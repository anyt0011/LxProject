; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: ArmCC [4d365d]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\06_project\cmsis_os2.o --asm_dir=.\06_Project\temp\ --list_dir=.\06_Project\temp\ --depend=.\06_project\cmsis_os2.d --cpu=Cortex-M4.fp.sp --apcs=interwork -O0 --diag_suppress=9931 -I../Core/Inc -I../Drivers/STM32F4xx_HAL_Driver/Inc -I../Drivers/STM32F4xx_HAL_Driver/Inc/Legacy -I../Drivers/CMSIS/Device/ST/STM32F4xx/Include -I../Drivers/CMSIS/Include -I../APP/Key/Inc -I../APP/Led/Inc -I../Middlewares/Third_Party/FreeRTOS/Source/include -I../Middlewares/Third_Party/FreeRTOS/Source/CMSIS_RTOS_V2 -I../Middlewares/Third_Party/FreeRTOS/Source/portable/RVDS/ARM_CM4F -I..\BSP\led\adaption -I..\BSP\led\driver -I..\BSP\led\handler -I.\RTE\_06_Project -IF:\software\ARM_ENV\Keil\Packs\ARM\CMSIS\5.9.0\CMSIS\Core\Include -IF:\software\ARM_ENV\Keil\Packs\Keil\STM32F4xx_DFP\2.17.1\Drivers\CMSIS\Device\ST\STM32F4xx\Include -D__MICROLIB -D__UVISION_VERSION=538 -D_RTE_ -DSTM32F411xE -D_RTE_ -DUSE_HAL_DRIVER -DSTM32F411xE --omf_browse=.\06_project\cmsis_os2.crf ../Middlewares/Third_Party/FreeRTOS/Source/CMSIS_RTOS_V2/cmsis_os2.c]
                          THUMB

                          AREA ||i.AllocBlock||, CODE, READONLY, ALIGN=1

                  AllocBlock PROC
;;;2372   */
;;;2373   static void *AllocBlock (MemPool_t *mp) {
000000  4601              MOV      r1,r0
;;;2374     MemPoolBlock_t *p = NULL;
000002  2000              MOVS     r0,#0
;;;2375   
;;;2376     if (mp->head != NULL) {
000004  680a              LDR      r2,[r1,#0]
000006  b112              CBZ      r2,|L1.14|
;;;2377       /* List of free block exists, get head block */
;;;2378       p = mp->head;
000008  6808              LDR      r0,[r1,#0]
;;;2379   
;;;2380       /* Head block is now next on the list */
;;;2381       mp->head = p->next;
00000a  6802              LDR      r2,[r0,#0]
00000c  600a              STR      r2,[r1,#0]
                  |L1.14|
;;;2382     }
;;;2383   
;;;2384     return (p);
;;;2385   }
00000e  4770              BX       lr
;;;2386   
                          ENDP


                          AREA ||i.CreateBlock||, CODE, READONLY, ALIGN=1

                  CreateBlock PROC
;;;2355   */
;;;2356   static void *CreateBlock (MemPool_t *mp) {
000000  b510              PUSH     {r4,lr}
000002  4601              MOV      r1,r0
;;;2357     MemPoolBlock_t *p = NULL;
000004  2000              MOVS     r0,#0
;;;2358   
;;;2359     if (mp->n < mp->bl_cnt) {
000006  e9d13206          LDRD     r3,r2,[r1,#0x18]
00000a  429a              CMP      r2,r3
00000c  d207              BCS      |L2.30|
;;;2360       /* Unallocated blocks exist, set pointer to new block */
;;;2361       p = (void *)(mp->mem_arr + (mp->bl_sz * mp->n));
00000e  69cc              LDR      r4,[r1,#0x1c]
000010  694b              LDR      r3,[r1,#0x14]
000012  688a              LDR      r2,[r1,#8]
000014  fb032004          MLA      r0,r3,r4,r2
;;;2362   
;;;2363       /* Increment block index */
;;;2364       mp->n += 1U;
000018  69ca              LDR      r2,[r1,#0x1c]
00001a  1c52              ADDS     r2,r2,#1
00001c  61ca              STR      r2,[r1,#0x1c]
                  |L2.30|
;;;2365     }
;;;2366   
;;;2367     return (p);
;;;2368   }
00001e  bd10              POP      {r4,pc}
;;;2369   
                          ENDP


                          AREA ||i.FreeBlock||, CODE, READONLY, ALIGN=1

                  FreeBlock PROC
;;;2389   */
;;;2390   static void FreeBlock (MemPool_t *mp, void *block) {
000000  460a              MOV      r2,r1
;;;2391     MemPoolBlock_t *p = block;
;;;2392   
;;;2393     /* Store current head into block memory space */
;;;2394     p->next = mp->head;
000002  6803              LDR      r3,[r0,#0]
000004  6013              STR      r3,[r2,#0]
;;;2395   
;;;2396     /* Store current block as new head */
;;;2397     mp->head = p;
000006  6002              STR      r2,[r0,#0]
;;;2398   }
000008  4770              BX       lr
;;;2399   #endif /* FREERTOS_MPOOL_H_ */
                          ENDP


                          AREA ||i.OS_Tick_GetCount||, CODE, READONLY, ALIGN=1

                  OS_Tick_GetCount PROC
;;;398    /* Get OS Tick count value */
;;;399    static uint32_t OS_Tick_GetCount (void) {
000000  f04f20e0          MOV      r0,#0xe000e000
;;;400      uint32_t load = SysTick->LOAD;
000004  6941              LDR      r1,[r0,#0x14]
;;;401      return  (load - SysTick->VAL);
000006  6980              LDR      r0,[r0,#0x18]
000008  1a08              SUBS     r0,r1,r0
;;;402    }
00000a  4770              BX       lr
;;;403    
                          ENDP


                          AREA ||i.OS_Tick_GetInterval||, CODE, READONLY, ALIGN=1

                  OS_Tick_GetInterval PROC
;;;409    /* Get OS Tick interval */
;;;410    static uint32_t OS_Tick_GetInterval (void) {
000000  f04f20e0          MOV      r0,#0xe000e000
;;;411      return (SysTick->LOAD + 1U);
000004  6940              LDR      r0,[r0,#0x14]
000006  1c40              ADDS     r0,r0,#1
;;;412    }
000008  4770              BX       lr
;;;413    
                          ENDP


                          AREA ||i.OS_Tick_GetOverflow||, CODE, READONLY, ALIGN=1

                  OS_Tick_GetOverflow PROC
;;;404    /* Get OS Tick overflow status */
;;;405    static uint32_t OS_Tick_GetOverflow (void) {
000000  f04f20e0          MOV      r0,#0xe000e000
;;;406      return ((SysTick->CTRL >> 16) & 1U);
000004  6900              LDR      r0,[r0,#0x10]
000006  f3c04000          UBFX     r0,r0,#16,#1
;;;407    }
00000a  4770              BX       lr
;;;408    
                          ENDP


                          AREA ||i.SysTick_Handler||, CODE, READONLY, ALIGN=1

                  SysTick_Handler PROC
;;;158    #if (USE_CUSTOM_SYSTICK_HANDLER_IMPLEMENTATION == 0)
;;;159    void SysTick_Handler (void) {
000000  b510              PUSH     {r4,lr}
;;;160      /* Clear overflow flag */
;;;161      SysTick->CTRL;
000002  f04f20e0          MOV      r0,#0xe000e000
000006  6900              LDR      r0,[r0,#0x10]
;;;162    
;;;163      if (xTaskGetSchedulerState() != taskSCHEDULER_NOT_STARTED) {
000008  f7fffffe          BL       xTaskGetSchedulerState
00000c  2801              CMP      r0,#1
00000e  d001              BEQ      |L7.20|
;;;164        /* Call tick handler */
;;;165        xPortSysTickHandler();
000010  f7fffffe          BL       xPortSysTickHandler
                  |L7.20|
;;;166      }
;;;167    }
000014  bd10              POP      {r4,pc}
;;;168    #endif
                          ENDP


                          AREA ||i.TimerCallback||, CODE, READONLY, ALIGN=1

                  TimerCallback PROC
;;;927    
;;;928    static void TimerCallback (TimerHandle_t hTimer) {
000000  b570              PUSH     {r4-r6,lr}
000002  4605              MOV      r5,r0
;;;929      TimerCallback_t *callb;
;;;930    
;;;931      callb = (TimerCallback_t *)pvTimerGetTimerID (hTimer);
000004  4628              MOV      r0,r5
000006  f7fffffe          BL       pvTimerGetTimerID
00000a  4604              MOV      r4,r0
;;;932    
;;;933      if (callb != NULL) {
00000c  b114              CBZ      r4,|L8.20|
;;;934        callb->func (callb->arg);
00000e  e9d41000          LDRD     r1,r0,[r4,#0]
000012  4788              BLX      r1
                  |L8.20|
;;;935      }
;;;936    }
000014  bd70              POP      {r4-r6,pc}
;;;937    
                          ENDP


                          AREA ||i.__get_IPSR||, CODE, READONLY, ALIGN=1

                  __get_IPSR PROC
;;;579     */
;;;580    __STATIC_INLINE uint32_t __get_IPSR(void)
000000  f3ef8005          MRS      r0,IPSR
;;;581    {
;;;582      register uint32_t __regIPSR          __ASM("ipsr");
;;;583      return(__regIPSR);
;;;584    }
000004  4770              BX       lr
;;;585    
                          ENDP


                          AREA ||i.osDelay||, CODE, READONLY, ALIGN=1

                  osDelay PROC
;;;879    
;;;880    osStatus_t osDelay (uint32_t ticks) {
000000  b570              PUSH     {r4-r6,lr}
000002  4605              MOV      r5,r0
;;;881      osStatus_t stat;
;;;882    
;;;883      if (IS_IRQ()) {
000004  f7fffffe          BL       __get_IPSR
000008  b110              CBZ      r0,|L10.16|
;;;884        stat = osErrorISR;
00000a  f06f0405          MVN      r4,#5
00000e  e004              B        |L10.26|
                  |L10.16|
;;;885      }
;;;886      else {
;;;887        stat = osOK;
000010  2400              MOVS     r4,#0
;;;888    
;;;889        if (ticks != 0U) {
000012  b115              CBZ      r5,|L10.26|
;;;890          vTaskDelay(ticks);
000014  4628              MOV      r0,r5
000016  f7fffffe          BL       vTaskDelay
                  |L10.26|
;;;891        }
;;;892      }
;;;893    
;;;894      return (stat);
00001a  4620              MOV      r0,r4
;;;895    }
00001c  bd70              POP      {r4-r6,pc}
;;;896    
                          ENDP


                          AREA ||i.osDelayUntil||, CODE, READONLY, ALIGN=1

                  osDelayUntil PROC
;;;896    
;;;897    osStatus_t osDelayUntil (uint32_t ticks) {
000000  b5f8              PUSH     {r3-r7,lr}
000002  4606              MOV      r6,r0
;;;898      TickType_t tcnt, delay;
;;;899      osStatus_t stat;
;;;900    
;;;901      if (IS_IRQ()) {
000004  f7fffffe          BL       __get_IPSR
000008  b110              CBZ      r0,|L11.16|
;;;902        stat = osErrorISR;
00000a  f06f0505          MVN      r5,#5
00000e  e00f              B        |L11.48|
                  |L11.16|
;;;903      }
;;;904      else {
;;;905        stat = osOK;
000010  2500              MOVS     r5,#0
;;;906        tcnt = xTaskGetTickCount();
000012  f7fffffe          BL       xTaskGetTickCount
000016  9000              STR      r0,[sp,#0]
;;;907    
;;;908        /* Determine remaining number of ticks to delay */
;;;909        delay = (TickType_t)ticks - tcnt;
000018  9800              LDR      r0,[sp,#0]
00001a  1a34              SUBS     r4,r6,r0
;;;910    
;;;911        /* Check if target tick has not expired */
;;;912        if((delay != 0U) && (0 == (delay >> (8 * sizeof(TickType_t) - 1)))) {
00001c  b134              CBZ      r4,|L11.44|
00001e  0fe0              LSRS     r0,r4,#31
000020  b920              CBNZ     r0,|L11.44|
;;;913          vTaskDelayUntil (&tcnt, delay);
000022  4621              MOV      r1,r4
000024  4668              MOV      r0,sp
000026  f7fffffe          BL       vTaskDelayUntil
00002a  e001              B        |L11.48|
                  |L11.44|
;;;914        }
;;;915        else
;;;916        {
;;;917          /* No delay or already expired */
;;;918          stat = osErrorParameter;
00002c  f06f0503          MVN      r5,#3
                  |L11.48|
;;;919        }
;;;920      }
;;;921    
;;;922      return (stat);
000030  4628              MOV      r0,r5
;;;923    }
000032  bdf8              POP      {r3-r7,pc}
;;;924    
                          ENDP


                          AREA ||i.osEventFlagsClear||, CODE, READONLY, ALIGN=1

                  osEventFlagsClear PROC
;;;1179   
;;;1180   uint32_t osEventFlagsClear (osEventFlagsId_t ef_id, uint32_t flags) {
000000  e92d41f0          PUSH     {r4-r8,lr}
000004  4605              MOV      r5,r0
000006  460e              MOV      r6,r1
;;;1181     EventGroupHandle_t hEventGroup = (EventGroupHandle_t)ef_id;
000008  462f              MOV      r7,r5
;;;1182     uint32_t rflags;
;;;1183   
;;;1184     if ((hEventGroup == NULL) || ((flags & EVENT_FLAGS_INVALID_BITS) != 0U)) {
00000a  b117              CBZ      r7,|L12.18|
00000c  f006407f          AND      r0,r6,#0xff000000
000010  b110              CBZ      r0,|L12.24|
                  |L12.18|
;;;1185       rflags = (uint32_t)osErrorParameter;
000012  f06f0403          MVN      r4,#3
000016  e013              B        |L12.64|
                  |L12.24|
;;;1186     }
;;;1187     else if (IS_IRQ()) {
000018  f7fffffe          BL       __get_IPSR
00001c  b158              CBZ      r0,|L12.54|
;;;1188     #if (configUSE_OS2_EVENTFLAGS_FROM_ISR == 0)
;;;1189       /* Enable timers and xTimerPendFunctionCall function to support osEventFlagsSet from ISR */
;;;1190       rflags = (uint32_t)osErrorResource;
;;;1191     #else
;;;1192       rflags = xEventGroupGetBitsFromISR (hEventGroup);
00001e  4638              MOV      r0,r7
000020  f7fffffe          BL       xEventGroupGetBitsFromISR
000024  4604              MOV      r4,r0
;;;1193   
;;;1194       if (xEventGroupClearBitsFromISR (hEventGroup, (EventBits_t)flags) == pdFAIL) {
000026  4631              MOV      r1,r6
000028  4638              MOV      r0,r7
00002a  f7fffffe          BL       xEventGroupClearBitsFromISR
00002e  b938              CBNZ     r0,|L12.64|
;;;1195         rflags = (uint32_t)osErrorResource;
000030  f06f0402          MVN      r4,#2
000034  e004              B        |L12.64|
                  |L12.54|
;;;1196       }
;;;1197     #endif
;;;1198     }
;;;1199     else {
;;;1200       rflags = xEventGroupClearBits (hEventGroup, (EventBits_t)flags);
000036  4631              MOV      r1,r6
000038  4638              MOV      r0,r7
00003a  f7fffffe          BL       xEventGroupClearBits
00003e  4604              MOV      r4,r0
                  |L12.64|
;;;1201     }
;;;1202   
;;;1203     return (rflags);
000040  4620              MOV      r0,r4
;;;1204   }
000042  e8bd81f0          POP      {r4-r8,pc}
;;;1205   
                          ENDP


                          AREA ||i.osEventFlagsDelete||, CODE, READONLY, ALIGN=1

                  osEventFlagsDelete PROC
;;;1272   
;;;1273   osStatus_t osEventFlagsDelete (osEventFlagsId_t ef_id) {
000000  b570              PUSH     {r4-r6,lr}
000002  4605              MOV      r5,r0
;;;1274     EventGroupHandle_t hEventGroup = (EventGroupHandle_t)ef_id;
000004  462e              MOV      r6,r5
;;;1275     osStatus_t stat;
;;;1276   
;;;1277   #ifndef USE_FreeRTOS_HEAP_1
;;;1278     if (IS_IRQ()) {
000006  f7fffffe          BL       __get_IPSR
00000a  b110              CBZ      r0,|L13.18|
;;;1279       stat = osErrorISR;
00000c  f06f0405          MVN      r4,#5
000010  e007              B        |L13.34|
                  |L13.18|
;;;1280     }
;;;1281     else if (hEventGroup == NULL) {
000012  b916              CBNZ     r6,|L13.26|
;;;1282       stat = osErrorParameter;
000014  f06f0403          MVN      r4,#3
000018  e003              B        |L13.34|
                  |L13.26|
;;;1283     }
;;;1284     else {
;;;1285       stat = osOK;
00001a  2400              MOVS     r4,#0
;;;1286       vEventGroupDelete (hEventGroup);
00001c  4630              MOV      r0,r6
00001e  f7fffffe          BL       vEventGroupDelete
                  |L13.34|
;;;1287     }
;;;1288   #else
;;;1289     stat = osError;
;;;1290   #endif
;;;1291   
;;;1292     return (stat);
000022  4620              MOV      r0,r4
;;;1293   }
000024  bd70              POP      {r4-r6,pc}
;;;1294   
                          ENDP


                          AREA ||i.osEventFlagsGet||, CODE, READONLY, ALIGN=1

                  osEventFlagsGet PROC
;;;1205   
;;;1206   uint32_t osEventFlagsGet (osEventFlagsId_t ef_id) {
000000  b570              PUSH     {r4-r6,lr}
000002  4605              MOV      r5,r0
;;;1207     EventGroupHandle_t hEventGroup = (EventGroupHandle_t)ef_id;
000004  462e              MOV      r6,r5
;;;1208     uint32_t rflags;
;;;1209   
;;;1210     if (ef_id == NULL) {
000006  b90d              CBNZ     r5,|L14.12|
;;;1211       rflags = 0U;
000008  2400              MOVS     r4,#0
00000a  e00c              B        |L14.38|
                  |L14.12|
;;;1212     }
;;;1213     else if (IS_IRQ()) {
00000c  f7fffffe          BL       __get_IPSR
000010  b120              CBZ      r0,|L14.28|
;;;1214       rflags = xEventGroupGetBitsFromISR (hEventGroup);
000012  4630              MOV      r0,r6
000014  f7fffffe          BL       xEventGroupGetBitsFromISR
000018  4604              MOV      r4,r0
00001a  e004              B        |L14.38|
                  |L14.28|
;;;1215     }
;;;1216     else {
;;;1217       rflags = xEventGroupGetBits (hEventGroup);
00001c  2100              MOVS     r1,#0
00001e  4630              MOV      r0,r6
000020  f7fffffe          BL       xEventGroupClearBits
000024  4604              MOV      r4,r0
                  |L14.38|
;;;1218     }
;;;1219   
;;;1220     return (rflags);
000026  4620              MOV      r0,r4
;;;1221   }
000028  bd70              POP      {r4-r6,pc}
;;;1222   
                          ENDP


                          AREA ||i.osEventFlagsNew||, CODE, READONLY, ALIGN=1

                  osEventFlagsNew PROC
;;;1108   
;;;1109   osEventFlagsId_t osEventFlagsNew (const osEventFlagsAttr_t *attr) {
000000  b570              PUSH     {r4-r6,lr}
000002  4604              MOV      r4,r0
;;;1110     EventGroupHandle_t hEventGroup;
;;;1111     int32_t mem;
;;;1112   
;;;1113     hEventGroup = NULL;
000004  2600              MOVS     r6,#0
;;;1114   
;;;1115     if (!IS_IRQ()) {
000006  f7fffffe          BL       __get_IPSR
00000a  b9d0              CBNZ     r0,|L15.66|
;;;1116       mem = -1;
00000c  1e75              SUBS     r5,r6,#1
;;;1117   
;;;1118       if (attr != NULL) {
00000e  b164              CBZ      r4,|L15.42|
;;;1119         if ((attr->cb_mem != NULL) && (attr->cb_size >= sizeof(StaticEventGroup_t))) {
000010  68a0              LDR      r0,[r4,#8]
000012  b120              CBZ      r0,|L15.30|
000014  68e0              LDR      r0,[r4,#0xc]
000016  2820              CMP      r0,#0x20
000018  d301              BCC      |L15.30|
;;;1120           mem = 1;
00001a  2501              MOVS     r5,#1
00001c  e006              B        |L15.44|
                  |L15.30|
;;;1121         }
;;;1122         else {
;;;1123           if ((attr->cb_mem == NULL) && (attr->cb_size == 0U)) {
00001e  68a0              LDR      r0,[r4,#8]
000020  b920              CBNZ     r0,|L15.44|
000022  68e0              LDR      r0,[r4,#0xc]
000024  b910              CBNZ     r0,|L15.44|
;;;1124             mem = 0;
000026  2500              MOVS     r5,#0
000028  e000              B        |L15.44|
                  |L15.42|
;;;1125           }
;;;1126         }
;;;1127       }
;;;1128       else {
;;;1129         mem = 0;
00002a  2500              MOVS     r5,#0
                  |L15.44|
;;;1130       }
;;;1131   
;;;1132       if (mem == 1) {
00002c  2d01              CMP      r5,#1
00002e  d104              BNE      |L15.58|
;;;1133         #if (configSUPPORT_STATIC_ALLOCATION == 1)
;;;1134         hEventGroup = xEventGroupCreateStatic (attr->cb_mem);
000030  68a0              LDR      r0,[r4,#8]
000032  f7fffffe          BL       xEventGroupCreateStatic
000036  4606              MOV      r6,r0
000038  e003              B        |L15.66|
                  |L15.58|
;;;1135         #endif
;;;1136       }
;;;1137       else {
;;;1138         if (mem == 0) {
00003a  b915              CBNZ     r5,|L15.66|
;;;1139           #if (configSUPPORT_DYNAMIC_ALLOCATION == 1)
;;;1140             hEventGroup = xEventGroupCreate();
00003c  f7fffffe          BL       xEventGroupCreate
000040  4606              MOV      r6,r0
                  |L15.66|
;;;1141           #endif
;;;1142         }
;;;1143       }
;;;1144     }
;;;1145   
;;;1146     return ((osEventFlagsId_t)hEventGroup);
000042  4630              MOV      r0,r6
;;;1147   }
000044  bd70              POP      {r4-r6,pc}
;;;1148   
                          ENDP


                          AREA ||i.osEventFlagsSet||, CODE, READONLY, ALIGN=2

                  osEventFlagsSet PROC
;;;1148   
;;;1149   uint32_t osEventFlagsSet (osEventFlagsId_t ef_id, uint32_t flags) {
000000  b5f8              PUSH     {r3-r7,lr}
000002  4605              MOV      r5,r0
000004  460e              MOV      r6,r1
;;;1150     EventGroupHandle_t hEventGroup = (EventGroupHandle_t)ef_id;
000006  462f              MOV      r7,r5
;;;1151     uint32_t rflags;
;;;1152     BaseType_t yield;
;;;1153   
;;;1154     if ((hEventGroup == NULL) || ((flags & EVENT_FLAGS_INVALID_BITS) != 0U)) {
000008  b117              CBZ      r7,|L16.16|
00000a  f006407f          AND      r0,r6,#0xff000000
00000e  b110              CBZ      r0,|L16.22|
                  |L16.16|
;;;1155       rflags = (uint32_t)osErrorParameter;
000010  f06f0403          MVN      r4,#3
000014  e01e              B        |L16.84|
                  |L16.22|
;;;1156     }
;;;1157     else if (IS_IRQ()) {
000016  f7fffffe          BL       __get_IPSR
00001a  b1b0              CBZ      r0,|L16.74|
;;;1158     #if (configUSE_OS2_EVENTFLAGS_FROM_ISR == 0)
;;;1159       (void)yield;
;;;1160       /* Enable timers and xTimerPendFunctionCall function to support osEventFlagsSet from ISR */
;;;1161       rflags = (uint32_t)osErrorResource;
;;;1162     #else
;;;1163       yield = pdFALSE;
00001c  2000              MOVS     r0,#0
00001e  9000              STR      r0,[sp,#0]
;;;1164   
;;;1165       if (xEventGroupSetBitsFromISR (hEventGroup, (EventBits_t)flags, &yield) == pdFAIL) {
000020  466a              MOV      r2,sp
000022  4631              MOV      r1,r6
000024  4638              MOV      r0,r7
000026  f7fffffe          BL       xEventGroupSetBitsFromISR
00002a  b910              CBNZ     r0,|L16.50|
;;;1166         rflags = (uint32_t)osErrorResource;
00002c  f06f0402          MVN      r4,#2
000030  e010              B        |L16.84|
                  |L16.50|
;;;1167       } else {
;;;1168         rflags = flags;
000032  4634              MOV      r4,r6
;;;1169         portYIELD_FROM_ISR (yield);
000034  9800              LDR      r0,[sp,#0]
000036  b168              CBZ      r0,|L16.84|
000038  f04f5080          MOV      r0,#0x10000000
00003c  4906              LDR      r1,|L16.88|
00003e  6008              STR      r0,[r1,#0]
000040  f3bf8f4f          DSB      
000044  f3bf8f6f          ISB      
000048  e004              B        |L16.84|
                  |L16.74|
;;;1170       }
;;;1171     #endif
;;;1172     }
;;;1173     else {
;;;1174       rflags = xEventGroupSetBits (hEventGroup, (EventBits_t)flags);
00004a  4631              MOV      r1,r6
00004c  4638              MOV      r0,r7
00004e  f7fffffe          BL       xEventGroupSetBits
000052  4604              MOV      r4,r0
                  |L16.84|
;;;1175     }
;;;1176   
;;;1177     return (rflags);
000054  4620              MOV      r0,r4
;;;1178   }
000056  bdf8              POP      {r3-r7,pc}
;;;1179   
                          ENDP

                  |L16.88|
                          DCD      0xe000ed04

                          AREA ||i.osEventFlagsWait||, CODE, READONLY, ALIGN=1

                  osEventFlagsWait PROC
;;;1222   
;;;1223   uint32_t osEventFlagsWait (osEventFlagsId_t ef_id, uint32_t flags, uint32_t options, uint32_t timeout) {
000000  e92d4ff8          PUSH     {r3-r11,lr}
000004  4680              MOV      r8,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
00000a  461f              MOV      r7,r3
;;;1224     EventGroupHandle_t hEventGroup = (EventGroupHandle_t)ef_id;
00000c  46c3              MOV      r11,r8
;;;1225     BaseType_t wait_all;
;;;1226     BaseType_t exit_clr;
;;;1227     uint32_t rflags;
;;;1228   
;;;1229     if ((hEventGroup == NULL) || ((flags & EVENT_FLAGS_INVALID_BITS) != 0U)) {
00000e  f1bb0f00          CMP      r11,#0
000012  d002              BEQ      |L17.26|
000014  f005407f          AND      r0,r5,#0xff000000
000018  b110              CBZ      r0,|L17.32|
                  |L17.26|
;;;1230       rflags = (uint32_t)osErrorParameter;
00001a  f06f0403          MVN      r4,#3
00001e  e034              B        |L17.138|
                  |L17.32|
;;;1231     }
;;;1232     else if (IS_IRQ()) {
000020  f7fffffe          BL       __get_IPSR
000024  b110              CBZ      r0,|L17.44|
;;;1233       rflags = (uint32_t)osErrorISR;
000026  f06f0405          MVN      r4,#5
00002a  e02e              B        |L17.138|
                  |L17.44|
;;;1234     }
;;;1235     else {
;;;1236       if (options & osFlagsWaitAll) {
00002c  f0060001          AND      r0,r6,#1
000030  b110              CBZ      r0,|L17.56|
;;;1237         wait_all = pdTRUE;
000032  f04f0901          MOV      r9,#1
000036  e001              B        |L17.60|
                  |L17.56|
;;;1238       } else {
;;;1239         wait_all = pdFAIL;
000038  f04f0900          MOV      r9,#0
                  |L17.60|
;;;1240       }
;;;1241   
;;;1242       if (options & osFlagsNoClear) {
00003c  f0060002          AND      r0,r6,#2
000040  b110              CBZ      r0,|L17.72|
;;;1243         exit_clr = pdFAIL;
000042  f04f0a00          MOV      r10,#0
000046  e001              B        |L17.76|
                  |L17.72|
;;;1244       } else {
;;;1245         exit_clr = pdTRUE;
000048  f04f0a01          MOV      r10,#1
                  |L17.76|
;;;1246       }
;;;1247   
;;;1248       rflags = xEventGroupWaitBits (hEventGroup, (EventBits_t)flags, exit_clr, wait_all, (TickType_t)timeout);
00004c  464b              MOV      r3,r9
00004e  4652              MOV      r2,r10
000050  4629              MOV      r1,r5
000052  4658              MOV      r0,r11
000054  9700              STR      r7,[sp,#0]
000056  f7fffffe          BL       xEventGroupWaitBits
00005a  4604              MOV      r4,r0
;;;1249   
;;;1250       if (options & osFlagsWaitAll) {
00005c  f0060001          AND      r0,r6,#1
000060  b150              CBZ      r0,|L17.120|
;;;1251         if ((flags & rflags) != flags) {
000062  ea050004          AND      r0,r5,r4
000066  42a8              CMP      r0,r5
000068  d00f              BEQ      |L17.138|
;;;1252           if (timeout > 0U) {
00006a  b117              CBZ      r7,|L17.114|
;;;1253             rflags = (uint32_t)osErrorTimeout;
00006c  f06f0401          MVN      r4,#1
000070  e00b              B        |L17.138|
                  |L17.114|
;;;1254           } else {
;;;1255             rflags = (uint32_t)osErrorResource;
000072  f06f0402          MVN      r4,#2
000076  e008              B        |L17.138|
                  |L17.120|
;;;1256           }
;;;1257         }
;;;1258       }
;;;1259       else {
;;;1260         if ((flags & rflags) == 0U) {
000078  ea050004          AND      r0,r5,r4
00007c  b928              CBNZ     r0,|L17.138|
;;;1261           if (timeout > 0U) {
00007e  b117              CBZ      r7,|L17.134|
;;;1262             rflags = (uint32_t)osErrorTimeout;
000080  f06f0401          MVN      r4,#1
000084  e001              B        |L17.138|
                  |L17.134|
;;;1263           } else {
;;;1264             rflags = (uint32_t)osErrorResource;
000086  f06f0402          MVN      r4,#2
                  |L17.138|
;;;1265           }
;;;1266         }
;;;1267       }
;;;1268     }
;;;1269   
;;;1270     return (rflags);
00008a  4620              MOV      r0,r4
;;;1271   }
00008c  e8bd8ff8          POP      {r3-r11,pc}
;;;1272   
                          ENDP


                          AREA ||i.osKernelGetInfo||, CODE, READONLY, ALIGN=2

                  osKernelGetInfo PROC
;;;221    
;;;222    osStatus_t osKernelGetInfo (osVersion_t *version, char *id_buf, uint32_t id_size) {
000000  b570              PUSH     {r4-r6,lr}
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
000006  4616              MOV      r6,r2
;;;223    
;;;224      if (version != NULL) {
000008  b114              CBZ      r4,|L18.16|
;;;225        /* Version encoding is major.minor.rev: mmnnnrrrr dec */
;;;226        version->api    = KERNEL_VERSION;
00000a  4807              LDR      r0,|L18.40|
00000c  6020              STR      r0,[r4,#0]
;;;227        version->kernel = KERNEL_VERSION;
00000e  6060              STR      r0,[r4,#4]
                  |L18.16|
;;;228      }
;;;229    
;;;230      if ((id_buf != NULL) && (id_size != 0U)) {
000010  b145              CBZ      r5,|L18.36|
000012  b13e              CBZ      r6,|L18.36|
;;;231        if (id_size > sizeof(KERNEL_ID)) {
000014  2e11              CMP      r6,#0x11
000016  d900              BLS      |L18.26|
;;;232          id_size = sizeof(KERNEL_ID);
000018  2611              MOVS     r6,#0x11
                  |L18.26|
;;;233        }
;;;234        memcpy(id_buf, KERNEL_ID, id_size);
00001a  4632              MOV      r2,r6
00001c  a103              ADR      r1,|L18.44|
00001e  4628              MOV      r0,r5
000020  f7fffffe          BL       __aeabi_memcpy
                  |L18.36|
;;;235      }
;;;236      return (osOK);
000024  2000              MOVS     r0,#0
;;;237    }
000026  bd70              POP      {r4-r6,pc}
;;;238    
                          ENDP

                  |L18.40|
                          DCD      0x05f5f531
                  |L18.44|
00002c  46726565          DCB      "FreeRTOS V10.3.1",0
000030  52544f53
000034  20563130
000038  2e332e31
00003c  00      
00003d  00                DCB      0
00003e  00                DCB      0
00003f  00                DCB      0

                          AREA ||i.osKernelGetState||, CODE, READONLY, ALIGN=2

                  osKernelGetState PROC
;;;238    
;;;239    osKernelState_t osKernelGetState (void) {
000000  b510              PUSH     {r4,lr}
;;;240      osKernelState_t state;
;;;241    
;;;242      switch (xTaskGetSchedulerState()) {
000002  f7fffffe          BL       xTaskGetSchedulerState
000006  b128              CBZ      r0,|L19.20|
000008  2801              CMP      r0,#1
00000a  d006              BEQ      |L19.26|
00000c  2802              CMP      r0,#2
00000e  d103              BNE      |L19.24|
;;;243        case taskSCHEDULER_RUNNING:
;;;244          state = osKernelRunning;
000010  2402              MOVS     r4,#2
;;;245          break;
000012  e00a              B        |L19.42|
                  |L19.20|
;;;246    
;;;247        case taskSCHEDULER_SUSPENDED:
;;;248          state = osKernelLocked;
000014  2403              MOVS     r4,#3
;;;249          break;
000016  e008              B        |L19.42|
                  |L19.24|
;;;250    
;;;251        case taskSCHEDULER_NOT_STARTED:
000018  bf00              NOP      
                  |L19.26|
;;;252        default:
;;;253          if (KernelState == osKernelReady) {
00001a  4805              LDR      r0,|L19.48|
00001c  6800              LDR      r0,[r0,#0]  ; KernelState
00001e  2801              CMP      r0,#1
000020  d101              BNE      |L19.38|
;;;254            state = osKernelReady;
000022  2401              MOVS     r4,#1
000024  e000              B        |L19.40|
                  |L19.38|
;;;255          } else {
;;;256            state = osKernelInactive;
000026  2400              MOVS     r4,#0
                  |L19.40|
;;;257          }
;;;258          break;
000028  bf00              NOP      
                  |L19.42|
00002a  bf00              NOP                            ;245
;;;259      }
;;;260    
;;;261      return (state);
00002c  4620              MOV      r0,r4
;;;262    }
00002e  bd10              POP      {r4,pc}
;;;263    
                          ENDP

                  |L19.48|
                          DCD      KernelState

                          AREA ||i.osKernelGetSysTimerCount||, CODE, READONLY, ALIGN=1

                  osKernelGetSysTimerCount PROC
;;;413    
;;;414    uint32_t osKernelGetSysTimerCount (void) {
000000  b570              PUSH     {r4-r6,lr}
;;;415      uint32_t irqmask = IS_IRQ_MASKED();
000002  bf00              NOP      
000004  f3ef8010          MRS      r0,PRIMASK
000008  b918              CBNZ     r0,|L20.18|
00000a  bf00              NOP      
00000c  f3ef8011          MRS      r0,BASEPRI
000010  b108              CBZ      r0,|L20.22|
                  |L20.18|
000012  2001              MOVS     r0,#1
000014  e000              B        |L20.24|
                  |L20.22|
000016  2000              MOVS     r0,#0
                  |L20.24|
000018  4606              MOV      r6,r0
;;;416      TickType_t ticks;
;;;417      uint32_t val;
;;;418    
;;;419      __disable_irq();
00001a  b672              CPSID    i
;;;420    
;;;421      ticks = xTaskGetTickCount();
00001c  f7fffffe          BL       xTaskGetTickCount
000020  4604              MOV      r4,r0
;;;422      val   = OS_Tick_GetCount();
000022  f7fffffe          BL       OS_Tick_GetCount
000026  4605              MOV      r5,r0
;;;423    
;;;424      if (OS_Tick_GetOverflow() != 0U) {
000028  f7fffffe          BL       OS_Tick_GetOverflow
00002c  b118              CBZ      r0,|L20.54|
;;;425        val = OS_Tick_GetCount();
00002e  f7fffffe          BL       OS_Tick_GetCount
000032  4605              MOV      r5,r0
;;;426        ticks++;
000034  1c64              ADDS     r4,r4,#1
                  |L20.54|
;;;427      }
;;;428      val += ticks * OS_Tick_GetInterval();
000036  f7fffffe          BL       OS_Tick_GetInterval
00003a  fb045500          MLA      r5,r4,r0,r5
;;;429    
;;;430      if (irqmask == 0U) {
00003e  b906              CBNZ     r6,|L20.66|
;;;431        __enable_irq();
000040  b662              CPSIE    i
                  |L20.66|
;;;432      }
;;;433    
;;;434      return (val);
000042  4628              MOV      r0,r5
;;;435    }
000044  bd70              POP      {r4-r6,pc}
;;;436    
                          ENDP


                          AREA ||i.osKernelGetSysTimerFreq||, CODE, READONLY, ALIGN=2

                  osKernelGetSysTimerFreq PROC
;;;436    
;;;437    uint32_t osKernelGetSysTimerFreq (void) {
000000  4801              LDR      r0,|L21.8|
;;;438      return (configCPU_CLOCK_HZ);
000002  6800              LDR      r0,[r0,#0]  ; SystemCoreClock
;;;439    }
000004  4770              BX       lr
;;;440    
                          ENDP

000006  0000              DCW      0x0000
                  |L21.8|
                          DCD      SystemCoreClock

                          AREA ||i.osKernelGetTickCount||, CODE, READONLY, ALIGN=1

                  osKernelGetTickCount PROC
;;;381    
;;;382    uint32_t osKernelGetTickCount (void) {
000000  b510              PUSH     {r4,lr}
;;;383      TickType_t ticks;
;;;384    
;;;385      if (IS_IRQ()) {
000002  f7fffffe          BL       __get_IPSR
000006  b118              CBZ      r0,|L22.16|
;;;386        ticks = xTaskGetTickCountFromISR();
000008  f7fffffe          BL       xTaskGetTickCountFromISR
00000c  4604              MOV      r4,r0
00000e  e002              B        |L22.22|
                  |L22.16|
;;;387      } else {
;;;388        ticks = xTaskGetTickCount();
000010  f7fffffe          BL       xTaskGetTickCount
000014  4604              MOV      r4,r0
                  |L22.22|
;;;389      }
;;;390    
;;;391      return (ticks);
000016  4620              MOV      r0,r4
;;;392    }
000018  bd10              POP      {r4,pc}
;;;393    
                          ENDP


                          AREA ||i.osKernelGetTickFreq||, CODE, READONLY, ALIGN=1

                  osKernelGetTickFreq PROC
;;;393    
;;;394    uint32_t osKernelGetTickFreq (void) {
000000  f44f707a          MOV      r0,#0x3e8
;;;395      return (configTICK_RATE_HZ);
;;;396    }
000004  4770              BX       lr
;;;397    
                          ENDP


                          AREA ||i.osKernelInitialize||, CODE, READONLY, ALIGN=2

                  osKernelInitialize PROC
;;;197    
;;;198    osStatus_t osKernelInitialize (void) {
000000  b510              PUSH     {r4,lr}
;;;199      osStatus_t stat;
;;;200    
;;;201      if (IS_IRQ()) {
000002  f7fffffe          BL       __get_IPSR
000006  b110              CBZ      r0,|L24.14|
;;;202        stat = osErrorISR;
000008  f06f0405          MVN      r4,#5
00000c  e009              B        |L24.34|
                  |L24.14|
;;;203      }
;;;204      else {
;;;205        if (KernelState == osKernelInactive) {
00000e  4806              LDR      r0,|L24.40|
000010  6800              LDR      r0,[r0,#0]  ; KernelState
000012  b920              CBNZ     r0,|L24.30|
;;;206          #if defined(USE_TRACE_EVENT_RECORDER)
;;;207            EvrFreeRTOSSetup(0U);
;;;208          #endif
;;;209          #if defined(USE_FreeRTOS_HEAP_5) && (HEAP_5_REGION_SETUP == 1)
;;;210            vPortDefineHeapRegions (configHEAP_5_REGIONS);
;;;211          #endif
;;;212          KernelState = osKernelReady;
000014  2001              MOVS     r0,#1
000016  4904              LDR      r1,|L24.40|
000018  6008              STR      r0,[r1,#0]  ; KernelState
;;;213          stat = osOK;
00001a  2400              MOVS     r4,#0
00001c  e001              B        |L24.34|
                  |L24.30|
;;;214        } else {
;;;215          stat = osError;
00001e  f04f34ff          MOV      r4,#0xffffffff
                  |L24.34|
;;;216        }
;;;217      }
;;;218    
;;;219      return (stat);
000022  4620              MOV      r0,r4
;;;220    }
000024  bd10              POP      {r4,pc}
;;;221    
                          ENDP

000026  0000              DCW      0x0000
                  |L24.40|
                          DCD      KernelState

                          AREA ||i.osKernelLock||, CODE, READONLY, ALIGN=1

                  osKernelLock PROC
;;;286    
;;;287    int32_t osKernelLock (void) {
000000  b510              PUSH     {r4,lr}
;;;288      int32_t lock;
;;;289    
;;;290      if (IS_IRQ()) {
000002  f7fffffe          BL       __get_IPSR
000006  b110              CBZ      r0,|L25.14|
;;;291        lock = (int32_t)osErrorISR;
000008  f06f0405          MVN      r4,#5
00000c  e012              B        |L25.52|
                  |L25.14|
;;;292      }
;;;293      else {
;;;294        switch (xTaskGetSchedulerState()) {
00000e  f7fffffe          BL       xTaskGetSchedulerState
000012  b120              CBZ      r0,|L25.30|
000014  2801              CMP      r0,#1
000016  d009              BEQ      |L25.44|
000018  2802              CMP      r0,#2
00001a  d106              BNE      |L25.42|
00001c  e001              B        |L25.34|
                  |L25.30|
;;;295          case taskSCHEDULER_SUSPENDED:
;;;296            lock = 1;
00001e  2401              MOVS     r4,#1
;;;297            break;
000020  e007              B        |L25.50|
                  |L25.34|
;;;298    
;;;299          case taskSCHEDULER_RUNNING:
;;;300            vTaskSuspendAll();
000022  f7fffffe          BL       vTaskSuspendAll
;;;301            lock = 0;
000026  2400              MOVS     r4,#0
;;;302            break;
000028  e003              B        |L25.50|
                  |L25.42|
;;;303    
;;;304          case taskSCHEDULER_NOT_STARTED:
00002a  bf00              NOP      
                  |L25.44|
;;;305          default:
;;;306            lock = (int32_t)osError;
00002c  f04f34ff          MOV      r4,#0xffffffff
;;;307            break;
000030  bf00              NOP      
                  |L25.50|
000032  bf00              NOP                            ;297
                  |L25.52|
;;;308        }
;;;309      }
;;;310    
;;;311      return (lock);
000034  4620              MOV      r0,r4
;;;312    }
000036  bd10              POP      {r4,pc}
;;;313    
                          ENDP


                          AREA ||i.osKernelRestoreLock||, CODE, READONLY, ALIGN=1

                  osKernelRestoreLock PROC
;;;345    
;;;346    int32_t osKernelRestoreLock (int32_t lock) {
000000  b510              PUSH     {r4,lr}
000002  4604              MOV      r4,r0
;;;347    
;;;348      if (IS_IRQ()) {
000004  f7fffffe          BL       __get_IPSR
000008  b110              CBZ      r0,|L26.16|
;;;349        lock = (int32_t)osErrorISR;
00000a  f06f0405          MVN      r4,#5
00000e  e021              B        |L26.84|
                  |L26.16|
;;;350      }
;;;351      else {
;;;352        switch (xTaskGetSchedulerState()) {
000010  f7fffffe          BL       xTaskGetSchedulerState
000014  b120              CBZ      r0,|L26.32|
000016  2801              CMP      r0,#1
000018  d018              BEQ      |L26.76|
00001a  2802              CMP      r0,#2
00001c  d115              BNE      |L26.74|
00001e  e000              B        |L26.34|
                  |L26.32|
;;;353          case taskSCHEDULER_SUSPENDED:
;;;354          case taskSCHEDULER_RUNNING:
000020  bf00              NOP      
                  |L26.34|
;;;355            if (lock == 1) {
000022  2c01              CMP      r4,#1
000024  d102              BNE      |L26.44|
;;;356              vTaskSuspendAll();
000026  f7fffffe          BL       vTaskSuspendAll
00002a  e00d              B        |L26.72|
                  |L26.44|
;;;357            }
;;;358            else {
;;;359              if (lock != 0) {
00002c  b114              CBZ      r4,|L26.52|
;;;360                lock = (int32_t)osError;
00002e  f04f34ff          MOV      r4,#0xffffffff
000032  e009              B        |L26.72|
                  |L26.52|
;;;361              }
;;;362              else {
;;;363                if (xTaskResumeAll() != pdTRUE) {
000034  f7fffffe          BL       xTaskResumeAll
000038  2801              CMP      r0,#1
00003a  d005              BEQ      |L26.72|
;;;364                  if (xTaskGetSchedulerState() != taskSCHEDULER_RUNNING) {
00003c  f7fffffe          BL       xTaskGetSchedulerState
000040  2802              CMP      r0,#2
000042  d001              BEQ      |L26.72|
;;;365                    lock = (int32_t)osError;
000044  f04f34ff          MOV      r4,#0xffffffff
                  |L26.72|
;;;366                  }
;;;367                }
;;;368              }
;;;369            }
;;;370            break;
000048  e003              B        |L26.82|
                  |L26.74|
;;;371    
;;;372          case taskSCHEDULER_NOT_STARTED:
00004a  bf00              NOP      
                  |L26.76|
;;;373          default:
;;;374            lock = (int32_t)osError;
00004c  f04f34ff          MOV      r4,#0xffffffff
;;;375            break;
000050  bf00              NOP      
                  |L26.82|
000052  bf00              NOP                            ;370
                  |L26.84|
;;;376        }
;;;377      }
;;;378    
;;;379      return (lock);
000054  4620              MOV      r0,r4
;;;380    }
000056  bd10              POP      {r4,pc}
;;;381    
                          ENDP


                          AREA ||i.osKernelStart||, CODE, READONLY, ALIGN=2

                  osKernelStart PROC
;;;263    
;;;264    osStatus_t osKernelStart (void) {
000000  b570              PUSH     {r4-r6,lr}
;;;265      osStatus_t stat;
;;;266    
;;;267      if (IS_IRQ()) {
000002  f7fffffe          BL       __get_IPSR
000006  b110              CBZ      r0,|L27.14|
;;;268        stat = osErrorISR;
000008  f06f0405          MVN      r4,#5
00000c  e01f              B        |L27.78|
                  |L27.14|
;;;269      }
;;;270      else {
;;;271        if (KernelState == osKernelReady) {
00000e  4811              LDR      r0,|L27.84|
000010  6800              LDR      r0,[r0,#0]  ; KernelState
000012  2801              CMP      r0,#1
000014  d119              BNE      |L27.74|
;;;272          /* Ensure SVC priority is at the reset value */
;;;273          SVC_Setup();
000016  bf00              NOP      
000018  1f80              SUBS     r0,r0,#6
00001a  2100              MOVS     r1,#0
00001c  2800              CMP      r0,#0
00001e  db04              BLT      |L27.42|
000020  070a              LSLS     r2,r1,#28
000022  0e13              LSRS     r3,r2,#24
000024  4a0c              LDR      r2,|L27.88|
000026  5413              STRB     r3,[r2,r0]
000028  e006              B        |L27.56|
                  |L27.42|
00002a  070a              LSLS     r2,r1,#28
00002c  0e15              LSRS     r5,r2,#24
00002e  4a0b              LDR      r2,|L27.92|
000030  f000030f          AND      r3,r0,#0xf
000034  1f1b              SUBS     r3,r3,#4
000036  54d5              STRB     r5,[r2,r3]
                  |L27.56|
000038  bf00              NOP      
00003a  bf00              NOP      
;;;274          /* Change state to enable IRQ masking check */
;;;275          KernelState = osKernelRunning;
00003c  2002              MOVS     r0,#2
00003e  4905              LDR      r1,|L27.84|
000040  6008              STR      r0,[r1,#0]  ; KernelState
;;;276          /* Start the kernel scheduler */
;;;277          vTaskStartScheduler();
000042  f7fffffe          BL       vTaskStartScheduler
;;;278          stat = osOK;
000046  2400              MOVS     r4,#0
000048  e001              B        |L27.78|
                  |L27.74|
;;;279        } else {
;;;280          stat = osError;
00004a  f04f34ff          MOV      r4,#0xffffffff
                  |L27.78|
;;;281        }
;;;282      }
;;;283    
;;;284      return (stat);
00004e  4620              MOV      r0,r4
;;;285    }
000050  bd70              POP      {r4-r6,pc}
;;;286    
                          ENDP

000052  0000              DCW      0x0000
                  |L27.84|
                          DCD      KernelState
                  |L27.88|
                          DCD      0xe000e400
                  |L27.92|
                          DCD      0xe000ed18

                          AREA ||i.osKernelUnlock||, CODE, READONLY, ALIGN=1

                  osKernelUnlock PROC
;;;313    
;;;314    int32_t osKernelUnlock (void) {
000000  b510              PUSH     {r4,lr}
;;;315      int32_t lock;
;;;316    
;;;317      if (IS_IRQ()) {
000002  f7fffffe          BL       __get_IPSR
000006  b110              CBZ      r0,|L28.14|
;;;318        lock = (int32_t)osErrorISR;
000008  f06f0405          MVN      r4,#5
00000c  e018              B        |L28.64|
                  |L28.14|
;;;319      }
;;;320      else {
;;;321        switch (xTaskGetSchedulerState()) {
00000e  f7fffffe          BL       xTaskGetSchedulerState
000012  b120              CBZ      r0,|L28.30|
000014  2801              CMP      r0,#1
000016  d00f              BEQ      |L28.56|
000018  2802              CMP      r0,#2
00001a  d10c              BNE      |L28.54|
00001c  e009              B        |L28.50|
                  |L28.30|
;;;322          case taskSCHEDULER_SUSPENDED:
;;;323            lock = 1;
00001e  2401              MOVS     r4,#1
;;;324    
;;;325            if (xTaskResumeAll() != pdTRUE) {
000020  f7fffffe          BL       xTaskResumeAll
000024  2801              CMP      r0,#1
000026  d003              BEQ      |L28.48|
;;;326              if (xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED) {
000028  f7fffffe          BL       xTaskGetSchedulerState
00002c  b900              CBNZ     r0,|L28.48|
;;;327                lock = (int32_t)osError;
00002e  1ea4              SUBS     r4,r4,#2
                  |L28.48|
;;;328              }
;;;329            }
;;;330            break;
000030  e005              B        |L28.62|
                  |L28.50|
;;;331    
;;;332          case taskSCHEDULER_RUNNING:
;;;333            lock = 0;
000032  2400              MOVS     r4,#0
;;;334            break;
000034  e003              B        |L28.62|
                  |L28.54|
;;;335    
;;;336          case taskSCHEDULER_NOT_STARTED:
000036  bf00              NOP      
                  |L28.56|
;;;337          default:
;;;338            lock = (int32_t)osError;
000038  f04f34ff          MOV      r4,#0xffffffff
;;;339            break;
00003c  bf00              NOP      
                  |L28.62|
00003e  bf00              NOP                            ;330
                  |L28.64|
;;;340        }
;;;341      }
;;;342    
;;;343      return (lock);
000040  4620              MOV      r0,r4
;;;344    }
000042  bd10              POP      {r4,pc}
;;;345    
                          ENDP


                          AREA ||i.osMemoryPoolAlloc||, CODE, READONLY, ALIGN=2

                  osMemoryPoolAlloc PROC
;;;2084   
;;;2085   void *osMemoryPoolAlloc (osMemoryPoolId_t mp_id, uint32_t timeout) {
000000  e92d41f0          PUSH     {r4-r8,lr}
000004  4607              MOV      r7,r0
000006  4688              MOV      r8,r1
;;;2086     MemPool_t *mp;
;;;2087     void *block;
;;;2088     uint32_t isrm;
;;;2089   
;;;2090     if (mp_id == NULL) {
000008  b90f              CBNZ     r7,|L29.14|
;;;2091       /* Invalid input parameters */
;;;2092       block = NULL;
00000a  2500              MOVS     r5,#0
00000c  e04a              B        |L29.164|
                  |L29.14|
;;;2093     }
;;;2094     else {
;;;2095       block = NULL;
00000e  2500              MOVS     r5,#0
;;;2096   
;;;2097       mp = (MemPool_t *)mp_id;
000010  463c              MOV      r4,r7
;;;2098   
;;;2099       if ((mp->status & MPOOL_STATUS) == MPOOL_STATUS) {
000012  6a20              LDR      r0,[r4,#0x20]
000014  4925              LDR      r1,|L29.172|
000016  4008              ANDS     r0,r0,r1
000018  4288              CMP      r0,r1
00001a  d143              BNE      |L29.164|
;;;2100         if (IS_IRQ()) {
00001c  f7fffffe          BL       __get_IPSR
000020  b340              CBZ      r0,|L29.116|
;;;2101           if (timeout == 0U) {
000022  f1b80f00          CMP      r8,#0
000026  d13d              BNE      |L29.164|
;;;2102             if (xSemaphoreTakeFromISR (mp->sem, NULL) == pdTRUE) {
000028  2200              MOVS     r2,#0
00002a  4611              MOV      r1,r2
00002c  6860              LDR      r0,[r4,#4]
00002e  f7fffffe          BL       xQueueReceiveFromISR
000032  2801              CMP      r0,#1
000034  d136              BNE      |L29.164|
;;;2103               if ((mp->status & MPOOL_STATUS) == MPOOL_STATUS) {
000036  6a20              LDR      r0,[r4,#0x20]
000038  491c              LDR      r1,|L29.172|
00003a  4008              ANDS     r0,r0,r1
00003c  4288              CMP      r0,r1
00003e  d131              BNE      |L29.164|
;;;2104                 isrm  = taskENTER_CRITICAL_FROM_ISR();
000040  bf00              NOP      
000042  2150              MOVS     r1,#0x50
000044  f3ef8011          MRS      r0,BASEPRI
000048  f3818811          MSR      BASEPRI,r1
00004c  f3bf8f4f          DSB      
000050  f3bf8f6f          ISB      
000054  bf00              NOP      
000056  4606              MOV      r6,r0
;;;2105   
;;;2106                 /* Get a block from the free-list */
;;;2107                 block = AllocBlock(mp);
000058  4620              MOV      r0,r4
00005a  f7fffffe          BL       AllocBlock
00005e  4605              MOV      r5,r0
;;;2108   
;;;2109                 if (block == NULL) {
000060  b91d              CBNZ     r5,|L29.106|
;;;2110                   /* List of free blocks is empty, 'create' new block */
;;;2111                   block = CreateBlock(mp);
000062  4620              MOV      r0,r4
000064  f7fffffe          BL       CreateBlock
000068  4605              MOV      r5,r0
                  |L29.106|
;;;2112                 }
;;;2113   
;;;2114                 taskEXIT_CRITICAL_FROM_ISR(isrm);
00006a  bf00              NOP      
00006c  f3868811          MSR      BASEPRI,r6
000070  bf00              NOP      
000072  e017              B        |L29.164|
                  |L29.116|
;;;2115               }
;;;2116             }
;;;2117           }
;;;2118         }
;;;2119         else {
;;;2120           if (xSemaphoreTake (mp->sem, (TickType_t)timeout) == pdTRUE) {
000074  4641              MOV      r1,r8
000076  6860              LDR      r0,[r4,#4]
000078  f7fffffe          BL       xQueueSemaphoreTake
00007c  2801              CMP      r0,#1
00007e  d111              BNE      |L29.164|
;;;2121             if ((mp->status & MPOOL_STATUS) == MPOOL_STATUS) {
000080  6a20              LDR      r0,[r4,#0x20]
000082  490a              LDR      r1,|L29.172|
000084  4008              ANDS     r0,r0,r1
000086  4288              CMP      r0,r1
000088  d10c              BNE      |L29.164|
;;;2122               taskENTER_CRITICAL();
00008a  f7fffffe          BL       vPortEnterCritical
;;;2123   
;;;2124               /* Get a block from the free-list */
;;;2125               block = AllocBlock(mp);
00008e  4620              MOV      r0,r4
000090  f7fffffe          BL       AllocBlock
000094  4605              MOV      r5,r0
;;;2126   
;;;2127               if (block == NULL) {
000096  b91d              CBNZ     r5,|L29.160|
;;;2128                 /* List of free blocks is empty, 'create' new block */
;;;2129                 block = CreateBlock(mp);
000098  4620              MOV      r0,r4
00009a  f7fffffe          BL       CreateBlock
00009e  4605              MOV      r5,r0
                  |L29.160|
;;;2130               }
;;;2131   
;;;2132               taskEXIT_CRITICAL();
0000a0  f7fffffe          BL       vPortExitCritical
                  |L29.164|
;;;2133             }
;;;2134           }
;;;2135         }
;;;2136       }
;;;2137     }
;;;2138   
;;;2139     return (block);
0000a4  4628              MOV      r0,r5
;;;2140   }
0000a6  e8bd81f0          POP      {r4-r8,pc}
;;;2141   
                          ENDP

0000aa  0000              DCW      0x0000
                  |L29.172|
                          DCD      0x5eed0000

                          AREA ||i.osMemoryPoolDelete||, CODE, READONLY, ALIGN=1

                  osMemoryPoolDelete PROC
;;;2309   
;;;2310   osStatus_t osMemoryPoolDelete (osMemoryPoolId_t mp_id) {
000000  b570              PUSH     {r4-r6,lr}
000002  4605              MOV      r5,r0
;;;2311     MemPool_t *mp;
;;;2312     osStatus_t stat;
;;;2313   
;;;2314     if (mp_id == NULL) {
000004  b915              CBNZ     r5,|L30.12|
;;;2315       /* Invalid input parameters */
;;;2316       stat = osErrorParameter;
000006  f06f0603          MVN      r6,#3
00000a  e02a              B        |L30.98|
                  |L30.12|
;;;2317     }
;;;2318     else if (IS_IRQ()) {
00000c  f7fffffe          BL       __get_IPSR
000010  b110              CBZ      r0,|L30.24|
;;;2319       stat = osErrorISR;
000012  f06f0605          MVN      r6,#5
000016  e024              B        |L30.98|
                  |L30.24|
;;;2320     }
;;;2321     else {
;;;2322       mp = (MemPool_t *)mp_id;
000018  462c              MOV      r4,r5
;;;2323   
;;;2324       taskENTER_CRITICAL();
00001a  f7fffffe          BL       vPortEnterCritical
;;;2325   
;;;2326       /* Invalidate control block status */
;;;2327       mp->status  = mp->status & 3U;
00001e  6a20              LDR      r0,[r4,#0x20]
000020  f0000003          AND      r0,r0,#3
000024  6220              STR      r0,[r4,#0x20]
;;;2328   
;;;2329       /* Wake-up tasks waiting for pool semaphore */
;;;2330       while (xSemaphoreGive (mp->sem) == pdTRUE);
000026  bf00              NOP      
                  |L30.40|
000028  2300              MOVS     r3,#0
00002a  461a              MOV      r2,r3
00002c  4619              MOV      r1,r3
00002e  6860              LDR      r0,[r4,#4]
000030  f7fffffe          BL       xQueueGenericSend
000034  2801              CMP      r0,#1
000036  d0f7              BEQ      |L30.40|
;;;2331   
;;;2332       mp->head    = NULL;
000038  2000              MOVS     r0,#0
00003a  6020              STR      r0,[r4,#0]
;;;2333       mp->bl_sz   = 0U;
00003c  6160              STR      r0,[r4,#0x14]
;;;2334       mp->bl_cnt  = 0U;
00003e  61a0              STR      r0,[r4,#0x18]
;;;2335   
;;;2336       if ((mp->status & 2U) != 0U) {
000040  6a20              LDR      r0,[r4,#0x20]
000042  f0000002          AND      r0,r0,#2
000046  b110              CBZ      r0,|L30.78|
;;;2337         /* Memory pool array allocated on heap */
;;;2338         vPortFree (mp->mem_arr);
000048  68a0              LDR      r0,[r4,#8]
00004a  f7fffffe          BL       vPortFree
                  |L30.78|
;;;2339       }
;;;2340       if ((mp->status & 1U) != 0U) {
00004e  6a20              LDR      r0,[r4,#0x20]
000050  f0000001          AND      r0,r0,#1
000054  b110              CBZ      r0,|L30.92|
;;;2341         /* Memory pool control block allocated on heap */
;;;2342         vPortFree (mp);
000056  4620              MOV      r0,r4
000058  f7fffffe          BL       vPortFree
                  |L30.92|
;;;2343       }
;;;2344   
;;;2345       taskEXIT_CRITICAL();
00005c  f7fffffe          BL       vPortExitCritical
;;;2346   
;;;2347       stat = osOK;
000060  2600              MOVS     r6,#0
                  |L30.98|
;;;2348     }
;;;2349   
;;;2350     return (stat);
000062  4630              MOV      r0,r6
;;;2351   }
000064  bd70              POP      {r4-r6,pc}
;;;2352   
                          ENDP


                          AREA ||i.osMemoryPoolFree||, CODE, READONLY, ALIGN=2

                  osMemoryPoolFree PROC
;;;2141   
;;;2142   osStatus_t osMemoryPoolFree (osMemoryPoolId_t mp_id, void *block) {
000000  e92d43f8          PUSH     {r3-r9,lr}
000004  4607              MOV      r7,r0
000006  4688              MOV      r8,r1
;;;2143     MemPool_t *mp;
;;;2144     osStatus_t stat;
;;;2145     uint32_t isrm;
;;;2146     BaseType_t yield;
;;;2147   
;;;2148     if ((mp_id == NULL) || (block == NULL)) {
000008  b117              CBZ      r7,|L31.16|
00000a  f1b80f00          CMP      r8,#0
00000e  d102              BNE      |L31.22|
                  |L31.16|
;;;2149       /* Invalid input parameters */
;;;2150       stat = osErrorParameter;
000010  f06f0503          MVN      r5,#3
000014  e05c              B        |L31.208|
                  |L31.22|
;;;2151     }
;;;2152     else {
;;;2153       mp = (MemPool_t *)mp_id;
000016  463c              MOV      r4,r7
;;;2154   
;;;2155       if ((mp->status & MPOOL_STATUS) != MPOOL_STATUS) {
000018  6a20              LDR      r0,[r4,#0x20]
00001a  492f              LDR      r1,|L31.216|
00001c  4008              ANDS     r0,r0,r1
00001e  4288              CMP      r0,r1
000020  d002              BEQ      |L31.40|
;;;2156         /* Invalid object status */
;;;2157         stat = osErrorResource;
000022  f06f0502          MVN      r5,#2
000026  e053              B        |L31.208|
                  |L31.40|
;;;2158       }
;;;2159       else if ((block < (void *)&mp->mem_arr[0]) || (block > (void*)&mp->mem_arr[mp->mem_sz-1])) {
000028  68a0              LDR      r0,[r4,#8]
00002a  4540              CMP      r0,r8
00002c  d805              BHI      |L31.58|
00002e  e9d41002          LDRD     r1,r0,[r4,#8]
000032  1e40              SUBS     r0,r0,#1
000034  4408              ADD      r0,r0,r1
000036  4540              CMP      r0,r8
000038  d202              BCS      |L31.64|
                  |L31.58|
;;;2160         /* Block pointer outside of memory array area */
;;;2161         stat = osErrorParameter;
00003a  f06f0503          MVN      r5,#3
00003e  e047              B        |L31.208|
                  |L31.64|
;;;2162       }
;;;2163       else {
;;;2164         stat = osOK;
000040  2500              MOVS     r5,#0
;;;2165   
;;;2166         if (IS_IRQ()) {
000042  f7fffffe          BL       __get_IPSR
000046  b360              CBZ      r0,|L31.162|
;;;2167           if (uxSemaphoreGetCountFromISR (mp->sem) == mp->bl_cnt) {
000048  6860              LDR      r0,[r4,#4]
00004a  f7fffffe          BL       uxQueueMessagesWaitingFromISR
00004e  69a1              LDR      r1,[r4,#0x18]
000050  4288              CMP      r0,r1
000052  d101              BNE      |L31.88|
;;;2168             stat = osErrorResource;
000054  1eed              SUBS     r5,r5,#3
000056  e03b              B        |L31.208|
                  |L31.88|
;;;2169           }
;;;2170           else {
;;;2171             isrm = taskENTER_CRITICAL_FROM_ISR();
000058  bf00              NOP      
00005a  2150              MOVS     r1,#0x50
00005c  f3ef8011          MRS      r0,BASEPRI
000060  f3818811          MSR      BASEPRI,r1
000064  f3bf8f4f          DSB      
000068  f3bf8f6f          ISB      
00006c  4606              MOV      r6,r0
00006e  bf00              NOP      
;;;2172   
;;;2173             /* Add block to the list of free blocks */
;;;2174             FreeBlock(mp, block);
000070  4641              MOV      r1,r8
000072  4620              MOV      r0,r4
000074  f7fffffe          BL       FreeBlock
;;;2175   
;;;2176             taskEXIT_CRITICAL_FROM_ISR(isrm);
000078  bf00              NOP      
00007a  f3868811          MSR      BASEPRI,r6
00007e  bf00              NOP      
;;;2177   
;;;2178             yield = pdFALSE;
000080  2000              MOVS     r0,#0
000082  9000              STR      r0,[sp,#0]
;;;2179             xSemaphoreGiveFromISR (mp->sem, &yield);
000084  4669              MOV      r1,sp
000086  6860              LDR      r0,[r4,#4]
000088  f7fffffe          BL       xQueueGiveFromISR
;;;2180             portYIELD_FROM_ISR (yield);
00008c  9800              LDR      r0,[sp,#0]
00008e  b1f8              CBZ      r0,|L31.208|
000090  f04f5080          MOV      r0,#0x10000000
000094  4911              LDR      r1,|L31.220|
000096  6008              STR      r0,[r1,#0]
000098  f3bf8f4f          DSB      
00009c  f3bf8f6f          ISB      
0000a0  e016              B        |L31.208|
                  |L31.162|
;;;2181           }
;;;2182         }
;;;2183         else {
;;;2184           if (uxSemaphoreGetCount (mp->sem) == mp->bl_cnt) {
0000a2  6860              LDR      r0,[r4,#4]
0000a4  f7fffffe          BL       uxQueueMessagesWaiting
0000a8  69a1              LDR      r1,[r4,#0x18]
0000aa  4288              CMP      r0,r1
0000ac  d102              BNE      |L31.180|
;;;2185             stat = osErrorResource;
0000ae  f06f0502          MVN      r5,#2
0000b2  e00d              B        |L31.208|
                  |L31.180|
;;;2186           }
;;;2187           else {
;;;2188             taskENTER_CRITICAL();
0000b4  f7fffffe          BL       vPortEnterCritical
;;;2189   
;;;2190             /* Add block to the list of free blocks */
;;;2191             FreeBlock(mp, block);
0000b8  4641              MOV      r1,r8
0000ba  4620              MOV      r0,r4
0000bc  f7fffffe          BL       FreeBlock
;;;2192   
;;;2193             taskEXIT_CRITICAL();
0000c0  f7fffffe          BL       vPortExitCritical
;;;2194   
;;;2195             xSemaphoreGive (mp->sem);
0000c4  2300              MOVS     r3,#0
0000c6  461a              MOV      r2,r3
0000c8  4619              MOV      r1,r3
0000ca  6860              LDR      r0,[r4,#4]
0000cc  f7fffffe          BL       xQueueGenericSend
                  |L31.208|
;;;2196           }
;;;2197         }
;;;2198       }
;;;2199     }
;;;2200   
;;;2201     return (stat);
0000d0  4628              MOV      r0,r5
;;;2202   }
0000d2  e8bd83f8          POP      {r3-r9,pc}
;;;2203   
                          ENDP

0000d6  0000              DCW      0x0000
                  |L31.216|
                          DCD      0x5eed0000
                  |L31.220|
                          DCD      0xe000ed04

                          AREA ||i.osMemoryPoolGetBlockSize||, CODE, READONLY, ALIGN=2

                  osMemoryPoolGetBlockSize PROC
;;;2227   
;;;2228   uint32_t osMemoryPoolGetBlockSize (osMemoryPoolId_t mp_id) {
000000  b510              PUSH     {r4,lr}
000002  4601              MOV      r1,r0
;;;2229     MemPool_t *mp;
;;;2230     uint32_t  sz;
;;;2231   
;;;2232     if (mp_id == NULL) {
000004  b909              CBNZ     r1,|L32.10|
;;;2233       /* Invalid input parameters */
;;;2234       sz = 0U;
000006  2000              MOVS     r0,#0
000008  e008              B        |L32.28|
                  |L32.10|
;;;2235     }
;;;2236     else {
;;;2237       mp = (MemPool_t *)mp_id;
00000a  460a              MOV      r2,r1
;;;2238   
;;;2239       if ((mp->status & MPOOL_STATUS) != MPOOL_STATUS) {
00000c  6a13              LDR      r3,[r2,#0x20]
00000e  4c04              LDR      r4,|L32.32|
000010  4023              ANDS     r3,r3,r4
000012  42a3              CMP      r3,r4
000014  d001              BEQ      |L32.26|
;;;2240         /* Invalid object status */
;;;2241         sz = 0U;
000016  2000              MOVS     r0,#0
000018  e000              B        |L32.28|
                  |L32.26|
;;;2242       }
;;;2243       else {
;;;2244         sz = mp->bl_sz;
00001a  6950              LDR      r0,[r2,#0x14]
                  |L32.28|
;;;2245       }
;;;2246     }
;;;2247   
;;;2248     /* Return memory block size in bytes */
;;;2249     return (sz);
;;;2250   }
00001c  bd10              POP      {r4,pc}
;;;2251   
                          ENDP

00001e  0000              DCW      0x0000
                  |L32.32|
                          DCD      0x5eed0000

                          AREA ||i.osMemoryPoolGetCapacity||, CODE, READONLY, ALIGN=2

                  osMemoryPoolGetCapacity PROC
;;;2203   
;;;2204   uint32_t osMemoryPoolGetCapacity (osMemoryPoolId_t mp_id) {
000000  b510              PUSH     {r4,lr}
000002  4601              MOV      r1,r0
;;;2205     MemPool_t *mp;
;;;2206     uint32_t  n;
;;;2207   
;;;2208     if (mp_id == NULL) {
000004  b909              CBNZ     r1,|L33.10|
;;;2209       /* Invalid input parameters */
;;;2210       n = 0U;
000006  2000              MOVS     r0,#0
000008  e008              B        |L33.28|
                  |L33.10|
;;;2211     }
;;;2212     else {
;;;2213       mp = (MemPool_t *)mp_id;
00000a  460a              MOV      r2,r1
;;;2214   
;;;2215       if ((mp->status & MPOOL_STATUS) != MPOOL_STATUS) {
00000c  6a13              LDR      r3,[r2,#0x20]
00000e  4c04              LDR      r4,|L33.32|
000010  4023              ANDS     r3,r3,r4
000012  42a3              CMP      r3,r4
000014  d001              BEQ      |L33.26|
;;;2216         /* Invalid object status */
;;;2217         n = 0U;
000016  2000              MOVS     r0,#0
000018  e000              B        |L33.28|
                  |L33.26|
;;;2218       }
;;;2219       else {
;;;2220         n = mp->bl_cnt;
00001a  6990              LDR      r0,[r2,#0x18]
                  |L33.28|
;;;2221       }
;;;2222     }
;;;2223   
;;;2224     /* Return maximum number of memory blocks */
;;;2225     return (n);
;;;2226   }
00001c  bd10              POP      {r4,pc}
;;;2227   
                          ENDP

00001e  0000              DCW      0x0000
                  |L33.32|
                          DCD      0x5eed0000

                          AREA ||i.osMemoryPoolGetCount||, CODE, READONLY, ALIGN=2

                  osMemoryPoolGetCount PROC
;;;2251   
;;;2252   uint32_t osMemoryPoolGetCount (osMemoryPoolId_t mp_id) {
000000  b570              PUSH     {r4-r6,lr}
000002  4606              MOV      r6,r0
;;;2253     MemPool_t *mp;
;;;2254     uint32_t  n;
;;;2255   
;;;2256     if (mp_id == NULL) {
000004  b90e              CBNZ     r6,|L34.10|
;;;2257       /* Invalid input parameters */
;;;2258       n = 0U;
000006  2400              MOVS     r4,#0
000008  e015              B        |L34.54|
                  |L34.10|
;;;2259     }
;;;2260     else {
;;;2261       mp = (MemPool_t *)mp_id;
00000a  4635              MOV      r5,r6
;;;2262   
;;;2263       if ((mp->status & MPOOL_STATUS) != MPOOL_STATUS) {
00000c  6a28              LDR      r0,[r5,#0x20]
00000e  490b              LDR      r1,|L34.60|
000010  4008              ANDS     r0,r0,r1
000012  4288              CMP      r0,r1
000014  d001              BEQ      |L34.26|
;;;2264         /* Invalid object status */
;;;2265         n = 0U;
000016  2400              MOVS     r4,#0
000018  e00d              B        |L34.54|
                  |L34.26|
;;;2266       }
;;;2267       else {
;;;2268         if (IS_IRQ()) {
00001a  f7fffffe          BL       __get_IPSR
00001e  b120              CBZ      r0,|L34.42|
;;;2269           n = uxSemaphoreGetCountFromISR (mp->sem);
000020  6868              LDR      r0,[r5,#4]
000022  f7fffffe          BL       uxQueueMessagesWaitingFromISR
000026  4604              MOV      r4,r0
000028  e003              B        |L34.50|
                  |L34.42|
;;;2270         } else {
;;;2271           n = uxSemaphoreGetCount        (mp->sem);
00002a  6868              LDR      r0,[r5,#4]
00002c  f7fffffe          BL       uxQueueMessagesWaiting
000030  4604              MOV      r4,r0
                  |L34.50|
;;;2272         }
;;;2273   
;;;2274         n = mp->bl_cnt - n;
000032  69a8              LDR      r0,[r5,#0x18]
000034  1b04              SUBS     r4,r0,r4
                  |L34.54|
;;;2275       }
;;;2276     }
;;;2277   
;;;2278     /* Return number of memory blocks used */
;;;2279     return (n);
000036  4620              MOV      r0,r4
;;;2280   }
000038  bd70              POP      {r4-r6,pc}
;;;2281   
                          ENDP

00003a  0000              DCW      0x0000
                  |L34.60|
                          DCD      0x5eed0000

                          AREA ||i.osMemoryPoolGetName||, CODE, READONLY, ALIGN=1

                  osMemoryPoolGetName PROC
;;;2067   
;;;2068   const char *osMemoryPoolGetName (osMemoryPoolId_t mp_id) {
000000  b570              PUSH     {r4-r6,lr}
000002  4605              MOV      r5,r0
;;;2069     MemPool_t *mp = (osMemoryPoolId_t)mp_id;
000004  462e              MOV      r6,r5
;;;2070     const char *p;
;;;2071   
;;;2072     if (IS_IRQ()) {
000006  f7fffffe          BL       __get_IPSR
00000a  b108              CBZ      r0,|L35.16|
;;;2073       p = NULL;
00000c  2400              MOVS     r4,#0
00000e  e003              B        |L35.24|
                  |L35.16|
;;;2074     }
;;;2075     else if (mp_id == NULL) {
000010  b90d              CBNZ     r5,|L35.22|
;;;2076       p = NULL;
000012  2400              MOVS     r4,#0
000014  e000              B        |L35.24|
                  |L35.22|
;;;2077     }
;;;2078     else {
;;;2079       p = mp->name;
000016  6934              LDR      r4,[r6,#0x10]
                  |L35.24|
;;;2080     }
;;;2081   
;;;2082     return (p);
000018  4620              MOV      r0,r4
;;;2083   }
00001a  bd70              POP      {r4-r6,pc}
;;;2084   
                          ENDP


                          AREA ||i.osMemoryPoolGetSpace||, CODE, READONLY, ALIGN=2

                  osMemoryPoolGetSpace PROC
;;;2281   
;;;2282   uint32_t osMemoryPoolGetSpace (osMemoryPoolId_t mp_id) {
000000  b570              PUSH     {r4-r6,lr}
000002  4605              MOV      r5,r0
;;;2283     MemPool_t *mp;
;;;2284     uint32_t  n;
;;;2285   
;;;2286     if (mp_id == NULL) {
000004  b90d              CBNZ     r5,|L36.10|
;;;2287       /* Invalid input parameters */
;;;2288       n = 0U;
000006  2400              MOVS     r4,#0
000008  e013              B        |L36.50|
                  |L36.10|
;;;2289     }
;;;2290     else {
;;;2291       mp = (MemPool_t *)mp_id;
00000a  462e              MOV      r6,r5
;;;2292   
;;;2293       if ((mp->status & MPOOL_STATUS) != MPOOL_STATUS) {
00000c  6a30              LDR      r0,[r6,#0x20]
00000e  490a              LDR      r1,|L36.56|
000010  4008              ANDS     r0,r0,r1
000012  4288              CMP      r0,r1
000014  d001              BEQ      |L36.26|
;;;2294         /* Invalid object status */
;;;2295         n = 0U;
000016  2400              MOVS     r4,#0
000018  e00b              B        |L36.50|
                  |L36.26|
;;;2296       }
;;;2297       else {
;;;2298         if (IS_IRQ()) {
00001a  f7fffffe          BL       __get_IPSR
00001e  b120              CBZ      r0,|L36.42|
;;;2299           n = uxSemaphoreGetCountFromISR (mp->sem);
000020  6870              LDR      r0,[r6,#4]
000022  f7fffffe          BL       uxQueueMessagesWaitingFromISR
000026  4604              MOV      r4,r0
000028  e003              B        |L36.50|
                  |L36.42|
;;;2300         } else {
;;;2301           n = uxSemaphoreGetCount        (mp->sem);
00002a  6870              LDR      r0,[r6,#4]
00002c  f7fffffe          BL       uxQueueMessagesWaiting
000030  4604              MOV      r4,r0
                  |L36.50|
;;;2302         }
;;;2303       }
;;;2304     }
;;;2305   
;;;2306     /* Return number of memory blocks available */
;;;2307     return (n);
000032  4620              MOV      r0,r4
;;;2308   }
000034  bd70              POP      {r4-r6,pc}
;;;2309   
                          ENDP

000036  0000              DCW      0x0000
                  |L36.56|
                          DCD      0x5eed0000

                          AREA ||i.osMemoryPoolNew||, CODE, READONLY, ALIGN=2

                  osMemoryPoolNew PROC
;;;1950   
;;;1951   osMemoryPoolId_t osMemoryPoolNew (uint32_t block_count, uint32_t block_size, const osMemoryPoolAttr_t *attr) {
000000  e92d5ff0          PUSH     {r4-r12,lr}
000004  4606              MOV      r6,r0
000006  460f              MOV      r7,r1
000008  4615              MOV      r5,r2
;;;1952     MemPool_t *mp;
;;;1953     const char *name;
;;;1954     int32_t mem_cb, mem_mp;
;;;1955     uint32_t sz;
;;;1956   
;;;1957     if (IS_IRQ()) {
00000a  f7fffffe          BL       __get_IPSR
00000e  b108              CBZ      r0,|L37.20|
;;;1958       mp = NULL;
000010  2400              MOVS     r4,#0
000012  e079              B        |L37.264|
                  |L37.20|
;;;1959     }
;;;1960     else if ((block_count == 0U) || (block_size == 0U)) {
000014  b106              CBZ      r6,|L37.24|
000016  b90f              CBNZ     r7,|L37.28|
                  |L37.24|
;;;1961       mp = NULL;
000018  2400              MOVS     r4,#0
00001a  e075              B        |L37.264|
                  |L37.28|
;;;1962     }
;;;1963     else {
;;;1964       mp = NULL;
00001c  2400              MOVS     r4,#0
;;;1965       sz = MEMPOOL_ARR_SIZE (block_count, block_size);
00001e  1cf8              ADDS     r0,r7,#3
000020  0880              LSRS     r0,r0,#2
000022  0080              LSLS     r0,r0,#2
000024  fb00f906          MUL      r9,r0,r6
;;;1966   
;;;1967       name = NULL;
000028  46a3              MOV      r11,r4
;;;1968       mem_cb = -1;
00002a  f04f38ff          MOV      r8,#0xffffffff
;;;1969       mem_mp = -1;
00002e  f04f3aff          MOV      r10,#0xffffffff
;;;1970   
;;;1971       if (attr != NULL) {
000032  b325              CBZ      r5,|L37.126|
;;;1972         if (attr->name != NULL) {
000034  6828              LDR      r0,[r5,#0]
000036  b108              CBZ      r0,|L37.60|
;;;1973           name = attr->name;
000038  f8d5b000          LDR      r11,[r5,#0]
                  |L37.60|
;;;1974         }
;;;1975   
;;;1976         if ((attr->cb_mem != NULL) && (attr->cb_size >= sizeof(MemPool_t))) {
00003c  68a8              LDR      r0,[r5,#8]
00003e  b128              CBZ      r0,|L37.76|
000040  68e8              LDR      r0,[r5,#0xc]
000042  2874              CMP      r0,#0x74
000044  d302              BCC      |L37.76|
;;;1977           /* Static control block is provided */
;;;1978           mem_cb = 1;
000046  f04f0801          MOV      r8,#1
00004a  e005              B        |L37.88|
                  |L37.76|
;;;1979         }
;;;1980         else if ((attr->cb_mem == NULL) && (attr->cb_size == 0U)) {
00004c  68a8              LDR      r0,[r5,#8]
00004e  b918              CBNZ     r0,|L37.88|
000050  68e8              LDR      r0,[r5,#0xc]
000052  b908              CBNZ     r0,|L37.88|
;;;1981           /* Allocate control block memory on heap */
;;;1982           mem_cb = 0;
000054  f04f0800          MOV      r8,#0
                  |L37.88|
;;;1983         }
;;;1984   
;;;1985         if ((attr->mp_mem == NULL) && (attr->mp_size == 0U)) {
000058  6928              LDR      r0,[r5,#0x10]
00005a  b920              CBNZ     r0,|L37.102|
00005c  6968              LDR      r0,[r5,#0x14]
00005e  b910              CBNZ     r0,|L37.102|
;;;1986           /* Allocate memory array on heap */
;;;1987             mem_mp = 0;
000060  f04f0a00          MOV      r10,#0
000064  e00e              B        |L37.132|
                  |L37.102|
;;;1988         }
;;;1989         else {
;;;1990           if (attr->mp_mem != NULL) {
000066  6928              LDR      r0,[r5,#0x10]
000068  b160              CBZ      r0,|L37.132|
;;;1991             /* Check if array is 4-byte aligned */
;;;1992             if (((uint32_t)attr->mp_mem & 3U) == 0U) {
00006a  7c28              LDRB     r0,[r5,#0x10]
00006c  f0000003          AND      r0,r0,#3
000070  b940              CBNZ     r0,|L37.132|
;;;1993               /* Check if array big enough */
;;;1994               if (attr->mp_size >= sz) {
000072  6968              LDR      r0,[r5,#0x14]
000074  4548              CMP      r0,r9
000076  d305              BCC      |L37.132|
;;;1995                 /* Static memory pool array is provided */
;;;1996                 mem_mp = 1;
000078  f04f0a01          MOV      r10,#1
00007c  e002              B        |L37.132|
                  |L37.126|
;;;1997               }
;;;1998             }
;;;1999           }
;;;2000         }
;;;2001       }
;;;2002       else {
;;;2003         /* Attributes not provided, allocate memory on heap */
;;;2004         mem_cb = 0;
00007e  f04f0800          MOV      r8,#0
;;;2005         mem_mp = 0;
000082  46c2              MOV      r10,r8
                  |L37.132|
;;;2006       }
;;;2007   
;;;2008       if (mem_cb == 0) {
000084  f1b80f00          CMP      r8,#0
000088  d104              BNE      |L37.148|
;;;2009         mp = pvPortMalloc (sizeof(MemPool_t));
00008a  2074              MOVS     r0,#0x74
00008c  f7fffffe          BL       pvPortMalloc
000090  4604              MOV      r4,r0
000092  e000              B        |L37.150|
                  |L37.148|
;;;2010       } else {
;;;2011         mp = attr->cb_mem;
000094  68ac              LDR      r4,[r5,#8]
                  |L37.150|
;;;2012       }
;;;2013   
;;;2014       if (mp != NULL) {
000096  b194              CBZ      r4,|L37.190|
;;;2015         /* Create a semaphore (max count == initial count == block_count) */
;;;2016         #if (configSUPPORT_STATIC_ALLOCATION == 1)
;;;2017           mp->sem = xSemaphoreCreateCountingStatic (block_count, block_count, &mp->mem_sem);
000098  f1040224          ADD      r2,r4,#0x24
00009c  4631              MOV      r1,r6
00009e  4630              MOV      r0,r6
0000a0  f7fffffe          BL       xQueueCreateCountingSemaphoreStatic
0000a4  6060              STR      r0,[r4,#4]
;;;2018         #elif (configSUPPORT_DYNAMIC_ALLOCATION == 1)
;;;2019           mp->sem = xSemaphoreCreateCounting (block_count, block_count);
;;;2020         #else
;;;2021           mp->sem == NULL;
;;;2022         #endif
;;;2023   
;;;2024         if (mp->sem != NULL) {
0000a6  6860              LDR      r0,[r4,#4]
0000a8  b148              CBZ      r0,|L37.190|
;;;2025           /* Setup memory array */
;;;2026           if (mem_mp == 0) {
0000aa  f1ba0f00          CMP      r10,#0
0000ae  d104              BNE      |L37.186|
;;;2027             mp->mem_arr = pvPortMalloc (sz);
0000b0  4648              MOV      r0,r9
0000b2  f7fffffe          BL       pvPortMalloc
0000b6  60a0              STR      r0,[r4,#8]
0000b8  e001              B        |L37.190|
                  |L37.186|
;;;2028           } else {
;;;2029             mp->mem_arr = attr->mp_mem;
0000ba  6928              LDR      r0,[r5,#0x10]
0000bc  60a0              STR      r0,[r4,#8]
                  |L37.190|
;;;2030           }
;;;2031         }
;;;2032       }
;;;2033   
;;;2034       if ((mp != NULL) && (mp->mem_arr != NULL)) {
0000be  b1dc              CBZ      r4,|L37.248|
0000c0  68a0              LDR      r0,[r4,#8]
0000c2  b1c8              CBZ      r0,|L37.248|
;;;2035         /* Memory pool can be created */
;;;2036         mp->head    = NULL;
0000c4  2000              MOVS     r0,#0
0000c6  6020              STR      r0,[r4,#0]
;;;2037         mp->mem_sz  = sz;
0000c8  f8c4900c          STR      r9,[r4,#0xc]
;;;2038         mp->name    = name;
0000cc  f8c4b010          STR      r11,[r4,#0x10]
;;;2039         mp->bl_sz   = block_size;
0000d0  6167              STR      r7,[r4,#0x14]
;;;2040         mp->bl_cnt  = block_count;
0000d2  61a6              STR      r6,[r4,#0x18]
;;;2041         mp->n       = 0U;
0000d4  61e0              STR      r0,[r4,#0x1c]
;;;2042   
;;;2043         /* Set heap allocated memory flags */
;;;2044         mp->status = MPOOL_STATUS;
0000d6  480e              LDR      r0,|L37.272|
0000d8  6220              STR      r0,[r4,#0x20]
;;;2045   
;;;2046         if (mem_cb == 0) {
0000da  f1b80f00          CMP      r8,#0
0000de  d103              BNE      |L37.232|
;;;2047           /* Control block on heap */
;;;2048           mp->status |= 1U;
0000e0  6a20              LDR      r0,[r4,#0x20]
0000e2  f0400001          ORR      r0,r0,#1
0000e6  6220              STR      r0,[r4,#0x20]
                  |L37.232|
;;;2049         }
;;;2050         if (mem_mp == 0) {
0000e8  f1ba0f00          CMP      r10,#0
0000ec  d10c              BNE      |L37.264|
;;;2051           /* Memory array on heap */
;;;2052           mp->status |= 2U;
0000ee  6a20              LDR      r0,[r4,#0x20]
0000f0  f0400002          ORR      r0,r0,#2
0000f4  6220              STR      r0,[r4,#0x20]
0000f6  e007              B        |L37.264|
                  |L37.248|
;;;2053         }
;;;2054       }
;;;2055       else {
;;;2056         /* Memory pool cannot be created, release allocated resources */
;;;2057         if ((mem_cb == 0) && (mp != NULL)) {
0000f8  f1b80f00          CMP      r8,#0
0000fc  d103              BNE      |L37.262|
0000fe  b114              CBZ      r4,|L37.262|
;;;2058           /* Free control block memory */
;;;2059           vPortFree (mp);
000100  4620              MOV      r0,r4
000102  f7fffffe          BL       vPortFree
                  |L37.262|
;;;2060         }
;;;2061         mp = NULL;
000106  2400              MOVS     r4,#0
                  |L37.264|
;;;2062       }
;;;2063     }
;;;2064   
;;;2065     return (mp);
000108  4620              MOV      r0,r4
;;;2066   }
00010a  e8bd9ff0          POP      {r4-r12,pc}
;;;2067   
                          ENDP

00010e  0000              DCW      0x0000
                  |L37.272|
                          DCD      0x5eed0000

                          AREA ||i.osMessageQueueDelete||, CODE, READONLY, ALIGN=1

                  osMessageQueueDelete PROC
;;;1916   
;;;1917   osStatus_t osMessageQueueDelete (osMessageQueueId_t mq_id) {
000000  b570              PUSH     {r4-r6,lr}
000002  4605              MOV      r5,r0
;;;1918     QueueHandle_t hQueue = (QueueHandle_t)mq_id;
000004  462e              MOV      r6,r5
;;;1919     osStatus_t stat;
;;;1920   
;;;1921   #ifndef USE_FreeRTOS_HEAP_1
;;;1922     if (IS_IRQ()) {
000006  f7fffffe          BL       __get_IPSR
00000a  b110              CBZ      r0,|L38.18|
;;;1923       stat = osErrorISR;
00000c  f06f0405          MVN      r4,#5
000010  e00a              B        |L38.40|
                  |L38.18|
;;;1924     }
;;;1925     else if (hQueue == NULL) {
000012  b916              CBNZ     r6,|L38.26|
;;;1926       stat = osErrorParameter;
000014  f06f0403          MVN      r4,#3
000018  e006              B        |L38.40|
                  |L38.26|
;;;1927     }
;;;1928     else {
;;;1929       #if (configQUEUE_REGISTRY_SIZE > 0)
;;;1930       vQueueUnregisterQueue (hQueue);
00001a  4630              MOV      r0,r6
00001c  f7fffffe          BL       vQueueUnregisterQueue
;;;1931       #endif
;;;1932   
;;;1933       stat = osOK;
000020  2400              MOVS     r4,#0
;;;1934       vQueueDelete (hQueue);
000022  4630              MOV      r0,r6
000024  f7fffffe          BL       vQueueDelete
                  |L38.40|
;;;1935     }
;;;1936   #else
;;;1937     stat = osError;
;;;1938   #endif
;;;1939   
;;;1940     return (stat);
000028  4620              MOV      r0,r4
;;;1941   }
00002a  bd70              POP      {r4-r6,pc}
;;;1942   
                          ENDP


                          AREA ||i.osMessageQueueGet||, CODE, READONLY, ALIGN=2

                  osMessageQueueGet PROC
;;;1789   
;;;1790   osStatus_t osMessageQueueGet (osMessageQueueId_t mq_id, void *msg_ptr, uint8_t *msg_prio, uint32_t timeout) {
000000  e92d43f8          PUSH     {r3-r9,lr}
000004  4607              MOV      r7,r0
000006  460d              MOV      r5,r1
000008  4691              MOV      r9,r2
00000a  461c              MOV      r4,r3
;;;1791     QueueHandle_t hQueue = (QueueHandle_t)mq_id;
00000c  463e              MOV      r6,r7
;;;1792     osStatus_t stat;
;;;1793     BaseType_t yield;
;;;1794   
;;;1795     (void)msg_prio; /* Message priority is ignored */
;;;1796   
;;;1797     stat = osOK;
00000e  f04f0800          MOV      r8,#0
;;;1798   
;;;1799     if (IS_IRQ()) {
000012  f7fffffe          BL       __get_IPSR
000016  b1e0              CBZ      r0,|L39.82|
;;;1800       if ((hQueue == NULL) || (msg_ptr == NULL) || (timeout != 0U)) {
000018  b10e              CBZ      r6,|L39.30|
00001a  b105              CBZ      r5,|L39.30|
00001c  b114              CBZ      r4,|L39.36|
                  |L39.30|
;;;1801         stat = osErrorParameter;
00001e  f06f0803          MVN      r8,#3
000022  e028              B        |L39.118|
                  |L39.36|
;;;1802       }
;;;1803       else {
;;;1804         yield = pdFALSE;
000024  2000              MOVS     r0,#0
000026  9000              STR      r0,[sp,#0]
;;;1805   
;;;1806         if (xQueueReceiveFromISR (hQueue, msg_ptr, &yield) != pdPASS) {
000028  466a              MOV      r2,sp
00002a  4629              MOV      r1,r5
00002c  4630              MOV      r0,r6
00002e  f7fffffe          BL       xQueueReceiveFromISR
000032  2801              CMP      r0,#1
000034  d002              BEQ      |L39.60|
;;;1807           stat = osErrorResource;
000036  f06f0802          MVN      r8,#2
00003a  e01c              B        |L39.118|
                  |L39.60|
;;;1808         } else {
;;;1809           portYIELD_FROM_ISR (yield);
00003c  9800              LDR      r0,[sp,#0]
00003e  b1d0              CBZ      r0,|L39.118|
000040  f04f5080          MOV      r0,#0x10000000
000044  490d              LDR      r1,|L39.124|
000046  6008              STR      r0,[r1,#0]
000048  f3bf8f4f          DSB      
00004c  f3bf8f6f          ISB      
000050  e011              B        |L39.118|
                  |L39.82|
;;;1810         }
;;;1811       }
;;;1812     }
;;;1813     else {
;;;1814       if ((hQueue == NULL) || (msg_ptr == NULL)) {
000052  b106              CBZ      r6,|L39.86|
000054  b915              CBNZ     r5,|L39.92|
                  |L39.86|
;;;1815         stat = osErrorParameter;
000056  f06f0803          MVN      r8,#3
00005a  e00c              B        |L39.118|
                  |L39.92|
;;;1816       }
;;;1817       else {
;;;1818         if (xQueueReceive (hQueue, msg_ptr, (TickType_t)timeout) != pdPASS) {
00005c  4622              MOV      r2,r4
00005e  4629              MOV      r1,r5
000060  4630              MOV      r0,r6
000062  f7fffffe          BL       xQueueReceive
000066  2801              CMP      r0,#1
000068  d005              BEQ      |L39.118|
;;;1819           if (timeout != 0U) {
00006a  b114              CBZ      r4,|L39.114|
;;;1820             stat = osErrorTimeout;
00006c  f06f0801          MVN      r8,#1
000070  e001              B        |L39.118|
                  |L39.114|
;;;1821           } else {
;;;1822             stat = osErrorResource;
000072  f06f0802          MVN      r8,#2
                  |L39.118|
;;;1823           }
;;;1824         }
;;;1825       }
;;;1826     }
;;;1827   
;;;1828     return (stat);
000076  4640              MOV      r0,r8
;;;1829   }
000078  e8bd83f8          POP      {r3-r9,pc}
;;;1830   
                          ENDP

                  |L39.124|
                          DCD      0xe000ed04

                          AREA ||i.osMessageQueueGetCapacity||, CODE, READONLY, ALIGN=1

                  osMessageQueueGetCapacity PROC
;;;1830   
;;;1831   uint32_t osMessageQueueGetCapacity (osMessageQueueId_t mq_id) {
000000  4601              MOV      r1,r0
;;;1832     StaticQueue_t *mq = (StaticQueue_t *)mq_id;
000002  460a              MOV      r2,r1
;;;1833     uint32_t capacity;
;;;1834   
;;;1835     if (mq == NULL) {
000004  b90a              CBNZ     r2,|L40.10|
;;;1836       capacity = 0U;
000006  2000              MOVS     r0,#0
000008  e000              B        |L40.12|
                  |L40.10|
;;;1837     } else {
;;;1838       /* capacity = pxQueue->uxLength */
;;;1839       capacity = mq->uxDummy4[1];
00000a  6bd0              LDR      r0,[r2,#0x3c]
                  |L40.12|
;;;1840     }
;;;1841   
;;;1842     return (capacity);
;;;1843   }
00000c  4770              BX       lr
;;;1844   
                          ENDP


                          AREA ||i.osMessageQueueGetCount||, CODE, READONLY, ALIGN=1

                  osMessageQueueGetCount PROC
;;;1858   
;;;1859   uint32_t osMessageQueueGetCount (osMessageQueueId_t mq_id) {
000000  b570              PUSH     {r4-r6,lr}
000002  4605              MOV      r5,r0
;;;1860     QueueHandle_t hQueue = (QueueHandle_t)mq_id;
000004  462e              MOV      r6,r5
;;;1861     UBaseType_t count;
;;;1862   
;;;1863     if (hQueue == NULL) {
000006  b90e              CBNZ     r6,|L41.12|
;;;1864       count = 0U;
000008  2400              MOVS     r4,#0
00000a  e00b              B        |L41.36|
                  |L41.12|
;;;1865     }
;;;1866     else if (IS_IRQ()) {
00000c  f7fffffe          BL       __get_IPSR
000010  b120              CBZ      r0,|L41.28|
;;;1867       count = uxQueueMessagesWaitingFromISR (hQueue);
000012  4630              MOV      r0,r6
000014  f7fffffe          BL       uxQueueMessagesWaitingFromISR
000018  4604              MOV      r4,r0
00001a  e003              B        |L41.36|
                  |L41.28|
;;;1868     }
;;;1869     else {
;;;1870       count = uxQueueMessagesWaiting (hQueue);
00001c  4630              MOV      r0,r6
00001e  f7fffffe          BL       uxQueueMessagesWaiting
000022  4604              MOV      r4,r0
                  |L41.36|
;;;1871     }
;;;1872   
;;;1873     return ((uint32_t)count);
000024  4620              MOV      r0,r4
;;;1874   }
000026  bd70              POP      {r4-r6,pc}
;;;1875   
                          ENDP


                          AREA ||i.osMessageQueueGetMsgSize||, CODE, READONLY, ALIGN=1

                  osMessageQueueGetMsgSize PROC
;;;1844   
;;;1845   uint32_t osMessageQueueGetMsgSize (osMessageQueueId_t mq_id) {
000000  4601              MOV      r1,r0
;;;1846     StaticQueue_t *mq = (StaticQueue_t *)mq_id;
000002  460a              MOV      r2,r1
;;;1847     uint32_t size;
;;;1848   
;;;1849     if (mq == NULL) {
000004  b90a              CBNZ     r2,|L42.10|
;;;1850       size = 0U;
000006  2000              MOVS     r0,#0
000008  e000              B        |L42.12|
                  |L42.10|
;;;1851     } else {
;;;1852       /* size = pxQueue->uxItemSize */
;;;1853       size = mq->uxDummy4[2];
00000a  6c10              LDR      r0,[r2,#0x40]
                  |L42.12|
;;;1854     }
;;;1855   
;;;1856     return (size);
;;;1857   }
00000c  4770              BX       lr
;;;1858   
                          ENDP


                          AREA ||i.osMessageQueueGetSpace||, CODE, READONLY, ALIGN=1

                  osMessageQueueGetSpace PROC
;;;1875   
;;;1876   uint32_t osMessageQueueGetSpace (osMessageQueueId_t mq_id) {
000000  e92d41f0          PUSH     {r4-r8,lr}
000004  4607              MOV      r7,r0
;;;1877     StaticQueue_t *mq = (StaticQueue_t *)mq_id;
000006  463d              MOV      r5,r7
;;;1878     uint32_t space;
;;;1879     uint32_t isrm;
;;;1880   
;;;1881     if (mq == NULL) {
000008  b90d              CBNZ     r5,|L43.14|
;;;1882       space = 0U;
00000a  2600              MOVS     r6,#0
00000c  e01a              B        |L43.68|
                  |L43.14|
;;;1883     }
;;;1884     else if (IS_IRQ()) {
00000e  f7fffffe          BL       __get_IPSR
000012  b198              CBZ      r0,|L43.60|
;;;1885       isrm = taskENTER_CRITICAL_FROM_ISR();
000014  bf00              NOP      
000016  2150              MOVS     r1,#0x50
000018  f3ef8011          MRS      r0,BASEPRI
00001c  f3818811          MSR      BASEPRI,r1
000020  f3bf8f4f          DSB      
000024  f3bf8f6f          ISB      
000028  4604              MOV      r4,r0
00002a  bf00              NOP      
;;;1886   
;;;1887       /* space = pxQueue->uxLength - pxQueue->uxMessagesWaiting; */
;;;1888       space = mq->uxDummy4[1] - mq->uxDummy4[0];
00002c  e9d5100e          LDRD     r1,r0,[r5,#0x38]
000030  1a46              SUBS     r6,r0,r1
;;;1889   
;;;1890       taskEXIT_CRITICAL_FROM_ISR(isrm);
000032  bf00              NOP      
000034  f3848811          MSR      BASEPRI,r4
000038  bf00              NOP      
00003a  e003              B        |L43.68|
                  |L43.60|
;;;1891     }
;;;1892     else {
;;;1893       space = (uint32_t)uxQueueSpacesAvailable ((QueueHandle_t)mq);
00003c  4628              MOV      r0,r5
00003e  f7fffffe          BL       uxQueueSpacesAvailable
000042  4606              MOV      r6,r0
                  |L43.68|
;;;1894     }
;;;1895   
;;;1896     return (space);
000044  4630              MOV      r0,r6
;;;1897   }
000046  e8bd81f0          POP      {r4-r8,pc}
;;;1898   
                          ENDP


                          AREA ||i.osMessageQueueNew||, CODE, READONLY, ALIGN=1

                  osMessageQueueNew PROC
;;;1691   
;;;1692   osMessageQueueId_t osMessageQueueNew (uint32_t msg_count, uint32_t msg_size, const osMessageQueueAttr_t *attr) {
000000  e92d43f8          PUSH     {r3-r9,lr}
000004  4605              MOV      r5,r0
000006  460e              MOV      r6,r1
000008  4614              MOV      r4,r2
;;;1693     QueueHandle_t hQueue;
;;;1694     int32_t mem;
;;;1695     #if (configQUEUE_REGISTRY_SIZE > 0)
;;;1696     const char *name;
;;;1697     #endif
;;;1698   
;;;1699     hQueue = NULL;
00000a  f04f0900          MOV      r9,#0
;;;1700   
;;;1701     if (!IS_IRQ() && (msg_count > 0U) && (msg_size > 0U)) {
00000e  f7fffffe          BL       __get_IPSR
000012  2800              CMP      r0,#0
000014  d13e              BNE      |L44.148|
000016  2d00              CMP      r5,#0
000018  d03c              BEQ      |L44.148|
00001a  2e00              CMP      r6,#0
00001c  d03a              BEQ      |L44.148|
;;;1702       mem = -1;
00001e  1e47              SUBS     r7,r0,#1
;;;1703   
;;;1704       if (attr != NULL) {
000020  b1bc              CBZ      r4,|L44.82|
;;;1705         if ((attr->cb_mem != NULL) && (attr->cb_size >= sizeof(StaticQueue_t)) &&
000022  68a0              LDR      r0,[r4,#8]
000024  b158              CBZ      r0,|L44.62|
000026  68e0              LDR      r0,[r4,#0xc]
000028  2850              CMP      r0,#0x50
00002a  d308              BCC      |L44.62|
;;;1706             (attr->mq_mem != NULL) && (attr->mq_size >= (msg_count * msg_size))) {
00002c  6920              LDR      r0,[r4,#0x10]
00002e  b130              CBZ      r0,|L44.62|
000030  fb05f006          MUL      r0,r5,r6
000034  6961              LDR      r1,[r4,#0x14]
000036  4281              CMP      r1,r0
000038  d301              BCC      |L44.62|
;;;1707           mem = 1;
00003a  2701              MOVS     r7,#1
00003c  e00a              B        |L44.84|
                  |L44.62|
;;;1708         }
;;;1709         else {
;;;1710           if ((attr->cb_mem == NULL) && (attr->cb_size == 0U) &&
00003e  68a0              LDR      r0,[r4,#8]
000040  b940              CBNZ     r0,|L44.84|
000042  68e0              LDR      r0,[r4,#0xc]
000044  b930              CBNZ     r0,|L44.84|
;;;1711               (attr->mq_mem == NULL) && (attr->mq_size == 0U)) {
000046  6920              LDR      r0,[r4,#0x10]
000048  b920              CBNZ     r0,|L44.84|
00004a  6960              LDR      r0,[r4,#0x14]
00004c  b910              CBNZ     r0,|L44.84|
;;;1712             mem = 0;
00004e  2700              MOVS     r7,#0
000050  e000              B        |L44.84|
                  |L44.82|
;;;1713           }
;;;1714         }
;;;1715       }
;;;1716       else {
;;;1717         mem = 0;
000052  2700              MOVS     r7,#0
                  |L44.84|
;;;1718       }
;;;1719   
;;;1720       if (mem == 1) {
000054  2f01              CMP      r7,#1
000056  d109              BNE      |L44.108|
;;;1721         #if (configSUPPORT_STATIC_ALLOCATION == 1)
;;;1722           hQueue = xQueueCreateStatic (msg_count, msg_size, attr->mq_mem, attr->cb_mem);
000058  2000              MOVS     r0,#0
00005a  9000              STR      r0,[sp,#0]
00005c  4631              MOV      r1,r6
00005e  4628              MOV      r0,r5
000060  68a3              LDR      r3,[r4,#8]
000062  6922              LDR      r2,[r4,#0x10]
000064  f7fffffe          BL       xQueueGenericCreateStatic
000068  4681              MOV      r9,r0
00006a  e006              B        |L44.122|
                  |L44.108|
;;;1723         #endif
;;;1724       }
;;;1725       else {
;;;1726         if (mem == 0) {
00006c  b92f              CBNZ     r7,|L44.122|
;;;1727           #if (configSUPPORT_DYNAMIC_ALLOCATION == 1)
;;;1728             hQueue = xQueueCreate (msg_count, msg_size);
00006e  2200              MOVS     r2,#0
000070  4631              MOV      r1,r6
000072  4628              MOV      r0,r5
000074  f7fffffe          BL       xQueueGenericCreate
000078  4681              MOV      r9,r0
                  |L44.122|
;;;1729           #endif
;;;1730         }
;;;1731       }
;;;1732   
;;;1733       #if (configQUEUE_REGISTRY_SIZE > 0)
;;;1734       if (hQueue != NULL) {
00007a  f1b90f00          CMP      r9,#0
00007e  d009              BEQ      |L44.148|
;;;1735         if (attr != NULL) {
000080  b114              CBZ      r4,|L44.136|
;;;1736           name = attr->name;
000082  f8d48000          LDR      r8,[r4,#0]
000086  e001              B        |L44.140|
                  |L44.136|
;;;1737         } else {
;;;1738           name = NULL;
000088  f04f0800          MOV      r8,#0
                  |L44.140|
;;;1739         }
;;;1740         vQueueAddToRegistry (hQueue, name);
00008c  4641              MOV      r1,r8
00008e  4648              MOV      r0,r9
000090  f7fffffe          BL       vQueueAddToRegistry
                  |L44.148|
;;;1741       }
;;;1742       #endif
;;;1743   
;;;1744     }
;;;1745   
;;;1746     return ((osMessageQueueId_t)hQueue);
000094  4648              MOV      r0,r9
;;;1747   }
000096  e8bd83f8          POP      {r3-r9,pc}
;;;1748   
                          ENDP


                          AREA ||i.osMessageQueuePut||, CODE, READONLY, ALIGN=2

                  osMessageQueuePut PROC
;;;1748   
;;;1749   osStatus_t osMessageQueuePut (osMessageQueueId_t mq_id, const void *msg_ptr, uint8_t msg_prio, uint32_t timeout) {
000000  e92d43f8          PUSH     {r3-r9,lr}
000004  4607              MOV      r7,r0
000006  460d              MOV      r5,r1
000008  4691              MOV      r9,r2
00000a  461c              MOV      r4,r3
;;;1750     QueueHandle_t hQueue = (QueueHandle_t)mq_id;
00000c  463e              MOV      r6,r7
;;;1751     osStatus_t stat;
;;;1752     BaseType_t yield;
;;;1753   
;;;1754     (void)msg_prio; /* Message priority is ignored */
;;;1755   
;;;1756     stat = osOK;
00000e  f04f0800          MOV      r8,#0
;;;1757   
;;;1758     if (IS_IRQ()) {
000012  f7fffffe          BL       __get_IPSR
000016  b1e8              CBZ      r0,|L45.84|
;;;1759       if ((hQueue == NULL) || (msg_ptr == NULL) || (timeout != 0U)) {
000018  b10e              CBZ      r6,|L45.30|
00001a  b105              CBZ      r5,|L45.30|
00001c  b114              CBZ      r4,|L45.36|
                  |L45.30|
;;;1760         stat = osErrorParameter;
00001e  f06f0803          MVN      r8,#3
000022  e02a              B        |L45.122|
                  |L45.36|
;;;1761       }
;;;1762       else {
;;;1763         yield = pdFALSE;
000024  2000              MOVS     r0,#0
000026  9000              STR      r0,[sp,#0]
;;;1764   
;;;1765         if (xQueueSendToBackFromISR (hQueue, msg_ptr, &yield) != pdTRUE) {
000028  2300              MOVS     r3,#0
00002a  466a              MOV      r2,sp
00002c  4629              MOV      r1,r5
00002e  4630              MOV      r0,r6
000030  f7fffffe          BL       xQueueGenericSendFromISR
000034  2801              CMP      r0,#1
000036  d002              BEQ      |L45.62|
;;;1766           stat = osErrorResource;
000038  f06f0802          MVN      r8,#2
00003c  e01d              B        |L45.122|
                  |L45.62|
;;;1767         } else {
;;;1768           portYIELD_FROM_ISR (yield);
00003e  9800              LDR      r0,[sp,#0]
000040  b1d8              CBZ      r0,|L45.122|
000042  f04f5080          MOV      r0,#0x10000000
000046  490e              LDR      r1,|L45.128|
000048  6008              STR      r0,[r1,#0]
00004a  f3bf8f4f          DSB      
00004e  f3bf8f6f          ISB      
000052  e012              B        |L45.122|
                  |L45.84|
;;;1769         }
;;;1770       }
;;;1771     }
;;;1772     else {
;;;1773       if ((hQueue == NULL) || (msg_ptr == NULL)) {
000054  b106              CBZ      r6,|L45.88|
000056  b915              CBNZ     r5,|L45.94|
                  |L45.88|
;;;1774         stat = osErrorParameter;
000058  f06f0803          MVN      r8,#3
00005c  e00d              B        |L45.122|
                  |L45.94|
;;;1775       }
;;;1776       else {
;;;1777         if (xQueueSendToBack (hQueue, msg_ptr, (TickType_t)timeout) != pdPASS) {
00005e  2300              MOVS     r3,#0
000060  4622              MOV      r2,r4
000062  4629              MOV      r1,r5
000064  4630              MOV      r0,r6
000066  f7fffffe          BL       xQueueGenericSend
00006a  2801              CMP      r0,#1
00006c  d005              BEQ      |L45.122|
;;;1778           if (timeout != 0U) {
00006e  b114              CBZ      r4,|L45.118|
;;;1779             stat = osErrorTimeout;
000070  f06f0801          MVN      r8,#1
000074  e001              B        |L45.122|
                  |L45.118|
;;;1780           } else {
;;;1781             stat = osErrorResource;
000076  f06f0802          MVN      r8,#2
                  |L45.122|
;;;1782           }
;;;1783         }
;;;1784       }
;;;1785     }
;;;1786   
;;;1787     return (stat);
00007a  4640              MOV      r0,r8
;;;1788   }
00007c  e8bd83f8          POP      {r3-r9,pc}
;;;1789   
                          ENDP

                  |L45.128|
                          DCD      0xe000ed04

                          AREA ||i.osMessageQueueReset||, CODE, READONLY, ALIGN=1

                  osMessageQueueReset PROC
;;;1898   
;;;1899   osStatus_t osMessageQueueReset (osMessageQueueId_t mq_id) {
000000  b570              PUSH     {r4-r6,lr}
000002  4605              MOV      r5,r0
;;;1900     QueueHandle_t hQueue = (QueueHandle_t)mq_id;
000004  462e              MOV      r6,r5
;;;1901     osStatus_t stat;
;;;1902   
;;;1903     if (IS_IRQ()) {
000006  f7fffffe          BL       __get_IPSR
00000a  b110              CBZ      r0,|L46.18|
;;;1904       stat = osErrorISR;
00000c  f06f0405          MVN      r4,#5
000010  e008              B        |L46.36|
                  |L46.18|
;;;1905     }
;;;1906     else if (hQueue == NULL) {
000012  b916              CBNZ     r6,|L46.26|
;;;1907       stat = osErrorParameter;
000014  f06f0403          MVN      r4,#3
000018  e004              B        |L46.36|
                  |L46.26|
;;;1908     }
;;;1909     else {
;;;1910       stat = osOK;
00001a  2400              MOVS     r4,#0
;;;1911       (void)xQueueReset (hQueue);
00001c  2100              MOVS     r1,#0
00001e  4630              MOV      r0,r6
000020  f7fffffe          BL       xQueueGenericReset
                  |L46.36|
;;;1912     }
;;;1913   
;;;1914     return (stat);
000024  4620              MOV      r0,r4
;;;1915   }
000026  bd70              POP      {r4-r6,pc}
;;;1916   
                          ENDP


                          AREA ||i.osMutexAcquire||, CODE, READONLY, ALIGN=1

                  osMutexAcquire PROC
;;;1384   
;;;1385   osStatus_t osMutexAcquire (osMutexId_t mutex_id, uint32_t timeout) {
000000  e92d41f0          PUSH     {r4-r8,lr}
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
;;;1386     SemaphoreHandle_t hMutex;
;;;1387     osStatus_t stat;
;;;1388     uint32_t rmtx;
;;;1389   
;;;1390     hMutex = (SemaphoreHandle_t)((uint32_t)mutex_id & ~1U);
000008  f0240601          BIC      r6,r4,#1
;;;1391   
;;;1392     rmtx = (uint32_t)mutex_id & 1U;
00000c  f0040801          AND      r8,r4,#1
;;;1393   
;;;1394     stat = osOK;
000010  2700              MOVS     r7,#0
;;;1395   
;;;1396     if (IS_IRQ()) {
000012  f7fffffe          BL       __get_IPSR
000016  b108              CBZ      r0,|L47.28|
;;;1397       stat = osErrorISR;
000018  1fbf              SUBS     r7,r7,#6
00001a  e01f              B        |L47.92|
                  |L47.28|
;;;1398     }
;;;1399     else if (hMutex == NULL) {
00001c  b916              CBNZ     r6,|L47.36|
;;;1400       stat = osErrorParameter;
00001e  f06f0703          MVN      r7,#3
000022  e01b              B        |L47.92|
                  |L47.36|
;;;1401     }
;;;1402     else {
;;;1403       if (rmtx != 0U) {
000024  f1b80f00          CMP      r8,#0
000028  d00c              BEQ      |L47.68|
;;;1404         #if (configUSE_RECURSIVE_MUTEXES == 1)
;;;1405         if (xSemaphoreTakeRecursive (hMutex, timeout) != pdPASS) {
00002a  4629              MOV      r1,r5
00002c  4630              MOV      r0,r6
00002e  f7fffffe          BL       xQueueTakeMutexRecursive
000032  2801              CMP      r0,#1
000034  d012              BEQ      |L47.92|
;;;1406           if (timeout != 0U) {
000036  b115              CBZ      r5,|L47.62|
;;;1407             stat = osErrorTimeout;
000038  f06f0701          MVN      r7,#1
00003c  e00e              B        |L47.92|
                  |L47.62|
;;;1408           } else {
;;;1409             stat = osErrorResource;
00003e  f06f0702          MVN      r7,#2
000042  e00b              B        |L47.92|
                  |L47.68|
;;;1410           }
;;;1411         }
;;;1412         #endif
;;;1413       }
;;;1414       else {
;;;1415         if (xSemaphoreTake (hMutex, timeout) != pdPASS) {
000044  4629              MOV      r1,r5
000046  4630              MOV      r0,r6
000048  f7fffffe          BL       xQueueSemaphoreTake
00004c  2801              CMP      r0,#1
00004e  d005              BEQ      |L47.92|
;;;1416           if (timeout != 0U) {
000050  b115              CBZ      r5,|L47.88|
;;;1417             stat = osErrorTimeout;
000052  f06f0701          MVN      r7,#1
000056  e001              B        |L47.92|
                  |L47.88|
;;;1418           } else {
;;;1419             stat = osErrorResource;
000058  f06f0702          MVN      r7,#2
                  |L47.92|
;;;1420           }
;;;1421         }
;;;1422       }
;;;1423     }
;;;1424   
;;;1425     return (stat);
00005c  4638              MOV      r0,r7
;;;1426   }
00005e  e8bd81f0          POP      {r4-r8,pc}
;;;1427   
                          ENDP


                          AREA ||i.osMutexDelete||, CODE, READONLY, ALIGN=1

                  osMutexDelete PROC
;;;1477   
;;;1478   osStatus_t osMutexDelete (osMutexId_t mutex_id) {
000000  b570              PUSH     {r4-r6,lr}
000002  4605              MOV      r5,r0
;;;1479     osStatus_t stat;
;;;1480   #ifndef USE_FreeRTOS_HEAP_1
;;;1481     SemaphoreHandle_t hMutex;
;;;1482   
;;;1483     hMutex = (SemaphoreHandle_t)((uint32_t)mutex_id & ~1U);
000004  f0250601          BIC      r6,r5,#1
;;;1484   
;;;1485     if (IS_IRQ()) {
000008  f7fffffe          BL       __get_IPSR
00000c  b110              CBZ      r0,|L48.20|
;;;1486       stat = osErrorISR;
00000e  f06f0405          MVN      r4,#5
000012  e00a              B        |L48.42|
                  |L48.20|
;;;1487     }
;;;1488     else if (hMutex == NULL) {
000014  b916              CBNZ     r6,|L48.28|
;;;1489       stat = osErrorParameter;
000016  f06f0403          MVN      r4,#3
00001a  e006              B        |L48.42|
                  |L48.28|
;;;1490     }
;;;1491     else {
;;;1492       #if (configQUEUE_REGISTRY_SIZE > 0)
;;;1493       vQueueUnregisterQueue (hMutex);
00001c  4630              MOV      r0,r6
00001e  f7fffffe          BL       vQueueUnregisterQueue
;;;1494       #endif
;;;1495       stat = osOK;
000022  2400              MOVS     r4,#0
;;;1496       vSemaphoreDelete (hMutex);
000024  4630              MOV      r0,r6
000026  f7fffffe          BL       vQueueDelete
                  |L48.42|
;;;1497     }
;;;1498   #else
;;;1499     stat = osError;
;;;1500   #endif
;;;1501   
;;;1502     return (stat);
00002a  4620              MOV      r0,r4
;;;1503   }
00002c  bd70              POP      {r4-r6,pc}
;;;1504   #endif /* (configUSE_OS2_MUTEX == 1) */
                          ENDP


                          AREA ||i.osMutexGetOwner||, CODE, READONLY, ALIGN=1

                  osMutexGetOwner PROC
;;;1462   
;;;1463   osThreadId_t osMutexGetOwner (osMutexId_t mutex_id) {
000000  b570              PUSH     {r4-r6,lr}
000002  4605              MOV      r5,r0
;;;1464     SemaphoreHandle_t hMutex;
;;;1465     osThreadId_t owner;
;;;1466   
;;;1467     hMutex = (SemaphoreHandle_t)((uint32_t)mutex_id & ~1U);
000004  f0250601          BIC      r6,r5,#1
;;;1468   
;;;1469     if (IS_IRQ() || (hMutex == NULL)) {
000008  f7fffffe          BL       __get_IPSR
00000c  b900              CBNZ     r0,|L49.16|
00000e  b90e              CBNZ     r6,|L49.20|
                  |L49.16|
;;;1470       owner = NULL;
000010  2400              MOVS     r4,#0
000012  e003              B        |L49.28|
                  |L49.20|
;;;1471     } else {
;;;1472       owner = (osThreadId_t)xSemaphoreGetMutexHolder (hMutex);
000014  4630              MOV      r0,r6
000016  f7fffffe          BL       xQueueGetMutexHolder
00001a  4604              MOV      r4,r0
                  |L49.28|
;;;1473     }
;;;1474   
;;;1475     return (owner);
00001c  4620              MOV      r0,r4
;;;1476   }
00001e  bd70              POP      {r4-r6,pc}
;;;1477   
                          ENDP


                          AREA ||i.osMutexNew||, CODE, READONLY, ALIGN=1

                  osMutexNew PROC
;;;1297   
;;;1298   osMutexId_t osMutexNew (const osMutexAttr_t *attr) {
000000  e92d47f0          PUSH     {r4-r10,lr}
000004  4604              MOV      r4,r0
;;;1299     SemaphoreHandle_t hMutex;
;;;1300     uint32_t type;
;;;1301     uint32_t rmtx;
;;;1302     int32_t  mem;
;;;1303     #if (configQUEUE_REGISTRY_SIZE > 0)
;;;1304     const char *name;
;;;1305     #endif
;;;1306   
;;;1307     hMutex = NULL;
000006  2600              MOVS     r6,#0
;;;1308   
;;;1309     if (!IS_IRQ()) {
000008  f7fffffe          BL       __get_IPSR
00000c  2800              CMP      r0,#0
00000e  d14d              BNE      |L50.172|
;;;1310       if (attr != NULL) {
000010  b10c              CBZ      r4,|L50.22|
;;;1311         type = attr->attr_bits;
000012  6867              LDR      r7,[r4,#4]
000014  e000              B        |L50.24|
                  |L50.22|
;;;1312       } else {
;;;1313         type = 0U;
000016  2700              MOVS     r7,#0
                  |L50.24|
;;;1314       }
;;;1315   
;;;1316       if ((type & osMutexRecursive) == osMutexRecursive) {
000018  f0070001          AND      r0,r7,#1
00001c  b108              CBZ      r0,|L50.34|
;;;1317         rmtx = 1U;
00001e  2501              MOVS     r5,#1
000020  e000              B        |L50.36|
                  |L50.34|
;;;1318       } else {
;;;1319         rmtx = 0U;
000022  2500              MOVS     r5,#0
                  |L50.36|
;;;1320       }
;;;1321   
;;;1322       if ((type & osMutexRobust) != osMutexRobust) {
000024  f0070008          AND      r0,r7,#8
000028  2808              CMP      r0,#8
00002a  d03f              BEQ      |L50.172|
;;;1323         mem = -1;
00002c  f04f38ff          MOV      r8,#0xffffffff
;;;1324   
;;;1325         if (attr != NULL) {
000030  b174              CBZ      r4,|L50.80|
;;;1326           if ((attr->cb_mem != NULL) && (attr->cb_size >= sizeof(StaticSemaphore_t))) {
000032  68a0              LDR      r0,[r4,#8]
000034  b128              CBZ      r0,|L50.66|
000036  68e0              LDR      r0,[r4,#0xc]
000038  2850              CMP      r0,#0x50
00003a  d302              BCC      |L50.66|
;;;1327             mem = 1;
00003c  f04f0801          MOV      r8,#1
000040  e008              B        |L50.84|
                  |L50.66|
;;;1328           }
;;;1329           else {
;;;1330             if ((attr->cb_mem == NULL) && (attr->cb_size == 0U)) {
000042  68a0              LDR      r0,[r4,#8]
000044  b930              CBNZ     r0,|L50.84|
000046  68e0              LDR      r0,[r4,#0xc]
000048  b920              CBNZ     r0,|L50.84|
;;;1331               mem = 0;
00004a  f04f0800          MOV      r8,#0
00004e  e001              B        |L50.84|
                  |L50.80|
;;;1332             }
;;;1333           }
;;;1334         }
;;;1335         else {
;;;1336           mem = 0;
000050  f04f0800          MOV      r8,#0
                  |L50.84|
;;;1337         }
;;;1338   
;;;1339         if (mem == 1) {
000054  f1b80f01          CMP      r8,#1
000058  d10c              BNE      |L50.116|
;;;1340           #if (configSUPPORT_STATIC_ALLOCATION == 1)
;;;1341             if (rmtx != 0U) {
00005a  b12d              CBZ      r5,|L50.104|
;;;1342               #if (configUSE_RECURSIVE_MUTEXES == 1)
;;;1343               hMutex = xSemaphoreCreateRecursiveMutexStatic (attr->cb_mem);
00005c  2004              MOVS     r0,#4
00005e  68a1              LDR      r1,[r4,#8]
000060  f7fffffe          BL       xQueueCreateMutexStatic
000064  4606              MOV      r6,r0
000066  e012              B        |L50.142|
                  |L50.104|
;;;1344               #endif
;;;1345             }
;;;1346             else {
;;;1347               hMutex = xSemaphoreCreateMutexStatic (attr->cb_mem);
000068  2001              MOVS     r0,#1
00006a  68a1              LDR      r1,[r4,#8]
00006c  f7fffffe          BL       xQueueCreateMutexStatic
000070  4606              MOV      r6,r0
000072  e00c              B        |L50.142|
                  |L50.116|
;;;1348             }
;;;1349           #endif
;;;1350         }
;;;1351         else {
;;;1352           if (mem == 0) {
000074  f1b80f00          CMP      r8,#0
000078  d109              BNE      |L50.142|
;;;1353             #if (configSUPPORT_DYNAMIC_ALLOCATION == 1)
;;;1354               if (rmtx != 0U) {
00007a  b125              CBZ      r5,|L50.134|
;;;1355                 #if (configUSE_RECURSIVE_MUTEXES == 1)
;;;1356                 hMutex = xSemaphoreCreateRecursiveMutex ();
00007c  2004              MOVS     r0,#4
00007e  f7fffffe          BL       xQueueCreateMutex
000082  4606              MOV      r6,r0
000084  e003              B        |L50.142|
                  |L50.134|
;;;1357                 #endif
;;;1358               } else {
;;;1359                 hMutex = xSemaphoreCreateMutex ();
000086  2001              MOVS     r0,#1
000088  f7fffffe          BL       xQueueCreateMutex
00008c  4606              MOV      r6,r0
                  |L50.142|
;;;1360               }
;;;1361             #endif
;;;1362           }
;;;1363         }
;;;1364   
;;;1365         #if (configQUEUE_REGISTRY_SIZE > 0)
;;;1366         if (hMutex != NULL) {
00008e  b14e              CBZ      r6,|L50.164|
;;;1367           if (attr != NULL) {
000090  b114              CBZ      r4,|L50.152|
;;;1368             name = attr->name;
000092  f8d49000          LDR      r9,[r4,#0]
000096  e001              B        |L50.156|
                  |L50.152|
;;;1369           } else {
;;;1370             name = NULL;
000098  f04f0900          MOV      r9,#0
                  |L50.156|
;;;1371           }
;;;1372           vQueueAddToRegistry (hMutex, name);
00009c  4649              MOV      r1,r9
00009e  4630              MOV      r0,r6
0000a0  f7fffffe          BL       vQueueAddToRegistry
                  |L50.164|
;;;1373         }
;;;1374         #endif
;;;1375   
;;;1376         if ((hMutex != NULL) && (rmtx != 0U)) {
0000a4  b116              CBZ      r6,|L50.172|
0000a6  b10d              CBZ      r5,|L50.172|
;;;1377           hMutex = (SemaphoreHandle_t)((uint32_t)hMutex | 1U);
0000a8  f0460601          ORR      r6,r6,#1
                  |L50.172|
;;;1378         }
;;;1379       }
;;;1380     }
;;;1381   
;;;1382     return ((osMutexId_t)hMutex);
0000ac  4630              MOV      r0,r6
;;;1383   }
0000ae  e8bd87f0          POP      {r4-r10,pc}
;;;1384   
                          ENDP


                          AREA ||i.osMutexRelease||, CODE, READONLY, ALIGN=1

                  osMutexRelease PROC
;;;1427   
;;;1428   osStatus_t osMutexRelease (osMutexId_t mutex_id) {
000000  e92d41f0          PUSH     {r4-r8,lr}
000004  4604              MOV      r4,r0
;;;1429     SemaphoreHandle_t hMutex;
;;;1430     osStatus_t stat;
;;;1431     uint32_t rmtx;
;;;1432   
;;;1433     hMutex = (SemaphoreHandle_t)((uint32_t)mutex_id & ~1U);
000006  f0240501          BIC      r5,r4,#1
;;;1434   
;;;1435     rmtx = (uint32_t)mutex_id & 1U;
00000a  f0040701          AND      r7,r4,#1
;;;1436   
;;;1437     stat = osOK;
00000e  2600              MOVS     r6,#0
;;;1438   
;;;1439     if (IS_IRQ()) {
000010  f7fffffe          BL       __get_IPSR
000014  b108              CBZ      r0,|L51.26|
;;;1440       stat = osErrorISR;
000016  1fb6              SUBS     r6,r6,#6
000018  e016              B        |L51.72|
                  |L51.26|
;;;1441     }
;;;1442     else if (hMutex == NULL) {
00001a  b915              CBNZ     r5,|L51.34|
;;;1443       stat = osErrorParameter;
00001c  f06f0603          MVN      r6,#3
000020  e012              B        |L51.72|
                  |L51.34|
;;;1444     }
;;;1445     else {
;;;1446       if (rmtx != 0U) {
000022  b13f              CBZ      r7,|L51.52|
;;;1447         #if (configUSE_RECURSIVE_MUTEXES == 1)
;;;1448         if (xSemaphoreGiveRecursive (hMutex) != pdPASS) {
000024  4628              MOV      r0,r5
000026  f7fffffe          BL       xQueueGiveMutexRecursive
00002a  2801              CMP      r0,#1
00002c  d00c              BEQ      |L51.72|
;;;1449           stat = osErrorResource;
00002e  f06f0602          MVN      r6,#2
000032  e009              B        |L51.72|
                  |L51.52|
;;;1450         }
;;;1451         #endif
;;;1452       }
;;;1453       else {
;;;1454         if (xSemaphoreGive (hMutex) != pdPASS) {
000034  2300              MOVS     r3,#0
000036  461a              MOV      r2,r3
000038  4619              MOV      r1,r3
00003a  4628              MOV      r0,r5
00003c  f7fffffe          BL       xQueueGenericSend
000040  2801              CMP      r0,#1
000042  d001              BEQ      |L51.72|
;;;1455           stat = osErrorResource;
000044  f06f0602          MVN      r6,#2
                  |L51.72|
;;;1456         }
;;;1457       }
;;;1458     }
;;;1459   
;;;1460     return (stat);
000048  4630              MOV      r0,r6
;;;1461   }
00004a  e8bd81f0          POP      {r4-r8,pc}
;;;1462   
                          ENDP


                          AREA ||i.osSemaphoreAcquire||, CODE, READONLY, ALIGN=2

                  osSemaphoreAcquire PROC
;;;1582   
;;;1583   osStatus_t osSemaphoreAcquire (osSemaphoreId_t semaphore_id, uint32_t timeout) {
000000  b5f8              PUSH     {r3-r7,lr}
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;1584     SemaphoreHandle_t hSemaphore = (SemaphoreHandle_t)semaphore_id;
000006  4626              MOV      r6,r4
;;;1585     osStatus_t stat;
;;;1586     BaseType_t yield;
;;;1587   
;;;1588     stat = osOK;
000008  2700              MOVS     r7,#0
;;;1589   
;;;1590     if (hSemaphore == NULL) {
00000a  b90e              CBNZ     r6,|L52.16|
;;;1591       stat = osErrorParameter;
00000c  1f3f              SUBS     r7,r7,#4
00000e  e029              B        |L52.100|
                  |L52.16|
;;;1592     }
;;;1593     else if (IS_IRQ()) {
000010  f7fffffe          BL       __get_IPSR
000014  b1d0              CBZ      r0,|L52.76|
;;;1594       if (timeout != 0U) {
000016  b115              CBZ      r5,|L52.30|
;;;1595         stat = osErrorParameter;
000018  f06f0703          MVN      r7,#3
00001c  e022              B        |L52.100|
                  |L52.30|
;;;1596       }
;;;1597       else {
;;;1598         yield = pdFALSE;
00001e  2000              MOVS     r0,#0
000020  9000              STR      r0,[sp,#0]
;;;1599   
;;;1600         if (xSemaphoreTakeFromISR (hSemaphore, &yield) != pdPASS) {
000022  466a              MOV      r2,sp
000024  2100              MOVS     r1,#0
000026  4630              MOV      r0,r6
000028  f7fffffe          BL       xQueueReceiveFromISR
00002c  2801              CMP      r0,#1
00002e  d002              BEQ      |L52.54|
;;;1601           stat = osErrorResource;
000030  f06f0702          MVN      r7,#2
000034  e016              B        |L52.100|
                  |L52.54|
;;;1602         } else {
;;;1603           portYIELD_FROM_ISR (yield);
000036  9800              LDR      r0,[sp,#0]
000038  b1a0              CBZ      r0,|L52.100|
00003a  f04f5080          MOV      r0,#0x10000000
00003e  490a              LDR      r1,|L52.104|
000040  6008              STR      r0,[r1,#0]
000042  f3bf8f4f          DSB      
000046  f3bf8f6f          ISB      
00004a  e00b              B        |L52.100|
                  |L52.76|
;;;1604         }
;;;1605       }
;;;1606     }
;;;1607     else {
;;;1608       if (xSemaphoreTake (hSemaphore, (TickType_t)timeout) != pdPASS) {
00004c  4629              MOV      r1,r5
00004e  4630              MOV      r0,r6
000050  f7fffffe          BL       xQueueSemaphoreTake
000054  2801              CMP      r0,#1
000056  d005              BEQ      |L52.100|
;;;1609         if (timeout != 0U) {
000058  b115              CBZ      r5,|L52.96|
;;;1610           stat = osErrorTimeout;
00005a  f06f0701          MVN      r7,#1
00005e  e001              B        |L52.100|
                  |L52.96|
;;;1611         } else {
;;;1612           stat = osErrorResource;
000060  f06f0702          MVN      r7,#2
                  |L52.100|
;;;1613         }
;;;1614       }
;;;1615     }
;;;1616   
;;;1617     return (stat);
000064  4638              MOV      r0,r7
;;;1618   }
000066  bdf8              POP      {r3-r7,pc}
;;;1619   
                          ENDP

                  |L52.104|
                          DCD      0xe000ed04

                          AREA ||i.osSemaphoreDelete||, CODE, READONLY, ALIGN=1

                  osSemaphoreDelete PROC
;;;1663   
;;;1664   osStatus_t osSemaphoreDelete (osSemaphoreId_t semaphore_id) {
000000  b570              PUSH     {r4-r6,lr}
000002  4605              MOV      r5,r0
;;;1665     SemaphoreHandle_t hSemaphore = (SemaphoreHandle_t)semaphore_id;
000004  462e              MOV      r6,r5
;;;1666     osStatus_t stat;
;;;1667   
;;;1668   #ifndef USE_FreeRTOS_HEAP_1
;;;1669     if (IS_IRQ()) {
000006  f7fffffe          BL       __get_IPSR
00000a  b110              CBZ      r0,|L53.18|
;;;1670       stat = osErrorISR;
00000c  f06f0405          MVN      r4,#5
000010  e00a              B        |L53.40|
                  |L53.18|
;;;1671     }
;;;1672     else if (hSemaphore == NULL) {
000012  b916              CBNZ     r6,|L53.26|
;;;1673       stat = osErrorParameter;
000014  f06f0403          MVN      r4,#3
000018  e006              B        |L53.40|
                  |L53.26|
;;;1674     }
;;;1675     else {
;;;1676       #if (configQUEUE_REGISTRY_SIZE > 0)
;;;1677       vQueueUnregisterQueue (hSemaphore);
00001a  4630              MOV      r0,r6
00001c  f7fffffe          BL       vQueueUnregisterQueue
;;;1678       #endif
;;;1679   
;;;1680       stat = osOK;
000020  2400              MOVS     r4,#0
;;;1681       vSemaphoreDelete (hSemaphore);
000022  4630              MOV      r0,r6
000024  f7fffffe          BL       vQueueDelete
                  |L53.40|
;;;1682     }
;;;1683   #else
;;;1684     stat = osError;
;;;1685   #endif
;;;1686   
;;;1687     return (stat);
000028  4620              MOV      r0,r4
;;;1688   }
00002a  bd70              POP      {r4-r6,pc}
;;;1689   
                          ENDP


                          AREA ||i.osSemaphoreGetCount||, CODE, READONLY, ALIGN=1

                  osSemaphoreGetCount PROC
;;;1647   
;;;1648   uint32_t osSemaphoreGetCount (osSemaphoreId_t semaphore_id) {
000000  b570              PUSH     {r4-r6,lr}
000002  4605              MOV      r5,r0
;;;1649     SemaphoreHandle_t hSemaphore = (SemaphoreHandle_t)semaphore_id;
000004  462e              MOV      r6,r5
;;;1650     uint32_t count;
;;;1651   
;;;1652     if (hSemaphore == NULL) {
000006  b90e              CBNZ     r6,|L54.12|
;;;1653       count = 0U;
000008  2400              MOVS     r4,#0
00000a  e00b              B        |L54.36|
                  |L54.12|
;;;1654     }
;;;1655     else if (IS_IRQ()) {
00000c  f7fffffe          BL       __get_IPSR
000010  b120              CBZ      r0,|L54.28|
;;;1656       count = uxQueueMessagesWaitingFromISR (hSemaphore);
000012  4630              MOV      r0,r6
000014  f7fffffe          BL       uxQueueMessagesWaitingFromISR
000018  4604              MOV      r4,r0
00001a  e003              B        |L54.36|
                  |L54.28|
;;;1657     } else {
;;;1658       count = (uint32_t)uxSemaphoreGetCount (hSemaphore);
00001c  4630              MOV      r0,r6
00001e  f7fffffe          BL       uxQueueMessagesWaiting
000022  4604              MOV      r4,r0
                  |L54.36|
;;;1659     }
;;;1660   
;;;1661     return (count);
000024  4620              MOV      r0,r4
;;;1662   }
000026  bd70              POP      {r4-r6,pc}
;;;1663   
                          ENDP


                          AREA ||i.osSemaphoreNew||, CODE, READONLY, ALIGN=1

                  osSemaphoreNew PROC
;;;1507   
;;;1508   osSemaphoreId_t osSemaphoreNew (uint32_t max_count, uint32_t initial_count, const osSemaphoreAttr_t *attr) {
000000  e92d43f8          PUSH     {r3-r9,lr}
000004  4605              MOV      r5,r0
000006  460f              MOV      r7,r1
000008  4614              MOV      r4,r2
;;;1509     SemaphoreHandle_t hSemaphore;
;;;1510     int32_t mem;
;;;1511     #if (configQUEUE_REGISTRY_SIZE > 0)
;;;1512     const char *name;
;;;1513     #endif
;;;1514   
;;;1515     hSemaphore = NULL;
00000a  f04f0800          MOV      r8,#0
;;;1516   
;;;1517     if (!IS_IRQ() && (max_count > 0U) && (initial_count <= max_count)) {
00000e  f7fffffe          BL       __get_IPSR
000012  2800              CMP      r0,#0
000014  d157              BNE      |L55.198|
000016  2d00              CMP      r5,#0
000018  d055              BEQ      |L55.198|
00001a  42af              CMP      r7,r5
00001c  d853              BHI      |L55.198|
;;;1518       mem = -1;
00001e  1e46              SUBS     r6,r0,#1
;;;1519   
;;;1520       if (attr != NULL) {
000020  b164              CBZ      r4,|L55.60|
;;;1521         if ((attr->cb_mem != NULL) && (attr->cb_size >= sizeof(StaticSemaphore_t))) {
000022  68a0              LDR      r0,[r4,#8]
000024  b120              CBZ      r0,|L55.48|
000026  68e0              LDR      r0,[r4,#0xc]
000028  2850              CMP      r0,#0x50
00002a  d301              BCC      |L55.48|
;;;1522           mem = 1;
00002c  2601              MOVS     r6,#1
00002e  e006              B        |L55.62|
                  |L55.48|
;;;1523         }
;;;1524         else {
;;;1525           if ((attr->cb_mem == NULL) && (attr->cb_size == 0U)) {
000030  68a0              LDR      r0,[r4,#8]
000032  b920              CBNZ     r0,|L55.62|
000034  68e0              LDR      r0,[r4,#0xc]
000036  b910              CBNZ     r0,|L55.62|
;;;1526             mem = 0;
000038  2600              MOVS     r6,#0
00003a  e000              B        |L55.62|
                  |L55.60|
;;;1527           }
;;;1528         }
;;;1529       }
;;;1530       else {
;;;1531         mem = 0;
00003c  2600              MOVS     r6,#0
                  |L55.62|
;;;1532       }
;;;1533   
;;;1534       if (mem != -1) {
00003e  1c70              ADDS     r0,r6,#1
000040  2800              CMP      r0,#0
000042  d040              BEQ      |L55.198|
;;;1535         if (max_count == 1U) {
000044  2d01              CMP      r5,#1
000046  d123              BNE      |L55.144|
;;;1536           if (mem == 1) {
000048  2e01              CMP      r6,#1
00004a  d109              BNE      |L55.96|
;;;1537             #if (configSUPPORT_STATIC_ALLOCATION == 1)
;;;1538               hSemaphore = xSemaphoreCreateBinaryStatic ((StaticSemaphore_t *)attr->cb_mem);
00004c  2003              MOVS     r0,#3
00004e  9000              STR      r0,[sp,#0]
000050  2200              MOVS     r2,#0
000052  4611              MOV      r1,r2
000054  2001              MOVS     r0,#1
000056  68a3              LDR      r3,[r4,#8]
000058  f7fffffe          BL       xQueueGenericCreateStatic
00005c  4680              MOV      r8,r0
00005e  e005              B        |L55.108|
                  |L55.96|
;;;1539             #endif
;;;1540           }
;;;1541           else {
;;;1542             #if (configSUPPORT_DYNAMIC_ALLOCATION == 1)
;;;1543               hSemaphore = xSemaphoreCreateBinary();
000060  2203              MOVS     r2,#3
000062  2100              MOVS     r1,#0
000064  2001              MOVS     r0,#1
000066  f7fffffe          BL       xQueueGenericCreate
00006a  4680              MOV      r8,r0
                  |L55.108|
;;;1544             #endif
;;;1545           }
;;;1546   
;;;1547           if ((hSemaphore != NULL) && (initial_count != 0U)) {
00006c  f1b80f00          CMP      r8,#0
000070  d01c              BEQ      |L55.172|
000072  b1df              CBZ      r7,|L55.172|
;;;1548             if (xSemaphoreGive (hSemaphore) != pdPASS) {
000074  2300              MOVS     r3,#0
000076  461a              MOV      r2,r3
000078  4619              MOV      r1,r3
00007a  4640              MOV      r0,r8
00007c  f7fffffe          BL       xQueueGenericSend
000080  2801              CMP      r0,#1
000082  d013              BEQ      |L55.172|
;;;1549               vSemaphoreDelete (hSemaphore);
000084  4640              MOV      r0,r8
000086  f7fffffe          BL       vQueueDelete
;;;1550               hSemaphore = NULL;
00008a  f04f0800          MOV      r8,#0
00008e  e00d              B        |L55.172|
                  |L55.144|
;;;1551             }
;;;1552           }
;;;1553         }
;;;1554         else {
;;;1555           if (mem == 1) {
000090  2e01              CMP      r6,#1
000092  d106              BNE      |L55.162|
;;;1556             #if (configSUPPORT_STATIC_ALLOCATION == 1)
;;;1557               hSemaphore = xSemaphoreCreateCountingStatic (max_count, initial_count, (StaticSemaphore_t *)attr->cb_mem);
000094  4639              MOV      r1,r7
000096  4628              MOV      r0,r5
000098  68a2              LDR      r2,[r4,#8]
00009a  f7fffffe          BL       xQueueCreateCountingSemaphoreStatic
00009e  4680              MOV      r8,r0
0000a0  e004              B        |L55.172|
                  |L55.162|
;;;1558             #endif
;;;1559           }
;;;1560           else {
;;;1561             #if (configSUPPORT_DYNAMIC_ALLOCATION == 1)
;;;1562               hSemaphore = xSemaphoreCreateCounting (max_count, initial_count);
0000a2  4639              MOV      r1,r7
0000a4  4628              MOV      r0,r5
0000a6  f7fffffe          BL       xQueueCreateCountingSemaphore
0000aa  4680              MOV      r8,r0
                  |L55.172|
;;;1563             #endif
;;;1564           }
;;;1565         }
;;;1566         
;;;1567         #if (configQUEUE_REGISTRY_SIZE > 0)
;;;1568         if (hSemaphore != NULL) {
0000ac  f1b80f00          CMP      r8,#0
0000b0  d009              BEQ      |L55.198|
;;;1569           if (attr != NULL) {
0000b2  b114              CBZ      r4,|L55.186|
;;;1570             name = attr->name;
0000b4  f8d49000          LDR      r9,[r4,#0]
0000b8  e001              B        |L55.190|
                  |L55.186|
;;;1571           } else {
;;;1572             name = NULL;
0000ba  f04f0900          MOV      r9,#0
                  |L55.190|
;;;1573           }
;;;1574           vQueueAddToRegistry (hSemaphore, name);
0000be  4649              MOV      r1,r9
0000c0  4640              MOV      r0,r8
0000c2  f7fffffe          BL       vQueueAddToRegistry
                  |L55.198|
;;;1575         }
;;;1576         #endif
;;;1577       }
;;;1578     }
;;;1579   
;;;1580     return ((osSemaphoreId_t)hSemaphore);
0000c6  4640              MOV      r0,r8
;;;1581   }
0000c8  e8bd83f8          POP      {r3-r9,pc}
;;;1582   
                          ENDP


                          AREA ||i.osSemaphoreRelease||, CODE, READONLY, ALIGN=2

                  osSemaphoreRelease PROC
;;;1619   
;;;1620   osStatus_t osSemaphoreRelease (osSemaphoreId_t semaphore_id) {
000000  b5f8              PUSH     {r3-r7,lr}
000002  4604              MOV      r4,r0
;;;1621     SemaphoreHandle_t hSemaphore = (SemaphoreHandle_t)semaphore_id;
000004  4625              MOV      r5,r4
;;;1622     osStatus_t stat;
;;;1623     BaseType_t yield;
;;;1624   
;;;1625     stat = osOK;
000006  2600              MOVS     r6,#0
;;;1626   
;;;1627     if (hSemaphore == NULL) {
000008  b90d              CBNZ     r5,|L56.14|
;;;1628       stat = osErrorParameter;
00000a  1f36              SUBS     r6,r6,#4
00000c  e022              B        |L56.84|
                  |L56.14|
;;;1629     }
;;;1630     else if (IS_IRQ()) {
00000e  f7fffffe          BL       __get_IPSR
000012  b1a8              CBZ      r0,|L56.64|
;;;1631       yield = pdFALSE;
000014  2000              MOVS     r0,#0
000016  9000              STR      r0,[sp,#0]
;;;1632   
;;;1633       if (xSemaphoreGiveFromISR (hSemaphore, &yield) != pdTRUE) {
000018  4669              MOV      r1,sp
00001a  4628              MOV      r0,r5
00001c  f7fffffe          BL       xQueueGiveFromISR
000020  2801              CMP      r0,#1
000022  d002              BEQ      |L56.42|
;;;1634         stat = osErrorResource;
000024  f06f0602          MVN      r6,#2
000028  e014              B        |L56.84|
                  |L56.42|
;;;1635       } else {
;;;1636         portYIELD_FROM_ISR (yield);
00002a  9800              LDR      r0,[sp,#0]
00002c  b190              CBZ      r0,|L56.84|
00002e  f04f5080          MOV      r0,#0x10000000
000032  4909              LDR      r1,|L56.88|
000034  6008              STR      r0,[r1,#0]
000036  f3bf8f4f          DSB      
00003a  f3bf8f6f          ISB      
00003e  e009              B        |L56.84|
                  |L56.64|
;;;1637       }
;;;1638     }
;;;1639     else {
;;;1640       if (xSemaphoreGive (hSemaphore) != pdPASS) {
000040  2300              MOVS     r3,#0
000042  461a              MOV      r2,r3
000044  4619              MOV      r1,r3
000046  4628              MOV      r0,r5
000048  f7fffffe          BL       xQueueGenericSend
00004c  2801              CMP      r0,#1
00004e  d001              BEQ      |L56.84|
;;;1641         stat = osErrorResource;
000050  f06f0602          MVN      r6,#2
                  |L56.84|
;;;1642       }
;;;1643     }
;;;1644   
;;;1645     return (stat);
000054  4630              MOV      r0,r6
;;;1646   }
000056  bdf8              POP      {r3-r7,pc}
;;;1647   
                          ENDP

                  |L56.88|
                          DCD      0xe000ed04

                          AREA ||i.osThreadEnumerate||, CODE, READONLY, ALIGN=1

                  osThreadEnumerate PROC
;;;697    #if (configUSE_OS2_THREAD_ENUMERATE == 1)
;;;698    uint32_t osThreadEnumerate (osThreadId_t *thread_array, uint32_t array_items) {
000000  e92d41f0          PUSH     {r4-r8,lr}
000004  4607              MOV      r7,r0
000006  4688              MOV      r8,r1
;;;699      uint32_t i, count;
;;;700      TaskStatus_t *task;
;;;701    
;;;702      if (IS_IRQ() || (thread_array == NULL) || (array_items == 0U)) {
000008  f7fffffe          BL       __get_IPSR
00000c  b918              CBNZ     r0,|L57.22|
00000e  b117              CBZ      r7,|L57.22|
000010  f1b80f00          CMP      r8,#0
000014  d101              BNE      |L57.26|
                  |L57.22|
;;;703        count = 0U;
000016  2500              MOVS     r5,#0
000018  e024              B        |L57.100|
                  |L57.26|
;;;704      } else {
;;;705        vTaskSuspendAll();
00001a  f7fffffe          BL       vTaskSuspendAll
;;;706    
;;;707        count = uxTaskGetNumberOfTasks();
00001e  f7fffffe          BL       uxTaskGetNumberOfTasks
000022  4605              MOV      r5,r0
;;;708        task  = pvPortMalloc (count * sizeof(TaskStatus_t));
000024  eb0501c5          ADD      r1,r5,r5,LSL #3
000028  0088              LSLS     r0,r1,#2
00002a  f7fffffe          BL       pvPortMalloc
00002e  4606              MOV      r6,r0
;;;709    
;;;710        if (task != NULL) {
000030  b19e              CBZ      r6,|L57.90|
;;;711          count = uxTaskGetSystemState (task, count, NULL);
000032  2200              MOVS     r2,#0
000034  4629              MOV      r1,r5
000036  4630              MOV      r0,r6
000038  f7fffffe          BL       uxTaskGetSystemState
00003c  4605              MOV      r5,r0
;;;712    
;;;713          for (i = 0U; (i < count) && (i < array_items); i++) {
00003e  2400              MOVS     r4,#0
000040  e006              B        |L57.80|
                  |L57.66|
;;;714            thread_array[i] = (osThreadId_t)task[i].xHandle;
000042  eb0400c4          ADD      r0,r4,r4,LSL #3
000046  f8560020          LDR      r0,[r6,r0,LSL #2]
00004a  f8470024          STR      r0,[r7,r4,LSL #2]
00004e  1c64              ADDS     r4,r4,#1              ;713
                  |L57.80|
000050  42ac              CMP      r4,r5                 ;713
000052  d201              BCS      |L57.88|
000054  4544              CMP      r4,r8                 ;713
000056  d3f4              BCC      |L57.66|
                  |L57.88|
;;;715          }
;;;716          count = i;
000058  4625              MOV      r5,r4
                  |L57.90|
;;;717        }
;;;718        (void)xTaskResumeAll();
00005a  f7fffffe          BL       xTaskResumeAll
;;;719    
;;;720        vPortFree (task);
00005e  4630              MOV      r0,r6
000060  f7fffffe          BL       vPortFree
                  |L57.100|
;;;721      }
;;;722    
;;;723      return (count);
000064  4628              MOV      r0,r5
;;;724    }
000066  e8bd81f0          POP      {r4-r8,pc}
;;;725    #endif /* (configUSE_OS2_THREAD_ENUMERATE == 1) */
                          ENDP


                          AREA ||i.osThreadExit||, CODE, READONLY, ALIGN=1

                  osThreadExit PROC
;;;648    
;;;649    __NO_RETURN void osThreadExit (void) {
000000  2000              MOVS     r0,#0
;;;650    #ifndef USE_FreeRTOS_HEAP_1
;;;651      vTaskDelete (NULL);
000002  f7fffffe          BL       vTaskDelete
;;;652    #endif
;;;653      for (;;);
000006  bf00              NOP      
                  |L58.8|
000008  e7fe              B        |L58.8|
;;;654    }
;;;655    
                          ENDP


                          AREA ||i.osThreadFlagsClear||, CODE, READONLY, ALIGN=1

                  osThreadFlagsClear PROC
;;;755    
;;;756    uint32_t osThreadFlagsClear (uint32_t flags) {
000000  b5f8              PUSH     {r3-r7,lr}
000002  4605              MOV      r5,r0
;;;757      TaskHandle_t hTask;
;;;758      uint32_t rflags, cflags;
;;;759    
;;;760      if (IS_IRQ()) {
000004  f7fffffe          BL       __get_IPSR
000008  b110              CBZ      r0,|L59.16|
;;;761        rflags = (uint32_t)osErrorISR;
00000a  f06f0405          MVN      r4,#5
00000e  e021              B        |L59.84|
                  |L59.16|
;;;762      }
;;;763      else if ((flags & THREAD_FLAGS_INVALID_BITS) != 0U) {
000010  f0054000          AND      r0,r5,#0x80000000
000014  b110              CBZ      r0,|L59.28|
;;;764        rflags = (uint32_t)osErrorParameter;
000016  f06f0403          MVN      r4,#3
00001a  e01b              B        |L59.84|
                  |L59.28|
;;;765      }
;;;766      else {
;;;767        hTask = xTaskGetCurrentTaskHandle();
00001c  f7fffffe          BL       xTaskGetCurrentTaskHandle
000020  4606              MOV      r6,r0
;;;768    
;;;769        if (xTaskNotifyAndQuery (hTask, 0, eNoAction, &cflags) == pdPASS) {
000022  466b              MOV      r3,sp
000024  2200              MOVS     r2,#0
000026  4611              MOV      r1,r2
000028  4630              MOV      r0,r6
00002a  f7fffffe          BL       xTaskGenericNotify
00002e  2801              CMP      r0,#1
000030  d10e              BNE      |L59.80|
;;;770          rflags = cflags;
000032  9c00              LDR      r4,[sp,#0]
;;;771          cflags &= ~flags;
000034  9800              LDR      r0,[sp,#0]
000036  43a8              BICS     r0,r0,r5
000038  9000              STR      r0,[sp,#0]
;;;772    
;;;773          if (xTaskNotify (hTask, cflags, eSetValueWithOverwrite) != pdPASS) {
00003a  2300              MOVS     r3,#0
00003c  2203              MOVS     r2,#3
00003e  4630              MOV      r0,r6
000040  9900              LDR      r1,[sp,#0]
000042  f7fffffe          BL       xTaskGenericNotify
000046  2801              CMP      r0,#1
000048  d004              BEQ      |L59.84|
;;;774            rflags = (uint32_t)osError;
00004a  f04f34ff          MOV      r4,#0xffffffff
00004e  e001              B        |L59.84|
                  |L59.80|
;;;775          }
;;;776        }
;;;777        else {
;;;778          rflags = (uint32_t)osError;
000050  f04f34ff          MOV      r4,#0xffffffff
                  |L59.84|
;;;779        }
;;;780      }
;;;781    
;;;782      /* Return flags before clearing */
;;;783      return (rflags);
000054  4620              MOV      r0,r4
;;;784    }
000056  bdf8              POP      {r3-r7,pc}
;;;785    
                          ENDP


                          AREA ||i.osThreadFlagsGet||, CODE, READONLY, ALIGN=1

                  osThreadFlagsGet PROC
;;;785    
;;;786    uint32_t osThreadFlagsGet (void) {
000000  b538              PUSH     {r3-r5,lr}
;;;787      TaskHandle_t hTask;
;;;788      uint32_t rflags;
;;;789    
;;;790      if (IS_IRQ()) {
000002  f7fffffe          BL       __get_IPSR
000006  b118              CBZ      r0,|L60.16|
;;;791        rflags = (uint32_t)osErrorISR;
000008  f06f0005          MVN      r0,#5
00000c  9000              STR      r0,[sp,#0]
00000e  e00d              B        |L60.44|
                  |L60.16|
;;;792      }
;;;793      else {
;;;794        hTask = xTaskGetCurrentTaskHandle();
000010  f7fffffe          BL       xTaskGetCurrentTaskHandle
000014  4604              MOV      r4,r0
;;;795    
;;;796        if (xTaskNotifyAndQuery (hTask, 0, eNoAction, &rflags) != pdPASS) {
000016  466b              MOV      r3,sp
000018  2200              MOVS     r2,#0
00001a  4611              MOV      r1,r2
00001c  4620              MOV      r0,r4
00001e  f7fffffe          BL       xTaskGenericNotify
000022  2801              CMP      r0,#1
000024  d002              BEQ      |L60.44|
;;;797          rflags = (uint32_t)osError;
000026  f04f30ff          MOV      r0,#0xffffffff
00002a  9000              STR      r0,[sp,#0]
                  |L60.44|
;;;798        }
;;;799      }
;;;800    
;;;801      return (rflags);
00002c  9800              LDR      r0,[sp,#0]
;;;802    }
00002e  bd38              POP      {r3-r5,pc}
;;;803    
                          ENDP


                          AREA ||i.osThreadFlagsSet||, CODE, READONLY, ALIGN=2

                  osThreadFlagsSet PROC
;;;727    #if (configUSE_OS2_THREAD_FLAGS == 1)
;;;728    uint32_t osThreadFlagsSet (osThreadId_t thread_id, uint32_t flags) {
000000  b5fe              PUSH     {r1-r7,lr}
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;729      TaskHandle_t hTask = (TaskHandle_t)thread_id;
000006  4626              MOV      r6,r4
;;;730      uint32_t rflags;
;;;731      BaseType_t yield;
;;;732    
;;;733      if ((hTask == NULL) || ((flags & THREAD_FLAGS_INVALID_BITS) != 0U)) {
000008  b116              CBZ      r6,|L61.16|
00000a  f0054000          AND      r0,r5,#0x80000000
00000e  b118              CBZ      r0,|L61.24|
                  |L61.16|
;;;734        rflags = (uint32_t)osErrorParameter;
000010  f06f0003          MVN      r0,#3
000014  9002              STR      r0,[sp,#8]
000016  e02e              B        |L61.118|
                  |L61.24|
;;;735      }
;;;736      else {
;;;737        rflags = (uint32_t)osError;
000018  f04f30ff          MOV      r0,#0xffffffff
00001c  9002              STR      r0,[sp,#8]
;;;738    
;;;739        if (IS_IRQ()) {
00001e  f7fffffe          BL       __get_IPSR
000022  b1e0              CBZ      r0,|L61.94|
;;;740          yield = pdFALSE;
000024  2000              MOVS     r0,#0
000026  9001              STR      r0,[sp,#4]
;;;741    
;;;742          (void)xTaskNotifyFromISR (hTask, flags, eSetBits, &yield);
000028  a801              ADD      r0,sp,#4
00002a  2300              MOVS     r3,#0
00002c  2201              MOVS     r2,#1
00002e  4629              MOV      r1,r5
000030  9000              STR      r0,[sp,#0]
000032  4630              MOV      r0,r6
000034  f7fffffe          BL       xTaskGenericNotifyFromISR
;;;743          (void)xTaskNotifyAndQueryFromISR (hTask, 0, eNoAction, &rflags, NULL);
000038  2000              MOVS     r0,#0
00003a  ab02              ADD      r3,sp,#8
00003c  4602              MOV      r2,r0
00003e  4601              MOV      r1,r0
000040  9000              STR      r0,[sp,#0]
000042  4630              MOV      r0,r6
000044  f7fffffe          BL       xTaskGenericNotifyFromISR
;;;744    
;;;745          portYIELD_FROM_ISR (yield);
000048  9801              LDR      r0,[sp,#4]
00004a  b1a0              CBZ      r0,|L61.118|
00004c  f04f5080          MOV      r0,#0x10000000
000050  490a              LDR      r1,|L61.124|
000052  6008              STR      r0,[r1,#0]
000054  f3bf8f4f          DSB      
000058  f3bf8f6f          ISB      
00005c  e00b              B        |L61.118|
                  |L61.94|
;;;746        }
;;;747        else {
;;;748          (void)xTaskNotify (hTask, flags, eSetBits);
00005e  2300              MOVS     r3,#0
000060  2201              MOVS     r2,#1
000062  4629              MOV      r1,r5
000064  4630              MOV      r0,r6
000066  f7fffffe          BL       xTaskGenericNotify
;;;749          (void)xTaskNotifyAndQuery (hTask, 0, eNoAction, &rflags);
00006a  ab02              ADD      r3,sp,#8
00006c  2200              MOVS     r2,#0
00006e  4611              MOV      r1,r2
000070  4630              MOV      r0,r6
000072  f7fffffe          BL       xTaskGenericNotify
                  |L61.118|
;;;750        }
;;;751      }
;;;752      /* Return flags after setting */
;;;753      return (rflags);
000076  9802              LDR      r0,[sp,#8]
;;;754    }
000078  bdfe              POP      {r1-r7,pc}
;;;755    
                          ENDP

00007a  0000              DCW      0x0000
                  |L61.124|
                          DCD      0xe000ed04

                          AREA ||i.osThreadFlagsWait||, CODE, READONLY, ALIGN=1

                  osThreadFlagsWait PROC
;;;803    
;;;804    uint32_t osThreadFlagsWait (uint32_t flags, uint32_t options, uint32_t timeout) {
000000  e92d5ffc          PUSH     {r2-r12,lr}
000004  4605              MOV      r5,r0
000006  4689              MOV      r9,r1
000008  4616              MOV      r6,r2
;;;805      uint32_t rflags, nval;
;;;806      uint32_t clear;
;;;807      TickType_t t0, td, tout;
;;;808      BaseType_t rval;
;;;809    
;;;810      if (IS_IRQ()) {
00000a  f7fffffe          BL       __get_IPSR
00000e  b110              CBZ      r0,|L62.22|
;;;811        rflags = (uint32_t)osErrorISR;
000010  f06f0405          MVN      r4,#5
000014  e04a              B        |L62.172|
                  |L62.22|
;;;812      }
;;;813      else if ((flags & THREAD_FLAGS_INVALID_BITS) != 0U) {
000016  f0054000          AND      r0,r5,#0x80000000
00001a  b110              CBZ      r0,|L62.34|
;;;814        rflags = (uint32_t)osErrorParameter;
00001c  f06f0403          MVN      r4,#3
000020  e044              B        |L62.172|
                  |L62.34|
;;;815      }
;;;816      else {
;;;817        if ((options & osFlagsNoClear) == osFlagsNoClear) {
000022  f0090002          AND      r0,r9,#2
000026  2802              CMP      r0,#2
000028  d102              BNE      |L62.48|
;;;818          clear = 0U;
00002a  f04f0a00          MOV      r10,#0
00002e  e000              B        |L62.50|
                  |L62.48|
;;;819        } else {
;;;820          clear = flags;
000030  46aa              MOV      r10,r5
                  |L62.50|
;;;821        }
;;;822    
;;;823        rflags = 0U;
000032  2400              MOVS     r4,#0
;;;824        tout   = timeout;
000034  4637              MOV      r7,r6
;;;825    
;;;826        t0 = xTaskGetTickCount();
000036  f7fffffe          BL       xTaskGetTickCount
00003a  9000              STR      r0,[sp,#0]
;;;827        do {
00003c  bf00              NOP      
                  |L62.62|
;;;828          rval = xTaskNotifyWait (0, clear, &nval, tout);
00003e  463b              MOV      r3,r7
000040  aa01              ADD      r2,sp,#4
000042  4651              MOV      r1,r10
000044  2000              MOVS     r0,#0
000046  f7fffffe          BL       xTaskNotifyWait
00004a  4680              MOV      r8,r0
;;;829    
;;;830          if (rval == pdPASS) {
00004c  f1b80f01          CMP      r8,#1
000050  d122              BNE      |L62.152|
;;;831            rflags &= flags;
000052  402c              ANDS     r4,r4,r5
;;;832            rflags |= nval;
000054  9801              LDR      r0,[sp,#4]
000056  4304              ORRS     r4,r4,r0
;;;833    
;;;834            if ((options & osFlagsWaitAll) == osFlagsWaitAll) {
000058  f0090001          AND      r0,r9,#1
00005c  b140              CBZ      r0,|L62.112|
;;;835              if ((flags & rflags) == flags) {
00005e  ea050004          AND      r0,r5,r4
000062  42a8              CMP      r0,r5
000064  d100              BNE      |L62.104|
;;;836                break;
000066  e020              B        |L62.170|
                  |L62.104|
;;;837              } else {
;;;838                if (timeout == 0U) {
000068  b956              CBNZ     r6,|L62.128|
;;;839                  rflags = (uint32_t)osErrorResource;
00006a  f06f0402          MVN      r4,#2
;;;840                  break;
00006e  e01c              B        |L62.170|
                  |L62.112|
;;;841                }
;;;842              }
;;;843            }
;;;844            else {
;;;845              if ((flags & rflags) != 0) {
000070  ea050004          AND      r0,r5,r4
000074  b100              CBZ      r0,|L62.120|
;;;846                break;
000076  e018              B        |L62.170|
                  |L62.120|
;;;847              } else {
;;;848                if (timeout == 0U) {
000078  b916              CBNZ     r6,|L62.128|
;;;849                  rflags = (uint32_t)osErrorResource;
00007a  f06f0402          MVN      r4,#2
;;;850                  break;
00007e  e014              B        |L62.170|
                  |L62.128|
;;;851                }
;;;852              }
;;;853            }
;;;854    
;;;855            /* Update timeout */
;;;856            td = xTaskGetTickCount() - t0;
000080  f7fffffe          BL       xTaskGetTickCount
000084  9900              LDR      r1,[sp,#0]
000086  eba00b01          SUB      r11,r0,r1
;;;857    
;;;858            if (td > tout) {
00008a  45bb              CMP      r11,r7
00008c  d901              BLS      |L62.146|
;;;859              tout  = 0;
00008e  2700              MOVS     r7,#0
000090  e008              B        |L62.164|
                  |L62.146|
;;;860            } else {
;;;861              tout -= td;
000092  eba7070b          SUB      r7,r7,r11
000096  e005              B        |L62.164|
                  |L62.152|
;;;862            }
;;;863          }
;;;864          else {
;;;865            if (timeout == 0) {
000098  b916              CBNZ     r6,|L62.160|
;;;866              rflags = (uint32_t)osErrorResource;
00009a  f06f0402          MVN      r4,#2
00009e  e001              B        |L62.164|
                  |L62.160|
;;;867            } else {
;;;868              rflags = (uint32_t)osErrorTimeout;
0000a0  f06f0401          MVN      r4,#1
                  |L62.164|
;;;869            }
;;;870          }
;;;871        }
;;;872        while (rval != pdFAIL);
0000a4  f1b80f00          CMP      r8,#0
0000a8  d1c9              BNE      |L62.62|
                  |L62.170|
0000aa  bf00              NOP                            ;836
                  |L62.172|
;;;873      }
;;;874    
;;;875      /* Return flags before clearing */
;;;876      return (rflags);
0000ac  4620              MOV      r0,r4
;;;877    }
0000ae  e8bd9ffc          POP      {r2-r12,pc}
;;;878    #endif /* (configUSE_OS2_THREAD_FLAGS == 1) */
                          ENDP


                          AREA ||i.osThreadGetCount||, CODE, READONLY, ALIGN=1

                  osThreadGetCount PROC
;;;684    
;;;685    uint32_t osThreadGetCount (void) {
000000  b510              PUSH     {r4,lr}
;;;686      uint32_t count;
;;;687    
;;;688      if (IS_IRQ()) {
000002  f7fffffe          BL       __get_IPSR
000006  b108              CBZ      r0,|L63.12|
;;;689        count = 0U;
000008  2400              MOVS     r4,#0
00000a  e002              B        |L63.18|
                  |L63.12|
;;;690      } else {
;;;691        count = uxTaskGetNumberOfTasks();
00000c  f7fffffe          BL       uxTaskGetNumberOfTasks
000010  4604              MOV      r4,r0
                  |L63.18|
;;;692      }
;;;693    
;;;694      return (count);
000012  4620              MOV      r0,r4
;;;695    }
000014  bd10              POP      {r4,pc}
;;;696    
                          ENDP


                          AREA ||i.osThreadGetId||, CODE, READONLY, ALIGN=1

                  osThreadGetId PROC
;;;523    
;;;524    osThreadId_t osThreadGetId (void) {
000000  b510              PUSH     {r4,lr}
;;;525      osThreadId_t id;
;;;526    
;;;527      id = (osThreadId_t)xTaskGetCurrentTaskHandle();
000002  f7fffffe          BL       xTaskGetCurrentTaskHandle
000006  4604              MOV      r4,r0
;;;528    
;;;529      return (id);
000008  4620              MOV      r0,r4
;;;530    }
00000a  bd10              POP      {r4,pc}
;;;531    
                          ENDP


                          AREA ||i.osThreadGetName||, CODE, READONLY, ALIGN=1

                  osThreadGetName PROC
;;;510    
;;;511    const char *osThreadGetName (osThreadId_t thread_id) {
000000  b570              PUSH     {r4-r6,lr}
000002  4605              MOV      r5,r0
;;;512      TaskHandle_t hTask = (TaskHandle_t)thread_id;
000004  462e              MOV      r6,r5
;;;513      const char *name;
;;;514    
;;;515      if (IS_IRQ() || (hTask == NULL)) {
000006  f7fffffe          BL       __get_IPSR
00000a  b900              CBNZ     r0,|L65.14|
00000c  b90e              CBNZ     r6,|L65.18|
                  |L65.14|
;;;516        name = NULL;
00000e  2400              MOVS     r4,#0
000010  e003              B        |L65.26|
                  |L65.18|
;;;517      } else {
;;;518        name = pcTaskGetName (hTask);
000012  4630              MOV      r0,r6
000014  f7fffffe          BL       pcTaskGetName
000018  4604              MOV      r4,r0
                  |L65.26|
;;;519      }
;;;520    
;;;521      return (name);
00001a  4620              MOV      r0,r4
;;;522    }
00001c  bd70              POP      {r4-r6,pc}
;;;523    
                          ENDP


                          AREA ||i.osThreadGetPriority||, CODE, READONLY, ALIGN=1

                  osThreadGetPriority PROC
;;;584    
;;;585    osPriority_t osThreadGetPriority (osThreadId_t thread_id) {
000000  b570              PUSH     {r4-r6,lr}
000002  4605              MOV      r5,r0
;;;586      TaskHandle_t hTask = (TaskHandle_t)thread_id;
000004  462e              MOV      r6,r5
;;;587      osPriority_t prio;
;;;588    
;;;589      if (IS_IRQ() || (hTask == NULL)) {
000006  f7fffffe          BL       __get_IPSR
00000a  b900              CBNZ     r0,|L66.14|
00000c  b916              CBNZ     r6,|L66.20|
                  |L66.14|
;;;590        prio = osPriorityError;
00000e  f04f34ff          MOV      r4,#0xffffffff
000012  e003              B        |L66.28|
                  |L66.20|
;;;591      } else {
;;;592        prio = (osPriority_t)((int32_t)uxTaskPriorityGet (hTask));
000014  4630              MOV      r0,r6
000016  f7fffffe          BL       uxTaskPriorityGet
00001a  4604              MOV      r4,r0
                  |L66.28|
;;;593      }
;;;594    
;;;595      return (prio);
00001c  4620              MOV      r0,r4
;;;596    }
00001e  bd70              POP      {r4-r6,pc}
;;;597    
                          ENDP


                          AREA ||i.osThreadGetStackSpace||, CODE, READONLY, ALIGN=1

                  osThreadGetStackSpace PROC
;;;553    
;;;554    uint32_t osThreadGetStackSpace (osThreadId_t thread_id) {
000000  b570              PUSH     {r4-r6,lr}
000002  4605              MOV      r5,r0
;;;555      TaskHandle_t hTask = (TaskHandle_t)thread_id;
000004  462e              MOV      r6,r5
;;;556      uint32_t sz;
;;;557    
;;;558      if (IS_IRQ() || (hTask == NULL)) {
000006  f7fffffe          BL       __get_IPSR
00000a  b900              CBNZ     r0,|L67.14|
00000c  b90e              CBNZ     r6,|L67.18|
                  |L67.14|
;;;559        sz = 0U;
00000e  2400              MOVS     r4,#0
000010  e003              B        |L67.26|
                  |L67.18|
;;;560      } else {
;;;561        sz = (uint32_t)(uxTaskGetStackHighWaterMark(hTask) * sizeof(StackType_t));
000012  4630              MOV      r0,r6
000014  f7fffffe          BL       uxTaskGetStackHighWaterMark
000018  0084              LSLS     r4,r0,#2
                  |L67.26|
;;;562      }
;;;563    
;;;564      return (sz);
00001a  4620              MOV      r0,r4
;;;565    }
00001c  bd70              POP      {r4-r6,pc}
;;;566    
                          ENDP


                          AREA ||i.osThreadGetState||, CODE, READONLY, ALIGN=1

                  osThreadGetState PROC
;;;531    
;;;532    osThreadState_t osThreadGetState (osThreadId_t thread_id) {
000000  b570              PUSH     {r4-r6,lr}
000002  4605              MOV      r5,r0
;;;533      TaskHandle_t hTask = (TaskHandle_t)thread_id;
000004  462e              MOV      r6,r5
;;;534      osThreadState_t state;
;;;535    
;;;536      if (IS_IRQ() || (hTask == NULL)) {
000006  f7fffffe          BL       __get_IPSR
00000a  b900              CBNZ     r0,|L68.14|
00000c  b916              CBNZ     r6,|L68.20|
                  |L68.14|
;;;537        state = osThreadError;
00000e  f04f34ff          MOV      r4,#0xffffffff
000012  e017              B        |L68.68|
                  |L68.20|
;;;538      }
;;;539      else {
;;;540        switch (eTaskGetState (hTask)) {
000014  4630              MOV      r0,r6
000016  f7fffffe          BL       eTaskGetState
00001a  2806              CMP      r0,#6
00001c  d20d              BCS      |L68.58|
00001e  e8dff000          TBB      [pc,r0]
000022  0305              DCB      0x03,0x05
000024  07080a0d          DCB      0x07,0x08,0x0a,0x0d
;;;541          case eRunning:   state = osThreadRunning;    break;
000028  2402              MOVS     r4,#2
00002a  e00a              B        |L68.66|
;;;542          case eReady:     state = osThreadReady;      break;
00002c  2401              MOVS     r4,#1
00002e  e008              B        |L68.66|
;;;543          case eBlocked:
;;;544          case eSuspended: state = osThreadBlocked;    break;
000030  bf00              NOP      
000032  2403              MOVS     r4,#3
000034  e005              B        |L68.66|
;;;545          case eDeleted:   state = osThreadTerminated; break;
000036  2404              MOVS     r4,#4
000038  e003              B        |L68.66|
                  |L68.58|
;;;546          case eInvalid:
00003a  bf00              NOP      
;;;547          default:         state = osThreadError;      break;
00003c  f04f34ff          MOV      r4,#0xffffffff
000040  bf00              NOP      
                  |L68.66|
000042  bf00              NOP                            ;541
                  |L68.68|
;;;548        }
;;;549      }
;;;550    
;;;551      return (state);
000044  4620              MOV      r0,r4
;;;552    }
000046  bd70              POP      {r4-r6,pc}
;;;553    
                          ENDP


                          AREA ||i.osThreadNew||, CODE, READONLY, ALIGN=1

                  osThreadNew PROC
;;;442    
;;;443    osThreadId_t osThreadNew (osThreadFunc_t func, void *argument, const osThreadAttr_t *attr) {
000000  e92d47ff          PUSH     {r0-r10,lr}
000004  4680              MOV      r8,r0
000006  4689              MOV      r9,r1
000008  4614              MOV      r4,r2
;;;444      const char *name;
;;;445      uint32_t stack;
;;;446      TaskHandle_t hTask;
;;;447      UBaseType_t prio;
;;;448      int32_t mem;
;;;449    
;;;450      hTask = NULL;
00000a  2000              MOVS     r0,#0
00000c  9003              STR      r0,[sp,#0xc]
;;;451    
;;;452      if (!IS_IRQ() && (func != NULL)) {
00000e  f7fffffe          BL       __get_IPSR
000012  2800              CMP      r0,#0
000014  d14e              BNE      |L69.180|
000016  f1b80f00          CMP      r8,#0
00001a  d04b              BEQ      |L69.180|
;;;453        stack = configMINIMAL_STACK_SIZE;
00001c  2680              MOVS     r6,#0x80
;;;454        prio  = (UBaseType_t)osPriorityNormal;
00001e  2518              MOVS     r5,#0x18
;;;455    
;;;456        name = NULL;
000020  4682              MOV      r10,r0
;;;457        mem  = -1;
000022  1e47              SUBS     r7,r0,#1
;;;458    
;;;459        if (attr != NULL) {
000024  b344              CBZ      r4,|L69.120|
;;;460          if (attr->name != NULL) {
000026  6820              LDR      r0,[r4,#0]
000028  b108              CBZ      r0,|L69.46|
;;;461            name = attr->name;
00002a  f8d4a000          LDR      r10,[r4,#0]
                  |L69.46|
;;;462          }
;;;463          if (attr->priority != osPriorityNone) {
00002e  69a0              LDR      r0,[r4,#0x18]
000030  b100              CBZ      r0,|L69.52|
;;;464            prio = (UBaseType_t)attr->priority;
000032  69a5              LDR      r5,[r4,#0x18]
                  |L69.52|
;;;465          }
;;;466    
;;;467          if ((prio < osPriorityIdle) || (prio > osPriorityISR) || ((attr->attr_bits & osThreadJoinable) == osThreadJoinable)) {
000034  b12d              CBZ      r5,|L69.66|
000036  2d38              CMP      r5,#0x38
000038  d803              BHI      |L69.66|
00003a  7920              LDRB     r0,[r4,#4]
00003c  f0000001          AND      r0,r0,#1
000040  b118              CBZ      r0,|L69.74|
                  |L69.66|
;;;468            return (NULL);
000042  2000              MOVS     r0,#0
                  |L69.68|
;;;469          }
;;;470    
;;;471          if (attr->stack_size > 0U) {
;;;472            /* In FreeRTOS stack is not in bytes, but in sizeof(StackType_t) which is 4 on ARM ports.       */
;;;473            /* Stack size should be therefore 4 byte aligned in order to avoid division caused side effects */
;;;474            stack = attr->stack_size / sizeof(StackType_t);
;;;475          }
;;;476    
;;;477          if ((attr->cb_mem    != NULL) && (attr->cb_size    >= sizeof(StaticTask_t)) &&
;;;478              (attr->stack_mem != NULL) && (attr->stack_size >  0U)) {
;;;479            mem = 1;
;;;480          }
;;;481          else {
;;;482            if ((attr->cb_mem == NULL) && (attr->cb_size == 0U) && (attr->stack_mem == NULL)) {
;;;483              mem = 0;
;;;484            }
;;;485          }
;;;486        }
;;;487        else {
;;;488          mem = 0;
;;;489        }
;;;490    
;;;491        if (mem == 1) {
;;;492          #if (configSUPPORT_STATIC_ALLOCATION == 1)
;;;493            hTask = xTaskCreateStatic ((TaskFunction_t)func, name, stack, argument, prio, (StackType_t  *)attr->stack_mem,
;;;494                                                                                          (StaticTask_t *)attr->cb_mem);
;;;495          #endif
;;;496        }
;;;497        else {
;;;498          if (mem == 0) {
;;;499            #if (configSUPPORT_DYNAMIC_ALLOCATION == 1)
;;;500              if (xTaskCreate ((TaskFunction_t)func, name, (uint16_t)stack, argument, prio, &hTask) != pdPASS) {
;;;501                hTask = NULL;
;;;502              }
;;;503            #endif
;;;504          }
;;;505        }
;;;506      }
;;;507    
;;;508      return ((osThreadId_t)hTask);
;;;509    }
000044  b004              ADD      sp,sp,#0x10
000046  e8bd87f0          POP      {r4-r10,pc}
                  |L69.74|
00004a  6960              LDR      r0,[r4,#0x14]         ;471
00004c  b108              CBZ      r0,|L69.82|
00004e  6960              LDR      r0,[r4,#0x14]         ;474
000050  0886              LSRS     r6,r0,#2              ;474
                  |L69.82|
000052  68a0              LDR      r0,[r4,#8]            ;477
000054  b140              CBZ      r0,|L69.104|
000056  68e0              LDR      r0,[r4,#0xc]          ;477
000058  285c              CMP      r0,#0x5c              ;477
00005a  d305              BCC      |L69.104|
00005c  6920              LDR      r0,[r4,#0x10]         ;478
00005e  b118              CBZ      r0,|L69.104|
000060  6960              LDR      r0,[r4,#0x14]         ;478
000062  b108              CBZ      r0,|L69.104|
000064  2701              MOVS     r7,#1                 ;479
000066  e008              B        |L69.122|
                  |L69.104|
000068  68a0              LDR      r0,[r4,#8]            ;482
00006a  b930              CBNZ     r0,|L69.122|
00006c  68e0              LDR      r0,[r4,#0xc]          ;482
00006e  b920              CBNZ     r0,|L69.122|
000070  6920              LDR      r0,[r4,#0x10]         ;482
000072  b910              CBNZ     r0,|L69.122|
000074  2700              MOVS     r7,#0                 ;483
000076  e000              B        |L69.122|
                  |L69.120|
000078  2700              MOVS     r7,#0                 ;488
                  |L69.122|
00007a  2f01              CMP      r7,#1                 ;491
00007c  d10c              BNE      |L69.152|
00007e  6921              LDR      r1,[r4,#0x10]         ;493
000080  68a0              LDR      r0,[r4,#8]            ;493
000082  464b              MOV      r3,r9                 ;493
000084  4632              MOV      r2,r6                 ;493
000086  e9cd5100          STRD     r5,r1,[sp,#0]         ;493
00008a  9002              STR      r0,[sp,#8]            ;493
00008c  4651              MOV      r1,r10                ;493
00008e  4640              MOV      r0,r8                 ;493
000090  f7fffffe          BL       xTaskCreateStatic
000094  9003              STR      r0,[sp,#0xc]          ;493
000096  e00d              B        |L69.180|
                  |L69.152|
000098  b967              CBNZ     r7,|L69.180|
00009a  a803              ADD      r0,sp,#0xc            ;500
00009c  b2b2              UXTH     r2,r6                 ;500
00009e  464b              MOV      r3,r9                 ;500
0000a0  4651              MOV      r1,r10                ;500
0000a2  e9cd5000          STRD     r5,r0,[sp,#0]         ;500
0000a6  4640              MOV      r0,r8                 ;500
0000a8  f7fffffe          BL       xTaskCreate
0000ac  2801              CMP      r0,#1                 ;500
0000ae  d001              BEQ      |L69.180|
0000b0  2000              MOVS     r0,#0                 ;501
0000b2  9003              STR      r0,[sp,#0xc]          ;501
                  |L69.180|
0000b4  9803              LDR      r0,[sp,#0xc]          ;508
0000b6  e7c5              B        |L69.68|
;;;510    
                          ENDP


                          AREA ||i.osThreadResume||, CODE, READONLY, ALIGN=1

                  osThreadResume PROC
;;;629    
;;;630    osStatus_t osThreadResume (osThreadId_t thread_id) {
000000  b570              PUSH     {r4-r6,lr}
000002  4605              MOV      r5,r0
;;;631      TaskHandle_t hTask = (TaskHandle_t)thread_id;
000004  462e              MOV      r6,r5
;;;632      osStatus_t stat;
;;;633    
;;;634      if (IS_IRQ()) {
000006  f7fffffe          BL       __get_IPSR
00000a  b110              CBZ      r0,|L70.18|
;;;635        stat = osErrorISR;
00000c  f06f0405          MVN      r4,#5
000010  e007              B        |L70.34|
                  |L70.18|
;;;636      }
;;;637      else if (hTask == NULL) {
000012  b916              CBNZ     r6,|L70.26|
;;;638        stat = osErrorParameter;
000014  f06f0403          MVN      r4,#3
000018  e003              B        |L70.34|
                  |L70.26|
;;;639      }
;;;640      else {
;;;641        stat = osOK;
00001a  2400              MOVS     r4,#0
;;;642        vTaskResume (hTask);
00001c  4630              MOV      r0,r6
00001e  f7fffffe          BL       vTaskResume
                  |L70.34|
;;;643      }
;;;644    
;;;645      return (stat);
000022  4620              MOV      r0,r4
;;;646    }
000024  bd70              POP      {r4-r6,pc}
;;;647    #endif /* (configUSE_OS2_THREAD_SUSPEND_RESUME == 1) */
                          ENDP


                          AREA ||i.osThreadSetPriority||, CODE, READONLY, ALIGN=1

                  osThreadSetPriority PROC
;;;566    
;;;567    osStatus_t osThreadSetPriority (osThreadId_t thread_id, osPriority_t priority) {
000000  e92d41f0          PUSH     {r4-r8,lr}
000004  4607              MOV      r7,r0
000006  460d              MOV      r5,r1
;;;568      TaskHandle_t hTask = (TaskHandle_t)thread_id;
000008  463e              MOV      r6,r7
;;;569      osStatus_t stat;
;;;570    
;;;571      if (IS_IRQ()) {
00000a  f7fffffe          BL       __get_IPSR
00000e  b110              CBZ      r0,|L71.22|
;;;572        stat = osErrorISR;
000010  f06f0405          MVN      r4,#5
000014  e00c              B        |L71.48|
                  |L71.22|
;;;573      }
;;;574      else if ((hTask == NULL) || (priority < osPriorityIdle) || (priority > osPriorityISR)) {
000016  b11e              CBZ      r6,|L71.32|
000018  2d01              CMP      r5,#1
00001a  db01              BLT      |L71.32|
00001c  2d38              CMP      r5,#0x38
00001e  dd02              BLE      |L71.38|
                  |L71.32|
;;;575        stat = osErrorParameter;
000020  f06f0403          MVN      r4,#3
000024  e004              B        |L71.48|
                  |L71.38|
;;;576      }
;;;577      else {
;;;578        stat = osOK;
000026  2400              MOVS     r4,#0
;;;579        vTaskPrioritySet (hTask, (UBaseType_t)priority);
000028  4629              MOV      r1,r5
00002a  4630              MOV      r0,r6
00002c  f7fffffe          BL       vTaskPrioritySet
                  |L71.48|
;;;580      }
;;;581    
;;;582      return (stat);
000030  4620              MOV      r0,r4
;;;583    }
000032  e8bd81f0          POP      {r4-r8,pc}
;;;584    
                          ENDP


                          AREA ||i.osThreadSuspend||, CODE, READONLY, ALIGN=1

                  osThreadSuspend PROC
;;;611    #if (configUSE_OS2_THREAD_SUSPEND_RESUME == 1)
;;;612    osStatus_t osThreadSuspend (osThreadId_t thread_id) {
000000  b570              PUSH     {r4-r6,lr}
000002  4605              MOV      r5,r0
;;;613      TaskHandle_t hTask = (TaskHandle_t)thread_id;
000004  462e              MOV      r6,r5
;;;614      osStatus_t stat;
;;;615    
;;;616      if (IS_IRQ()) {
000006  f7fffffe          BL       __get_IPSR
00000a  b110              CBZ      r0,|L72.18|
;;;617        stat = osErrorISR;
00000c  f06f0405          MVN      r4,#5
000010  e007              B        |L72.34|
                  |L72.18|
;;;618      }
;;;619      else if (hTask == NULL) {
000012  b916              CBNZ     r6,|L72.26|
;;;620        stat = osErrorParameter;
000014  f06f0403          MVN      r4,#3
000018  e003              B        |L72.34|
                  |L72.26|
;;;621      }
;;;622      else {
;;;623        stat = osOK;
00001a  2400              MOVS     r4,#0
;;;624        vTaskSuspend (hTask);
00001c  4630              MOV      r0,r6
00001e  f7fffffe          BL       vTaskSuspend
                  |L72.34|
;;;625      }
;;;626    
;;;627      return (stat);
000022  4620              MOV      r0,r4
;;;628    }
000024  bd70              POP      {r4-r6,pc}
;;;629    
                          ENDP


                          AREA ||i.osThreadTerminate||, CODE, READONLY, ALIGN=1

                  osThreadTerminate PROC
;;;655    
;;;656    osStatus_t osThreadTerminate (osThreadId_t thread_id) {
000000  e92d41f0          PUSH     {r4-r8,lr}
000004  4606              MOV      r6,r0
;;;657      TaskHandle_t hTask = (TaskHandle_t)thread_id;
000006  4637              MOV      r7,r6
;;;658      osStatus_t stat;
;;;659    #ifndef USE_FreeRTOS_HEAP_1
;;;660      eTaskState tstate;
;;;661    
;;;662      if (IS_IRQ()) {
000008  f7fffffe          BL       __get_IPSR
00000c  b110              CBZ      r0,|L73.20|
;;;663        stat = osErrorISR;
00000e  f06f0405          MVN      r4,#5
000012  e010              B        |L73.54|
                  |L73.20|
;;;664      }
;;;665      else if (hTask == NULL) {
000014  b917              CBNZ     r7,|L73.28|
;;;666        stat = osErrorParameter;
000016  f06f0403          MVN      r4,#3
00001a  e00c              B        |L73.54|
                  |L73.28|
;;;667      }
;;;668      else {
;;;669        tstate = eTaskGetState (hTask);
00001c  4638              MOV      r0,r7
00001e  f7fffffe          BL       eTaskGetState
000022  4605              MOV      r5,r0
;;;670    
;;;671        if (tstate != eDeleted) {
000024  2d04              CMP      r5,#4
000026  d004              BEQ      |L73.50|
;;;672          stat = osOK;
000028  2400              MOVS     r4,#0
;;;673          vTaskDelete (hTask);
00002a  4638              MOV      r0,r7
00002c  f7fffffe          BL       vTaskDelete
000030  e001              B        |L73.54|
                  |L73.50|
;;;674        } else {
;;;675          stat = osErrorResource;
000032  f06f0402          MVN      r4,#2
                  |L73.54|
;;;676        }
;;;677      }
;;;678    #else
;;;679      stat = osError;
;;;680    #endif
;;;681    
;;;682      return (stat);
000036  4620              MOV      r0,r4
;;;683    }
000038  e8bd81f0          POP      {r4-r8,pc}
;;;684    
                          ENDP


                          AREA ||i.osThreadYield||, CODE, READONLY, ALIGN=2

                  osThreadYield PROC
;;;597    
;;;598    osStatus_t osThreadYield (void) {
000000  b510              PUSH     {r4,lr}
;;;599      osStatus_t stat;
;;;600    
;;;601      if (IS_IRQ()) {
000002  f7fffffe          BL       __get_IPSR
000006  b110              CBZ      r0,|L74.14|
;;;602        stat = osErrorISR;
000008  f06f0405          MVN      r4,#5
00000c  e008              B        |L74.32|
                  |L74.14|
;;;603      } else {
;;;604        stat = osOK;
00000e  2400              MOVS     r4,#0
;;;605        taskYIELD();
000010  f04f5080          MOV      r0,#0x10000000
000014  4903              LDR      r1,|L74.36|
000016  6008              STR      r0,[r1,#0]
000018  f3bf8f4f          DSB      
00001c  f3bf8f6f          ISB      
                  |L74.32|
;;;606      }
;;;607    
;;;608      return (stat);
000020  4620              MOV      r0,r4
;;;609    }
000022  bd10              POP      {r4,pc}
;;;610    
                          ENDP

                  |L74.36|
                          DCD      0xe000ed04

                          AREA ||i.osTimerDelete||, CODE, READONLY, ALIGN=1

                  osTimerDelete PROC
;;;1076   
;;;1077   osStatus_t osTimerDelete (osTimerId_t timer_id) {
000000  b5f8              PUSH     {r3-r7,lr}
000002  4605              MOV      r5,r0
;;;1078     TimerHandle_t hTimer = (TimerHandle_t)timer_id;
000004  462e              MOV      r6,r5
;;;1079     osStatus_t stat;
;;;1080   #ifndef USE_FreeRTOS_HEAP_1
;;;1081     TimerCallback_t *callb;
;;;1082   
;;;1083     if (IS_IRQ()) {
000006  f7fffffe          BL       __get_IPSR
00000a  b110              CBZ      r0,|L75.18|
;;;1084       stat = osErrorISR;
00000c  f06f0405          MVN      r4,#5
000010  e018              B        |L75.68|
                  |L75.18|
;;;1085     }
;;;1086     else if (hTimer == NULL) {
000012  b916              CBNZ     r6,|L75.26|
;;;1087       stat = osErrorParameter;
000014  f06f0403          MVN      r4,#3
000018  e014              B        |L75.68|
                  |L75.26|
;;;1088     }
;;;1089     else {
;;;1090       callb = (TimerCallback_t *)pvTimerGetTimerID (hTimer);
00001a  4630              MOV      r0,r6
00001c  f7fffffe          BL       pvTimerGetTimerID
000020  4607              MOV      r7,r0
;;;1091   
;;;1092       if (xTimerDelete (hTimer, 0) == pdPASS) {
000022  2000              MOVS     r0,#0
000024  4603              MOV      r3,r0
000026  4602              MOV      r2,r0
000028  2105              MOVS     r1,#5
00002a  9000              STR      r0,[sp,#0]
00002c  4630              MOV      r0,r6
00002e  f7fffffe          BL       xTimerGenericCommand
000032  2801              CMP      r0,#1
000034  d104              BNE      |L75.64|
;;;1093         vPortFree (callb);
000036  4638              MOV      r0,r7
000038  f7fffffe          BL       vPortFree
;;;1094         stat = osOK;
00003c  2400              MOVS     r4,#0
00003e  e001              B        |L75.68|
                  |L75.64|
;;;1095       } else {
;;;1096         stat = osErrorResource;
000040  f06f0402          MVN      r4,#2
                  |L75.68|
;;;1097       }
;;;1098     }
;;;1099   #else
;;;1100     stat = osError;
;;;1101   #endif
;;;1102   
;;;1103     return (stat);
000044  4620              MOV      r0,r4
;;;1104   }
000046  bdf8              POP      {r3-r7,pc}
;;;1105   #endif /* (configUSE_OS2_TIMER == 1) */
                          ENDP


                          AREA ||i.osTimerGetName||, CODE, READONLY, ALIGN=1

                  osTimerGetName PROC
;;;1003   
;;;1004   const char *osTimerGetName (osTimerId_t timer_id) {
000000  b570              PUSH     {r4-r6,lr}
000002  4605              MOV      r5,r0
;;;1005     TimerHandle_t hTimer = (TimerHandle_t)timer_id;
000004  462e              MOV      r6,r5
;;;1006     const char *p;
;;;1007   
;;;1008     if (IS_IRQ() || (hTimer == NULL)) {
000006  f7fffffe          BL       __get_IPSR
00000a  b900              CBNZ     r0,|L76.14|
00000c  b90e              CBNZ     r6,|L76.18|
                  |L76.14|
;;;1009       p = NULL;
00000e  2400              MOVS     r4,#0
000010  e003              B        |L76.26|
                  |L76.18|
;;;1010     } else {
;;;1011       p = pcTimerGetName (hTimer);
000012  4630              MOV      r0,r6
000014  f7fffffe          BL       pcTimerGetName
000018  4604              MOV      r4,r0
                  |L76.26|
;;;1012     }
;;;1013   
;;;1014     return (p);
00001a  4620              MOV      r0,r4
;;;1015   }
00001c  bd70              POP      {r4-r6,pc}
;;;1016   
                          ENDP


                          AREA ||i.osTimerIsRunning||, CODE, READONLY, ALIGN=1

                  osTimerIsRunning PROC
;;;1063   
;;;1064   uint32_t osTimerIsRunning (osTimerId_t timer_id) {
000000  b570              PUSH     {r4-r6,lr}
000002  4605              MOV      r5,r0
;;;1065     TimerHandle_t hTimer = (TimerHandle_t)timer_id;
000004  462e              MOV      r6,r5
;;;1066     uint32_t running;
;;;1067   
;;;1068     if (IS_IRQ() || (hTimer == NULL)) {
000006  f7fffffe          BL       __get_IPSR
00000a  b900              CBNZ     r0,|L77.14|
00000c  b90e              CBNZ     r6,|L77.18|
                  |L77.14|
;;;1069       running = 0U;
00000e  2400              MOVS     r4,#0
000010  e003              B        |L77.26|
                  |L77.18|
;;;1070     } else {
;;;1071       running = (uint32_t)xTimerIsTimerActive (hTimer);
000012  4630              MOV      r0,r6
000014  f7fffffe          BL       xTimerIsTimerActive
000018  4604              MOV      r4,r0
                  |L77.26|
;;;1072     }
;;;1073   
;;;1074     return (running);
00001a  4620              MOV      r0,r4
;;;1075   }
00001c  bd70              POP      {r4-r6,pc}
;;;1076   
                          ENDP


                          AREA ||i.osTimerNew||, CODE, READONLY, ALIGN=2

                  osTimerNew PROC
;;;937    
;;;938    osTimerId_t osTimerNew (osTimerFunc_t func, osTimerType_t type, void *argument, const osTimerAttr_t *attr) {
000000  e92d4ffe          PUSH     {r1-r11,lr}
000004  4606              MOV      r6,r0
000006  4689              MOV      r9,r1
000008  4692              MOV      r10,r2
00000a  461c              MOV      r4,r3
;;;939      const char *name;
;;;940      TimerHandle_t hTimer;
;;;941      TimerCallback_t *callb;
;;;942      UBaseType_t reload;
;;;943      int32_t mem;
;;;944    
;;;945      hTimer = NULL;
00000c  2000              MOVS     r0,#0
00000e  9002              STR      r0,[sp,#8]
;;;946    
;;;947      if (!IS_IRQ() && (func != NULL)) {
000010  f7fffffe          BL       __get_IPSR
000014  2800              CMP      r0,#0
000016  d14b              BNE      |L78.176|
000018  2e00              CMP      r6,#0
00001a  d049              BEQ      |L78.176|
;;;948        /* Allocate memory to store callback function and argument */
;;;949        callb = pvPortMalloc (sizeof(TimerCallback_t));
00001c  2008              MOVS     r0,#8
00001e  f7fffffe          BL       pvPortMalloc
000022  4605              MOV      r5,r0
;;;950    
;;;951        if (callb != NULL) {
000024  2d00              CMP      r5,#0
000026  d043              BEQ      |L78.176|
;;;952          callb->func = func;
000028  602e              STR      r6,[r5,#0]
;;;953          callb->arg  = argument;
00002a  f8c5a004          STR      r10,[r5,#4]
;;;954    
;;;955          if (type == osTimerOnce) {
00002e  f1b90f00          CMP      r9,#0
000032  d101              BNE      |L78.56|
;;;956            reload = pdFALSE;
000034  2700              MOVS     r7,#0
000036  e000              B        |L78.58|
                  |L78.56|
;;;957          } else {
;;;958            reload = pdTRUE;
000038  2701              MOVS     r7,#1
                  |L78.58|
;;;959          }
;;;960    
;;;961          mem  = -1;
00003a  f04f38ff          MOV      r8,#0xffffffff
;;;962          name = NULL;
00003e  f04f0b00          MOV      r11,#0
;;;963    
;;;964          if (attr != NULL) {
000042  b194              CBZ      r4,|L78.106|
;;;965            if (attr->name != NULL) {
000044  6820              LDR      r0,[r4,#0]
000046  b108              CBZ      r0,|L78.76|
;;;966              name = attr->name;
000048  f8d4b000          LDR      r11,[r4,#0]
                  |L78.76|
;;;967            }
;;;968    
;;;969            if ((attr->cb_mem != NULL) && (attr->cb_size >= sizeof(StaticTimer_t))) {
00004c  68a0              LDR      r0,[r4,#8]
00004e  b128              CBZ      r0,|L78.92|
000050  68e0              LDR      r0,[r4,#0xc]
000052  282c              CMP      r0,#0x2c
000054  d302              BCC      |L78.92|
;;;970              mem = 1;
000056  f04f0801          MOV      r8,#1
00005a  e008              B        |L78.110|
                  |L78.92|
;;;971            }
;;;972            else {
;;;973              if ((attr->cb_mem == NULL) && (attr->cb_size == 0U)) {
00005c  68a0              LDR      r0,[r4,#8]
00005e  b930              CBNZ     r0,|L78.110|
000060  68e0              LDR      r0,[r4,#0xc]
000062  b920              CBNZ     r0,|L78.110|
;;;974                mem = 0;
000064  f04f0800          MOV      r8,#0
000068  e001              B        |L78.110|
                  |L78.106|
;;;975              }
;;;976            }
;;;977          }
;;;978          else {
;;;979            mem = 0;
00006a  f04f0800          MOV      r8,#0
                  |L78.110|
;;;980          }
;;;981    
;;;982          if (mem == 1) {
00006e  f1b80f01          CMP      r8,#1
000072  d10b              BNE      |L78.140|
;;;983            #if (configSUPPORT_STATIC_ALLOCATION == 1)
;;;984              hTimer = xTimerCreateStatic (name, 1, reload, callb, TimerCallback, (StaticTimer_t *)attr->cb_mem);
000074  4910              LDR      r1,|L78.184|
000076  68a0              LDR      r0,[r4,#8]
000078  462b              MOV      r3,r5
00007a  463a              MOV      r2,r7
00007c  e9cd1000          STRD     r1,r0,[sp,#0]
000080  2101              MOVS     r1,#1
000082  4658              MOV      r0,r11
000084  f7fffffe          BL       xTimerCreateStatic
000088  9002              STR      r0,[sp,#8]
00008a  e00b              B        |L78.164|
                  |L78.140|
;;;985            #endif
;;;986          }
;;;987          else {
;;;988            if (mem == 0) {
00008c  f1b80f00          CMP      r8,#0
000090  d108              BNE      |L78.164|
;;;989              #if (configSUPPORT_DYNAMIC_ALLOCATION == 1)
;;;990                hTimer = xTimerCreate (name, 1, reload, callb, TimerCallback);
000092  4809              LDR      r0,|L78.184|
000094  462b              MOV      r3,r5
000096  463a              MOV      r2,r7
000098  2101              MOVS     r1,#1
00009a  9000              STR      r0,[sp,#0]
00009c  4658              MOV      r0,r11
00009e  f7fffffe          BL       xTimerCreate
0000a2  9002              STR      r0,[sp,#8]
                  |L78.164|
;;;991              #endif
;;;992            }
;;;993          }
;;;994    
;;;995          if ((hTimer == NULL) && (callb != NULL)) {
0000a4  9802              LDR      r0,[sp,#8]
0000a6  b918              CBNZ     r0,|L78.176|
0000a8  b115              CBZ      r5,|L78.176|
;;;996            vPortFree (callb);
0000aa  4628              MOV      r0,r5
0000ac  f7fffffe          BL       vPortFree
                  |L78.176|
;;;997          }
;;;998        }
;;;999      }
;;;1000   
;;;1001     return ((osTimerId_t)hTimer);
0000b0  9802              LDR      r0,[sp,#8]
;;;1002   }
0000b2  e8bd8ffe          POP      {r1-r11,pc}
;;;1003   
                          ENDP

0000b6  0000              DCW      0x0000
                  |L78.184|
                          DCD      TimerCallback

                          AREA ||i.osTimerStart||, CODE, READONLY, ALIGN=1

                  osTimerStart PROC
;;;1016   
;;;1017   osStatus_t osTimerStart (osTimerId_t timer_id, uint32_t ticks) {
000000  b5f8              PUSH     {r3-r7,lr}
000002  4605              MOV      r5,r0
000004  460e              MOV      r6,r1
;;;1018     TimerHandle_t hTimer = (TimerHandle_t)timer_id;
000006  462f              MOV      r7,r5
;;;1019     osStatus_t stat;
;;;1020   
;;;1021     if (IS_IRQ()) {
000008  f7fffffe          BL       __get_IPSR
00000c  b110              CBZ      r0,|L79.20|
;;;1022       stat = osErrorISR;
00000e  f06f0405          MVN      r4,#5
000012  e011              B        |L79.56|
                  |L79.20|
;;;1023     }
;;;1024     else if (hTimer == NULL) {
000014  b917              CBNZ     r7,|L79.28|
;;;1025       stat = osErrorParameter;
000016  f06f0403          MVN      r4,#3
00001a  e00d              B        |L79.56|
                  |L79.28|
;;;1026     }
;;;1027     else {
;;;1028       if (xTimerChangePeriod (hTimer, ticks, 0) == pdPASS) {
00001c  2000              MOVS     r0,#0
00001e  4603              MOV      r3,r0
000020  4632              MOV      r2,r6
000022  2104              MOVS     r1,#4
000024  9000              STR      r0,[sp,#0]
000026  4638              MOV      r0,r7
000028  f7fffffe          BL       xTimerGenericCommand
00002c  2801              CMP      r0,#1
00002e  d101              BNE      |L79.52|
;;;1029         stat = osOK;
000030  2400              MOVS     r4,#0
000032  e001              B        |L79.56|
                  |L79.52|
;;;1030       } else {
;;;1031         stat = osErrorResource;
000034  f06f0402          MVN      r4,#2
                  |L79.56|
;;;1032       }
;;;1033     }
;;;1034   
;;;1035     return (stat);
000038  4620              MOV      r0,r4
;;;1036   }
00003a  bdf8              POP      {r3-r7,pc}
;;;1037   
                          ENDP


                          AREA ||i.osTimerStop||, CODE, READONLY, ALIGN=1

                  osTimerStop PROC
;;;1037   
;;;1038   osStatus_t osTimerStop (osTimerId_t timer_id) {
000000  b5f8              PUSH     {r3-r7,lr}
000002  4605              MOV      r5,r0
;;;1039     TimerHandle_t hTimer = (TimerHandle_t)timer_id;
000004  462e              MOV      r6,r5
;;;1040     osStatus_t stat;
;;;1041   
;;;1042     if (IS_IRQ()) {
000006  f7fffffe          BL       __get_IPSR
00000a  b110              CBZ      r0,|L80.18|
;;;1043       stat = osErrorISR;
00000c  f06f0405          MVN      r4,#5
000010  e018              B        |L80.68|
                  |L80.18|
;;;1044     }
;;;1045     else if (hTimer == NULL) {
000012  b916              CBNZ     r6,|L80.26|
;;;1046       stat = osErrorParameter;
000014  f06f0403          MVN      r4,#3
000018  e014              B        |L80.68|
                  |L80.26|
;;;1047     }
;;;1048     else {
;;;1049       if (xTimerIsTimerActive (hTimer) == pdFALSE) {
00001a  4630              MOV      r0,r6
00001c  f7fffffe          BL       xTimerIsTimerActive
000020  b910              CBNZ     r0,|L80.40|
;;;1050         stat = osErrorResource;
000022  f06f0402          MVN      r4,#2
000026  e00d              B        |L80.68|
                  |L80.40|
;;;1051       }
;;;1052       else {
;;;1053         if (xTimerStop (hTimer, 0) == pdPASS) {
000028  2000              MOVS     r0,#0
00002a  4603              MOV      r3,r0
00002c  4602              MOV      r2,r0
00002e  2103              MOVS     r1,#3
000030  9000              STR      r0,[sp,#0]
000032  4630              MOV      r0,r6
000034  f7fffffe          BL       xTimerGenericCommand
000038  2801              CMP      r0,#1
00003a  d101              BNE      |L80.64|
;;;1054           stat = osOK;
00003c  2400              MOVS     r4,#0
00003e  e001              B        |L80.68|
                  |L80.64|
;;;1055         } else {
;;;1056           stat = osError;
000040  f04f34ff          MOV      r4,#0xffffffff
                  |L80.68|
;;;1057         }
;;;1058       }
;;;1059     }
;;;1060   
;;;1061     return (stat);
000044  4620              MOV      r0,r4
;;;1062   }
000046  bdf8              POP      {r3-r7,pc}
;;;1063   
                          ENDP


                          AREA ||i.vApplicationGetIdleTaskMemory||, CODE, READONLY, ALIGN=2

                  vApplicationGetIdleTaskMemory PROC
;;;2457   */
;;;2458   __WEAK void vApplicationGetIdleTaskMemory (StaticTask_t **ppxIdleTaskTCBBuffer, StackType_t **ppxIdleTaskStackBuffer, uint32_t *pulIdleTaskStackSize) {
000000  4b03              LDR      r3,|L81.16|
;;;2459     /* Idle task control block and stack */
;;;2460     static StaticTask_t Idle_TCB;
;;;2461     static StackType_t  Idle_Stack[configMINIMAL_STACK_SIZE];
;;;2462   
;;;2463     *ppxIdleTaskTCBBuffer   = &Idle_TCB;
000002  6003              STR      r3,[r0,#0]
;;;2464     *ppxIdleTaskStackBuffer = &Idle_Stack[0];
000004  4b03              LDR      r3,|L81.20|
000006  600b              STR      r3,[r1,#0]
;;;2465     *pulIdleTaskStackSize   = (uint32_t)configMINIMAL_STACK_SIZE;
000008  2380              MOVS     r3,#0x80
00000a  6013              STR      r3,[r2,#0]
;;;2466   }
00000c  4770              BX       lr
;;;2467   
                          ENDP

00000e  0000              DCW      0x0000
                  |L81.16|
                          DCD      Idle_TCB
                  |L81.20|
                          DCD      Idle_Stack

                          AREA ||i.vApplicationGetTimerTaskMemory||, CODE, READONLY, ALIGN=2

                  vApplicationGetTimerTaskMemory PROC
;;;2471   */
;;;2472   __WEAK void vApplicationGetTimerTaskMemory (StaticTask_t **ppxTimerTaskTCBBuffer, StackType_t **ppxTimerTaskStackBuffer, uint32_t *pulTimerTaskStackSize) {
000000  4b03              LDR      r3,|L82.16|
;;;2473     /* Timer task control block and stack */
;;;2474     static StaticTask_t Timer_TCB;
;;;2475     static StackType_t  Timer_Stack[configTIMER_TASK_STACK_DEPTH];
;;;2476   
;;;2477     *ppxTimerTaskTCBBuffer   = &Timer_TCB;
000002  6003              STR      r3,[r0,#0]
;;;2478     *ppxTimerTaskStackBuffer = &Timer_Stack[0];
000004  4b03              LDR      r3,|L82.20|
000006  600b              STR      r3,[r1,#0]
;;;2479     *pulTimerTaskStackSize   = (uint32_t)configTIMER_TASK_STACK_DEPTH;
000008  f44f7380          MOV      r3,#0x100
00000c  6013              STR      r3,[r2,#0]
;;;2480   }
00000e  4770              BX       lr
;;;2481   #endif
                          ENDP

                  |L82.16|
                          DCD      Timer_TCB
                  |L82.20|
                          DCD      Timer_Stack

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  Idle_TCB
                          %        92
                  Idle_Stack
                          %        512
                  Timer_TCB
                          %        92
                  Timer_Stack
                          %        1024

                          AREA ||.data||, DATA, ALIGN=2

                  KernelState
                          DCD      0x00000000

;*** Start embedded assembler ***

#line 1 "../Middlewares/Third_Party/FreeRTOS/Source/CMSIS_RTOS_V2/cmsis_os2.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___11_cmsis_os2_c_b672aa62____REV16|
#line 208 "../Drivers/CMSIS/Include/cmsis_armcc.h"
|__asm___11_cmsis_os2_c_b672aa62____REV16| PROC
#line 209

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___11_cmsis_os2_c_b672aa62____REVSH|
#line 223
|__asm___11_cmsis_os2_c_b672aa62____REVSH| PROC
#line 224

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___11_cmsis_os2_c_b672aa62____RRX|
#line 410
|__asm___11_cmsis_os2_c_b672aa62____RRX| PROC
#line 411

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
