; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: ArmCC [4d365d]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\06_project\stm32f4xx_hal.o --asm_dir=.\06_Project\temp\ --list_dir=.\06_Project\temp\ --depend=.\06_project\stm32f4xx_hal.d --cpu=Cortex-M4.fp.sp --apcs=interwork -O0 --diag_suppress=9931 -I../Core/Inc -I../Drivers/STM32F4xx_HAL_Driver/Inc -I../Drivers/STM32F4xx_HAL_Driver/Inc/Legacy -I../Drivers/CMSIS/Device/ST/STM32F4xx/Include -I../Drivers/CMSIS/Include -I../APP/Key/Inc -I../APP/Led/Inc -I../Middlewares/Third_Party/FreeRTOS/Source/include -I../Middlewares/Third_Party/FreeRTOS/Source/CMSIS_RTOS_V2 -I../Middlewares/Third_Party/FreeRTOS/Source/portable/RVDS/ARM_CM4F -I.\RTE\_06_Project -IF:\software\ARM_ENV\Keil\Packs\ARM\CMSIS\5.9.0\CMSIS\Core\Include -IF:\software\ARM_ENV\Keil\Packs\Keil\STM32F4xx_DFP\2.17.1\Drivers\CMSIS\Device\ST\STM32F4xx\Include -D__MICROLIB -D__UVISION_VERSION=538 -D_RTE_ -DSTM32F411xE -D_RTE_ -DUSE_HAL_DRIVER -DSTM32F411xE --omf_browse=.\06_project\stm32f4xx_hal.crf ../Drivers/STM32F4xx_HAL_Driver/Src/stm32f4xx_hal.c]
                          THUMB

                          AREA ||i.HAL_DBGMCU_DisableDBGSleepMode||, CODE, READONLY, ALIGN=2

                  HAL_DBGMCU_DisableDBGSleepMode PROC
;;;477      */
;;;478    void HAL_DBGMCU_DisableDBGSleepMode(void)
000000  4803              LDR      r0,|L1.16|
;;;479    {
;;;480      CLEAR_BIT(DBGMCU->CR, DBGMCU_CR_DBG_SLEEP);
000002  6840              LDR      r0,[r0,#4]
000004  f0200001          BIC      r0,r0,#1
000008  4901              LDR      r1,|L1.16|
00000a  6048              STR      r0,[r1,#4]
;;;481    }
00000c  4770              BX       lr
;;;482    
                          ENDP

00000e  0000              DCW      0x0000
                  |L1.16|
                          DCD      0xe0042000

                          AREA ||i.HAL_DBGMCU_DisableDBGStandbyMode||, CODE, READONLY, ALIGN=2

                  HAL_DBGMCU_DisableDBGStandbyMode PROC
;;;513      */
;;;514    void HAL_DBGMCU_DisableDBGStandbyMode(void)
000000  4803              LDR      r0,|L2.16|
;;;515    {
;;;516      CLEAR_BIT(DBGMCU->CR, DBGMCU_CR_DBG_STANDBY);
000002  6840              LDR      r0,[r0,#4]
000004  f0200004          BIC      r0,r0,#4
000008  4901              LDR      r1,|L2.16|
00000a  6048              STR      r0,[r1,#4]
;;;517    }
00000c  4770              BX       lr
;;;518    
                          ENDP

00000e  0000              DCW      0x0000
                  |L2.16|
                          DCD      0xe0042000

                          AREA ||i.HAL_DBGMCU_DisableDBGStopMode||, CODE, READONLY, ALIGN=2

                  HAL_DBGMCU_DisableDBGStopMode PROC
;;;495      */
;;;496    void HAL_DBGMCU_DisableDBGStopMode(void)
000000  4803              LDR      r0,|L3.16|
;;;497    {
;;;498      CLEAR_BIT(DBGMCU->CR, DBGMCU_CR_DBG_STOP);
000002  6840              LDR      r0,[r0,#4]
000004  f0200002          BIC      r0,r0,#2
000008  4901              LDR      r1,|L3.16|
00000a  6048              STR      r0,[r1,#4]
;;;499    }
00000c  4770              BX       lr
;;;500    
                          ENDP

00000e  0000              DCW      0x0000
                  |L3.16|
                          DCD      0xe0042000

                          AREA ||i.HAL_DBGMCU_EnableDBGSleepMode||, CODE, READONLY, ALIGN=2

                  HAL_DBGMCU_EnableDBGSleepMode PROC
;;;468      */
;;;469    void HAL_DBGMCU_EnableDBGSleepMode(void)
000000  4803              LDR      r0,|L4.16|
;;;470    {
;;;471      SET_BIT(DBGMCU->CR, DBGMCU_CR_DBG_SLEEP);
000002  6840              LDR      r0,[r0,#4]
000004  f0400001          ORR      r0,r0,#1
000008  4901              LDR      r1,|L4.16|
00000a  6048              STR      r0,[r1,#4]
;;;472    }
00000c  4770              BX       lr
;;;473    
                          ENDP

00000e  0000              DCW      0x0000
                  |L4.16|
                          DCD      0xe0042000

                          AREA ||i.HAL_DBGMCU_EnableDBGStandbyMode||, CODE, READONLY, ALIGN=2

                  HAL_DBGMCU_EnableDBGStandbyMode PROC
;;;504      */
;;;505    void HAL_DBGMCU_EnableDBGStandbyMode(void)
000000  4803              LDR      r0,|L5.16|
;;;506    {
;;;507      SET_BIT(DBGMCU->CR, DBGMCU_CR_DBG_STANDBY);
000002  6840              LDR      r0,[r0,#4]
000004  f0400004          ORR      r0,r0,#4
000008  4901              LDR      r1,|L5.16|
00000a  6048              STR      r0,[r1,#4]
;;;508    }
00000c  4770              BX       lr
;;;509    
                          ENDP

00000e  0000              DCW      0x0000
                  |L5.16|
                          DCD      0xe0042000

                          AREA ||i.HAL_DBGMCU_EnableDBGStopMode||, CODE, READONLY, ALIGN=2

                  HAL_DBGMCU_EnableDBGStopMode PROC
;;;486      */
;;;487    void HAL_DBGMCU_EnableDBGStopMode(void)
000000  4803              LDR      r0,|L6.16|
;;;488    {
;;;489      SET_BIT(DBGMCU->CR, DBGMCU_CR_DBG_STOP);
000002  6840              LDR      r0,[r0,#4]
000004  f0400002          ORR      r0,r0,#2
000008  4901              LDR      r1,|L6.16|
00000a  6048              STR      r0,[r1,#4]
;;;490    }
00000c  4770              BX       lr
;;;491    
                          ENDP

00000e  0000              DCW      0x0000
                  |L6.16|
                          DCD      0xe0042000

                          AREA ||i.HAL_DeInit||, CODE, READONLY, ALIGN=2

                  HAL_DeInit PROC
;;;189      */
;;;190    HAL_StatusTypeDef HAL_DeInit(void)
000000  b510              PUSH     {r4,lr}
;;;191    {
;;;192      /* Reset of all peripherals */
;;;193      __HAL_RCC_APB1_FORCE_RESET();
000002  480f              LDR      r0,|L7.64|
000004  490f              LDR      r1,|L7.68|
000006  6008              STR      r0,[r1,#0]
;;;194      __HAL_RCC_APB1_RELEASE_RESET();
000008  2000              MOVS     r0,#0
00000a  6008              STR      r0,[r1,#0]
;;;195    
;;;196      __HAL_RCC_APB2_FORCE_RESET();
00000c  480e              LDR      r0,|L7.72|
00000e  1d09              ADDS     r1,r1,#4
000010  6008              STR      r0,[r1,#0]
;;;197      __HAL_RCC_APB2_RELEASE_RESET();
000012  2000              MOVS     r0,#0
000014  6008              STR      r0,[r1,#0]
;;;198    
;;;199      __HAL_RCC_AHB1_FORCE_RESET();
000016  480d              LDR      r0,|L7.76|
000018  490a              LDR      r1,|L7.68|
00001a  3910              SUBS     r1,r1,#0x10
00001c  6008              STR      r0,[r1,#0]
;;;200      __HAL_RCC_AHB1_RELEASE_RESET();
00001e  2000              MOVS     r0,#0
000020  6008              STR      r0,[r1,#0]
;;;201    
;;;202      __HAL_RCC_AHB2_FORCE_RESET();
000022  2080              MOVS     r0,#0x80
000024  1d09              ADDS     r1,r1,#4
000026  6008              STR      r0,[r1,#0]
;;;203      __HAL_RCC_AHB2_RELEASE_RESET();
000028  2000              MOVS     r0,#0
00002a  6008              STR      r0,[r1,#0]
;;;204    
;;;205      __HAL_RCC_AHB3_FORCE_RESET();
00002c  1e40              SUBS     r0,r0,#1
00002e  1d09              ADDS     r1,r1,#4
000030  6008              STR      r0,[r1,#0]
;;;206      __HAL_RCC_AHB3_RELEASE_RESET();
000032  2000              MOVS     r0,#0
000034  6008              STR      r0,[r1,#0]
;;;207    
;;;208      /* De-Init the low level hardware */
;;;209      HAL_MspDeInit();
000036  f7fffffe          BL       HAL_MspDeInit
;;;210        
;;;211      /* Return function status */
;;;212      return HAL_OK;
00003a  2000              MOVS     r0,#0
;;;213    }
00003c  bd10              POP      {r4,pc}
;;;214    
                          ENDP

00003e  0000              DCW      0x0000
                  |L7.64|
                          DCD      0x10e2c80f
                  |L7.68|
                          DCD      0x40023820
                  |L7.72|
                          DCD      0x00177931
                  |L7.76|
                          DCD      0x0060109f

                          AREA ||i.HAL_Delay||, CODE, READONLY, ALIGN=2

                  HAL_Delay PROC
;;;389      */
;;;390    __weak void HAL_Delay(uint32_t Delay)
000000  b570              PUSH     {r4-r6,lr}
;;;391    {
000002  4604              MOV      r4,r0
;;;392      uint32_t tickstart = HAL_GetTick();
000004  f7fffffe          BL       HAL_GetTick
000008  4606              MOV      r6,r0
;;;393      uint32_t wait = Delay;
00000a  4625              MOV      r5,r4
;;;394    
;;;395      /* Add a freq to guarantee minimum wait */
;;;396      if (wait < HAL_MAX_DELAY)
00000c  1c68              ADDS     r0,r5,#1
00000e  b110              CBZ      r0,|L8.22|
;;;397      {
;;;398        wait += (uint32_t)(uwTickFreq);
000010  4804              LDR      r0,|L8.36|
000012  7800              LDRB     r0,[r0,#0]  ; uwTickFreq
000014  4405              ADD      r5,r5,r0
                  |L8.22|
;;;399      }
;;;400    
;;;401      while((HAL_GetTick() - tickstart) < wait)
000016  bf00              NOP      
                  |L8.24|
000018  f7fffffe          BL       HAL_GetTick
00001c  1b80              SUBS     r0,r0,r6
00001e  42a8              CMP      r0,r5
000020  d3fa              BCC      |L8.24|
;;;402      {
;;;403      }
;;;404    }
000022  bd70              POP      {r4-r6,pc}
;;;405    
                          ENDP

                  |L8.36|
                          DCD      uwTickFreq

                          AREA ||i.HAL_DisableCompensationCell||, CODE, READONLY, ALIGN=2

                  HAL_DisableCompensationCell PROC
;;;535      */
;;;536    void HAL_DisableCompensationCell(void)
000000  2000              MOVS     r0,#0
;;;537    {
;;;538      *(__IO uint32_t *)CMPCR_CMP_PD_BB = (uint32_t)DISABLE;
000002  4901              LDR      r1,|L9.8|
000004  6008              STR      r0,[r1,#0]
;;;539    }
000006  4770              BX       lr
;;;540    
                          ENDP

                  |L9.8|
                          DCD      0x42270400

                          AREA ||i.HAL_EnableCompensationCell||, CODE, READONLY, ALIGN=2

                  HAL_EnableCompensationCell PROC
;;;524      */
;;;525    void HAL_EnableCompensationCell(void)
000000  2001              MOVS     r0,#1
;;;526    {
;;;527      *(__IO uint32_t *)CMPCR_CMP_PD_BB = (uint32_t)ENABLE;
000002  4901              LDR      r1,|L10.8|
000004  6008              STR      r0,[r1,#0]
;;;528    }
000006  4770              BX       lr
;;;529    
                          ENDP

                  |L10.8|
                          DCD      0x42270400

                          AREA ||i.HAL_GetDEVID||, CODE, READONLY, ALIGN=2

                  HAL_GetDEVID PROC
;;;459      */
;;;460    uint32_t HAL_GetDEVID(void)
000000  4802              LDR      r0,|L11.12|
;;;461    {
;;;462      return((DBGMCU->IDCODE) & IDCODE_DEVID_MASK);
000002  6800              LDR      r0,[r0,#0]
000004  f3c0000b          UBFX     r0,r0,#0,#12
;;;463    }
000008  4770              BX       lr
;;;464    
                          ENDP

00000a  0000              DCW      0x0000
                  |L11.12|
                          DCD      0xe0042000

                          AREA ||i.HAL_GetHalVersion||, CODE, READONLY, ALIGN=2

                  HAL_GetHalVersion PROC
;;;441      */
;;;442    uint32_t HAL_GetHalVersion(void)
000000  4800              LDR      r0,|L12.4|
;;;443    {
;;;444      return __STM32F4xx_HAL_VERSION;
;;;445    }
000002  4770              BX       lr
;;;446    
                          ENDP

                  |L12.4|
                          DCD      0x01080200

                          AREA ||i.HAL_GetREVID||, CODE, READONLY, ALIGN=2

                  HAL_GetREVID PROC
;;;450      */
;;;451    uint32_t HAL_GetREVID(void)
000000  4801              LDR      r0,|L13.8|
;;;452    {
;;;453      return((DBGMCU->IDCODE) >> 16U);
000002  6800              LDR      r0,[r0,#0]
000004  0c00              LSRS     r0,r0,#16
;;;454    }
000006  4770              BX       lr
;;;455    
                          ENDP

                  |L13.8|
                          DCD      0xe0042000

                          AREA ||i.HAL_GetTick||, CODE, READONLY, ALIGN=2

                  HAL_GetTick PROC
;;;322      */
;;;323    __weak uint32_t HAL_GetTick(void)
000000  4801              LDR      r0,|L14.8|
;;;324    {
;;;325      return uwTick;
000002  6800              LDR      r0,[r0,#0]  ; uwTick
;;;326    }
000004  4770              BX       lr
;;;327    
                          ENDP

000006  0000              DCW      0x0000
                  |L14.8|
                          DCD      uwTick

                          AREA ||i.HAL_GetTickFreq||, CODE, READONLY, ALIGN=2

                  HAL_GetTickFreq PROC
;;;373      */
;;;374    HAL_TickFreqTypeDef HAL_GetTickFreq(void)
000000  4801              LDR      r0,|L15.8|
;;;375    {
;;;376      return uwTickFreq;
000002  7800              LDRB     r0,[r0,#0]  ; uwTickFreq
;;;377    }
000004  4770              BX       lr
;;;378    
                          ENDP

000006  0000              DCW      0x0000
                  |L15.8|
                          DCD      uwTickFreq

                          AREA ||i.HAL_GetTickPrio||, CODE, READONLY, ALIGN=2

                  HAL_GetTickPrio PROC
;;;331      */
;;;332    uint32_t HAL_GetTickPrio(void)
000000  4801              LDR      r0,|L16.8|
;;;333    {
;;;334      return uwTickPrio;
000002  6800              LDR      r0,[r0,#0]  ; uwTickPrio
;;;335    }
000004  4770              BX       lr
;;;336    
                          ENDP

000006  0000              DCW      0x0000
                  |L16.8|
                          DCD      uwTickPrio

                          AREA ||i.HAL_GetUIDw0||, CODE, READONLY, ALIGN=2

                  HAL_GetUIDw0 PROC
;;;544      */
;;;545    uint32_t HAL_GetUIDw0(void)
000000  4801              LDR      r0,|L17.8|
;;;546    {
;;;547      return (READ_REG(*((uint32_t *)UID_BASE)));
000002  6800              LDR      r0,[r0,#0]
;;;548    }
000004  4770              BX       lr
;;;549    
                          ENDP

000006  0000              DCW      0x0000
                  |L17.8|
                          DCD      0x1fff7a10

                          AREA ||i.HAL_GetUIDw1||, CODE, READONLY, ALIGN=2

                  HAL_GetUIDw1 PROC
;;;553      */
;;;554    uint32_t HAL_GetUIDw1(void)
000000  4801              LDR      r0,|L18.8|
;;;555    {
;;;556      return (READ_REG(*((uint32_t *)(UID_BASE + 4U))));
000002  6800              LDR      r0,[r0,#0]
;;;557    }
000004  4770              BX       lr
;;;558    
                          ENDP

000006  0000              DCW      0x0000
                  |L18.8|
                          DCD      0x1fff7a14

                          AREA ||i.HAL_GetUIDw2||, CODE, READONLY, ALIGN=2

                  HAL_GetUIDw2 PROC
;;;562      */
;;;563    uint32_t HAL_GetUIDw2(void)
000000  4801              LDR      r0,|L19.8|
;;;564    {
;;;565      return (READ_REG(*((uint32_t *)(UID_BASE + 8U))));
000002  6800              LDR      r0,[r0,#0]
;;;566    }
000004  4770              BX       lr
;;;567    
                          ENDP

000006  0000              DCW      0x0000
                  |L19.8|
                          DCD      0x1fff7a18

                          AREA ||i.HAL_IncTick||, CODE, READONLY, ALIGN=2

                  HAL_IncTick PROC
;;;311      */
;;;312    __weak void HAL_IncTick(void)
000000  4803              LDR      r0,|L20.16|
;;;313    {
;;;314      uwTick += uwTickFreq;
000002  6800              LDR      r0,[r0,#0]  ; uwTick
000004  4903              LDR      r1,|L20.20|
000006  7809              LDRB     r1,[r1,#0]  ; uwTickFreq
000008  4408              ADD      r0,r0,r1
00000a  4901              LDR      r1,|L20.16|
00000c  6008              STR      r0,[r1,#0]  ; uwTick
;;;315    }
00000e  4770              BX       lr
;;;316    
                          ENDP

                  |L20.16|
                          DCD      uwTick
                  |L20.20|
                          DCD      uwTickFreq

                          AREA ||i.HAL_Init||, CODE, READONLY, ALIGN=2

                  HAL_Init PROC
;;;156      */
;;;157    HAL_StatusTypeDef HAL_Init(void)
000000  b510              PUSH     {r4,lr}
;;;158    {
;;;159      /* Configure Flash prefetch, Instruction cache, Data cache */ 
;;;160    #if (INSTRUCTION_CACHE_ENABLE != 0U)
;;;161      __HAL_FLASH_INSTRUCTION_CACHE_ENABLE();
000002  480d              LDR      r0,|L21.56|
000004  6800              LDR      r0,[r0,#0]
000006  f4407000          ORR      r0,r0,#0x200
00000a  490b              LDR      r1,|L21.56|
00000c  6008              STR      r0,[r1,#0]
;;;162    #endif /* INSTRUCTION_CACHE_ENABLE */
;;;163    
;;;164    #if (DATA_CACHE_ENABLE != 0U)
;;;165      __HAL_FLASH_DATA_CACHE_ENABLE();
00000e  4608              MOV      r0,r1
000010  6800              LDR      r0,[r0,#0]
000012  f4406080          ORR      r0,r0,#0x400
000016  6008              STR      r0,[r1,#0]
;;;166    #endif /* DATA_CACHE_ENABLE */
;;;167    
;;;168    #if (PREFETCH_ENABLE != 0U)
;;;169      __HAL_FLASH_PREFETCH_BUFFER_ENABLE();
000018  4608              MOV      r0,r1
00001a  6800              LDR      r0,[r0,#0]
00001c  f4407080          ORR      r0,r0,#0x100
000020  6008              STR      r0,[r1,#0]
;;;170    #endif /* PREFETCH_ENABLE */
;;;171    
;;;172      /* Set Interrupt Group Priority */
;;;173      HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_4);
000022  2003              MOVS     r0,#3
000024  f7fffffe          BL       HAL_NVIC_SetPriorityGrouping
;;;174    
;;;175      /* Use systick as time base source and configure 1ms tick (default clock after Reset is HSI) */
;;;176      HAL_InitTick(TICK_INT_PRIORITY);
000028  200f              MOVS     r0,#0xf
00002a  f7fffffe          BL       HAL_InitTick
;;;177    
;;;178      /* Init the low level hardware */
;;;179      HAL_MspInit();
00002e  f7fffffe          BL       HAL_MspInit
;;;180    
;;;181      /* Return function status */
;;;182      return HAL_OK;
000032  2000              MOVS     r0,#0
;;;183    }
000034  bd10              POP      {r4,pc}
;;;184    
                          ENDP

000036  0000              DCW      0x0000
                  |L21.56|
                          DCD      0x40023c00

                          AREA ||i.HAL_InitTick||, CODE, READONLY, ALIGN=2

                  HAL_InitTick PROC
;;;252      */
;;;253    __weak HAL_StatusTypeDef HAL_InitTick(uint32_t TickPriority)
000000  b570              PUSH     {r4-r6,lr}
;;;254    {
000002  4604              MOV      r4,r0
;;;255      /* Configure the SysTick to have interrupt in 1ms time basis*/
;;;256      if (HAL_SYSTICK_Config(SystemCoreClock / (1000U / uwTickFreq)) > 0U)
000004  480e              LDR      r0,|L22.64|
000006  7800              LDRB     r0,[r0,#0]  ; uwTickFreq
000008  f44f717a          MOV      r1,#0x3e8
00000c  fbb1f0f0          UDIV     r0,r1,r0
000010  490c              LDR      r1,|L22.68|
000012  6809              LDR      r1,[r1,#0]  ; SystemCoreClock
000014  fbb1f5f0          UDIV     r5,r1,r0
000018  4628              MOV      r0,r5
00001a  f7fffffe          BL       HAL_SYSTICK_Config
00001e  b108              CBZ      r0,|L22.36|
;;;257      {
;;;258        return HAL_ERROR;
000020  2001              MOVS     r0,#1
                  |L22.34|
;;;259      }
;;;260    
;;;261      /* Configure the SysTick IRQ priority */
;;;262      if (TickPriority < (1UL << __NVIC_PRIO_BITS))
;;;263      {
;;;264        HAL_NVIC_SetPriority(SysTick_IRQn, TickPriority, 0U);
;;;265        uwTickPrio = TickPriority;
;;;266      }
;;;267      else
;;;268      {
;;;269        return HAL_ERROR;
;;;270      }
;;;271    
;;;272      /* Return function status */
;;;273      return HAL_OK;
;;;274    }
000022  bd70              POP      {r4-r6,pc}
                  |L22.36|
000024  2c10              CMP      r4,#0x10              ;262
000026  d207              BCS      |L22.56|
000028  2200              MOVS     r2,#0                 ;264
00002a  4621              MOV      r1,r4                 ;264
00002c  1e50              SUBS     r0,r2,#1              ;264
00002e  f7fffffe          BL       HAL_NVIC_SetPriority
000032  4805              LDR      r0,|L22.72|
000034  6004              STR      r4,[r0,#0]            ;265  ; uwTickPrio
000036  e001              B        |L22.60|
                  |L22.56|
000038  2001              MOVS     r0,#1                 ;269
00003a  e7f2              B        |L22.34|
                  |L22.60|
00003c  2000              MOVS     r0,#0                 ;273
00003e  e7f0              B        |L22.34|
;;;275    
                          ENDP

                  |L22.64|
                          DCD      uwTickFreq
                  |L22.68|
                          DCD      SystemCoreClock
                  |L22.72|
                          DCD      uwTickPrio

                          AREA ||i.HAL_MspDeInit||, CODE, READONLY, ALIGN=1

                  HAL_MspDeInit PROC
;;;229      */
;;;230    __weak void HAL_MspDeInit(void)
000000  4770              BX       lr
;;;231    {
;;;232      /* NOTE : This function should not be modified, when the callback is needed,
;;;233                the HAL_MspDeInit could be implemented in the user file
;;;234       */ 
;;;235    }
;;;236    
                          ENDP


                          AREA ||i.HAL_MspInit||, CODE, READONLY, ALIGN=1

                  HAL_MspInit PROC
;;;218      */
;;;219    __weak void HAL_MspInit(void)
000000  4770              BX       lr
;;;220    {
;;;221      /* NOTE : This function should not be modified, when the callback is needed,
;;;222                the HAL_MspInit could be implemented in the user file
;;;223       */
;;;224    }
;;;225    
                          ENDP


                          AREA ||i.HAL_ResumeTick||, CODE, READONLY, ALIGN=1

                  HAL_ResumeTick PROC
;;;431      */
;;;432    __weak void HAL_ResumeTick(void)
000000  f04f20e0          MOV      r0,#0xe000e000
;;;433    {
;;;434      /* Enable SysTick Interrupt */
;;;435      SysTick->CTRL  |= SysTick_CTRL_TICKINT_Msk;
000004  6900              LDR      r0,[r0,#0x10]
000006  f0400002          ORR      r0,r0,#2
00000a  f04f21e0          MOV      r1,#0xe000e000
00000e  6108              STR      r0,[r1,#0x10]
;;;436    }
000010  4770              BX       lr
;;;437    
                          ENDP


                          AREA ||i.HAL_SetTickFreq||, CODE, READONLY, ALIGN=2

                  HAL_SetTickFreq PROC
;;;340      */
;;;341    HAL_StatusTypeDef HAL_SetTickFreq(HAL_TickFreqTypeDef Freq)
000000  b570              PUSH     {r4-r6,lr}
;;;342    {
000002  4604              MOV      r4,r0
;;;343      HAL_StatusTypeDef status  = HAL_OK;
000004  2500              MOVS     r5,#0
;;;344      HAL_TickFreqTypeDef prevTickFreq;
;;;345    
;;;346      assert_param(IS_TICKFREQ(Freq));
;;;347    
;;;348      if (uwTickFreq != Freq)
000006  4808              LDR      r0,|L26.40|
000008  7800              LDRB     r0,[r0,#0]  ; uwTickFreq
00000a  42a0              CMP      r0,r4
00000c  d00a              BEQ      |L26.36|
;;;349      {
;;;350        /* Back up uwTickFreq frequency */
;;;351        prevTickFreq = uwTickFreq;
00000e  4806              LDR      r0,|L26.40|
000010  7806              LDRB     r6,[r0,#0]  ; uwTickFreq
;;;352    
;;;353        /* Update uwTickFreq global variable used by HAL_InitTick() */
;;;354        uwTickFreq = Freq;
000012  7004              STRB     r4,[r0,#0]
;;;355    
;;;356        /* Apply the new tick Freq  */
;;;357        status = HAL_InitTick(uwTickPrio);
000014  4805              LDR      r0,|L26.44|
000016  6800              LDR      r0,[r0,#0]  ; uwTickPrio
000018  f7fffffe          BL       HAL_InitTick
00001c  4605              MOV      r5,r0
;;;358    
;;;359        if (status != HAL_OK)
00001e  b10d              CBZ      r5,|L26.36|
;;;360        {
;;;361          /* Restore previous tick frequency */
;;;362          uwTickFreq = prevTickFreq;
000020  4801              LDR      r0,|L26.40|
000022  7006              STRB     r6,[r0,#0]
                  |L26.36|
;;;363        }
;;;364      }
;;;365    
;;;366      return status;
000024  4628              MOV      r0,r5
;;;367    }
000026  bd70              POP      {r4-r6,pc}
;;;368    
                          ENDP

                  |L26.40|
                          DCD      uwTickFreq
                  |L26.44|
                          DCD      uwTickPrio

                          AREA ||i.HAL_SuspendTick||, CODE, READONLY, ALIGN=1

                  HAL_SuspendTick PROC
;;;415      */
;;;416    __weak void HAL_SuspendTick(void)
000000  f04f20e0          MOV      r0,#0xe000e000
;;;417    {
;;;418      /* Disable SysTick Interrupt */
;;;419      SysTick->CTRL &= ~SysTick_CTRL_TICKINT_Msk;
000004  6900              LDR      r0,[r0,#0x10]
000006  f0200002          BIC      r0,r0,#2
00000a  f04f21e0          MOV      r1,#0xe000e000
00000e  6108              STR      r0,[r1,#0x10]
;;;420    }
000010  4770              BX       lr
;;;421    
                          ENDP


                          AREA ||.data||, DATA, ALIGN=2

                  uwTick
                          DCD      0x00000000
                  uwTickPrio
                          DCD      0x00000010
                  uwTickFreq
000008  01                DCB      0x01

;*** Start embedded assembler ***

#line 1 "../Drivers/STM32F4xx_HAL_Driver/Src/stm32f4xx_hal.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___15_stm32f4xx_hal_c_3da258af____REV16|
#line 208 "../Drivers/CMSIS/Include/cmsis_armcc.h"
|__asm___15_stm32f4xx_hal_c_3da258af____REV16| PROC
#line 209

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___15_stm32f4xx_hal_c_3da258af____REVSH|
#line 223
|__asm___15_stm32f4xx_hal_c_3da258af____REVSH| PROC
#line 224

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___15_stm32f4xx_hal_c_3da258af____RRX|
#line 410
|__asm___15_stm32f4xx_hal_c_3da258af____RRX| PROC
#line 411

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
