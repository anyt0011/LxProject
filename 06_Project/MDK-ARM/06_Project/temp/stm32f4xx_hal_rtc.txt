; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: ArmCC [4d365d]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\06_project\stm32f4xx_hal_rtc.o --asm_dir=.\06_Project\temp\ --list_dir=.\06_Project\temp\ --depend=.\06_project\stm32f4xx_hal_rtc.d --cpu=Cortex-M4.fp.sp --apcs=interwork -O0 --diag_suppress=9931 -I../Core/Inc -I../Drivers/STM32F4xx_HAL_Driver/Inc -I../Drivers/STM32F4xx_HAL_Driver/Inc/Legacy -I../Drivers/CMSIS/Device/ST/STM32F4xx/Include -I../Drivers/CMSIS/Include -I../APP/Key/Inc -I../APP/Led/Inc -I../Middlewares/Third_Party/FreeRTOS/Source/include -I../Middlewares/Third_Party/FreeRTOS/Source/CMSIS_RTOS_V2 -I../Middlewares/Third_Party/FreeRTOS/Source/portable/RVDS/ARM_CM4F -I..\BSP\led\adaption -I..\BSP\led\driver -I..\BSP\led\handler -I.\RTE\_06_Project -IF:\software\ARM_ENV\Keil\Packs\ARM\CMSIS\5.9.0\CMSIS\Core\Include -IF:\software\ARM_ENV\Keil\Packs\Keil\STM32F4xx_DFP\2.17.1\Drivers\CMSIS\Device\ST\STM32F4xx\Include -D__MICROLIB -D__UVISION_VERSION=538 -D_RTE_ -DSTM32F411xE -D_RTE_ -DUSE_HAL_DRIVER -DSTM32F411xE --omf_browse=.\06_project\stm32f4xx_hal_rtc.crf ../Drivers/STM32F4xx_HAL_Driver/Src/stm32f4xx_hal_rtc.c]
                          THUMB

                          AREA ||i.HAL_RTC_AlarmAEventCallback||, CODE, READONLY, ALIGN=1

                  HAL_RTC_AlarmAEventCallback PROC
;;;1594     */
;;;1595   __weak void HAL_RTC_AlarmAEventCallback(RTC_HandleTypeDef *hrtc)
000000  4770              BX       lr
;;;1596   {
;;;1597     /* Prevent unused argument(s) compilation warning */
;;;1598     UNUSED(hrtc);
;;;1599   
;;;1600     /* NOTE: This function should not be modified, when the callback is needed,
;;;1601              the HAL_RTC_AlarmAEventCallback could be implemented in the user file
;;;1602      */
;;;1603   }
;;;1604   
                          ENDP


                          AREA ||i.HAL_RTC_AlarmIRQHandler||, CODE, READONLY, ALIGN=2

                  HAL_RTC_AlarmIRQHandler PROC
;;;1543     */
;;;1544   void HAL_RTC_AlarmIRQHandler(RTC_HandleTypeDef *hrtc)
000000  b510              PUSH     {r4,lr}
;;;1545   {
000002  4604              MOV      r4,r0
;;;1546     /* Clear the EXTI's line Flag for RTC Alarm */
;;;1547     __HAL_RTC_ALARM_EXTI_CLEAR_FLAG();
000004  f44f3000          MOV      r0,#0x20000
000008  4917              LDR      r1,|L2.104|
00000a  6008              STR      r0,[r1,#0]
;;;1548   
;;;1549     /* Get the Alarm A interrupt source enable status */
;;;1550     if (__HAL_RTC_ALARM_GET_IT_SOURCE(hrtc, RTC_IT_ALRA) != 0U)
00000c  6820              LDR      r0,[r4,#0]
00000e  6880              LDR      r0,[r0,#8]
000010  f3c03000          UBFX     r0,r0,#12,#1
000014  b178              CBZ      r0,|L2.54|
;;;1551     {
;;;1552       /* Get the pending status of the Alarm A Interrupt */
;;;1553       if (__HAL_RTC_ALARM_GET_FLAG(hrtc, RTC_FLAG_ALRAF) != 0U)
000016  6820              LDR      r0,[r4,#0]
000018  68c0              LDR      r0,[r0,#0xc]
00001a  f3c02000          UBFX     r0,r0,#8,#1
00001e  b150              CBZ      r0,|L2.54|
;;;1554       {
;;;1555         /* Clear the Alarm A interrupt pending bit */
;;;1556         __HAL_RTC_ALARM_CLEAR_FLAG(hrtc, RTC_FLAG_ALRAF);
000020  6820              LDR      r0,[r4,#0]
000022  68c0              LDR      r0,[r0,#0xc]
000024  f0000080          AND      r0,r0,#0x80
000028  f46070c0          ORN      r0,r0,#0x180
00002c  6821              LDR      r1,[r4,#0]
00002e  60c8              STR      r0,[r1,#0xc]
;;;1557   
;;;1558         /* Alarm A callback */
;;;1559   #if (USE_HAL_RTC_REGISTER_CALLBACKS == 1)
;;;1560         hrtc->AlarmAEventCallback(hrtc);
;;;1561   #else
;;;1562         HAL_RTC_AlarmAEventCallback(hrtc);
000030  4620              MOV      r0,r4
000032  f7fffffe          BL       HAL_RTC_AlarmAEventCallback
                  |L2.54|
;;;1563   #endif /* USE_HAL_RTC_REGISTER_CALLBACKS */
;;;1564       }
;;;1565     }
;;;1566   
;;;1567     /* Get the Alarm B interrupt source enable status */
;;;1568     if (__HAL_RTC_ALARM_GET_IT_SOURCE(hrtc, RTC_IT_ALRB) != 0U)
000036  6820              LDR      r0,[r4,#0]
000038  6880              LDR      r0,[r0,#8]
00003a  f3c03040          UBFX     r0,r0,#13,#1
00003e  b178              CBZ      r0,|L2.96|
;;;1569     {
;;;1570       /* Get the pending status of the Alarm B Interrupt */
;;;1571       if (__HAL_RTC_ALARM_GET_FLAG(hrtc, RTC_FLAG_ALRBF) != 0U)
000040  6820              LDR      r0,[r4,#0]
000042  68c0              LDR      r0,[r0,#0xc]
000044  f3c02040          UBFX     r0,r0,#9,#1
000048  b150              CBZ      r0,|L2.96|
;;;1572       {
;;;1573         /* Clear the Alarm B interrupt pending bit */
;;;1574         __HAL_RTC_ALARM_CLEAR_FLAG(hrtc, RTC_FLAG_ALRBF);
00004a  6820              LDR      r0,[r4,#0]
00004c  68c0              LDR      r0,[r0,#0xc]
00004e  f0000080          AND      r0,r0,#0x80
000052  f4607020          ORN      r0,r0,#0x280
000056  6821              LDR      r1,[r4,#0]
000058  60c8              STR      r0,[r1,#0xc]
;;;1575   
;;;1576         /* Alarm B callback */
;;;1577   #if (USE_HAL_RTC_REGISTER_CALLBACKS == 1)
;;;1578         hrtc->AlarmBEventCallback(hrtc);
;;;1579   #else
;;;1580         HAL_RTCEx_AlarmBEventCallback(hrtc);
00005a  4620              MOV      r0,r4
00005c  f7fffffe          BL       HAL_RTCEx_AlarmBEventCallback
                  |L2.96|
;;;1581   #endif /* USE_HAL_RTC_REGISTER_CALLBACKS */
;;;1582       }
;;;1583     }
;;;1584   
;;;1585     /* Change RTC state */
;;;1586     hrtc->State = HAL_RTC_STATE_READY;
000060  2001              MOVS     r0,#1
000062  7760              STRB     r0,[r4,#0x1d]
;;;1587   }
000064  bd10              POP      {r4,pc}
;;;1588   
                          ENDP

000066  0000              DCW      0x0000
                  |L2.104|
                          DCD      0x40013c14

                          AREA ||i.HAL_RTC_DST_Add1Hour||, CODE, READONLY, ALIGN=1

                  HAL_RTC_DST_Add1Hour PROC
;;;1704     */
;;;1705   void HAL_RTC_DST_Add1Hour(RTC_HandleTypeDef *hrtc)
000000  bf00              NOP      
;;;1706   {
;;;1707     __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
000002  21ca              MOVS     r1,#0xca
000004  6802              LDR      r2,[r0,#0]
000006  6251              STR      r1,[r2,#0x24]
000008  2153              MOVS     r1,#0x53
00000a  6802              LDR      r2,[r0,#0]
00000c  6251              STR      r1,[r2,#0x24]
00000e  bf00              NOP      
;;;1708     SET_BIT(hrtc->Instance->CR, RTC_CR_ADD1H);
000010  6801              LDR      r1,[r0,#0]
000012  6889              LDR      r1,[r1,#8]
000014  f4413180          ORR      r1,r1,#0x10000
000018  6802              LDR      r2,[r0,#0]
00001a  6091              STR      r1,[r2,#8]
;;;1709     __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
00001c  bf00              NOP      
00001e  21ff              MOVS     r1,#0xff
000020  6802              LDR      r2,[r0,#0]
000022  6251              STR      r1,[r2,#0x24]
000024  bf00              NOP      
;;;1710   }
000026  4770              BX       lr
;;;1711   
                          ENDP


                          AREA ||i.HAL_RTC_DST_ClearStoreOperation||, CODE, READONLY, ALIGN=1

                  HAL_RTC_DST_ClearStoreOperation PROC
;;;1745     */
;;;1746   void HAL_RTC_DST_ClearStoreOperation(RTC_HandleTypeDef *hrtc)
000000  bf00              NOP      
;;;1747   {
;;;1748     __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
000002  21ca              MOVS     r1,#0xca
000004  6802              LDR      r2,[r0,#0]
000006  6251              STR      r1,[r2,#0x24]
000008  2153              MOVS     r1,#0x53
00000a  6802              LDR      r2,[r0,#0]
00000c  6251              STR      r1,[r2,#0x24]
00000e  bf00              NOP      
;;;1749     CLEAR_BIT(hrtc->Instance->CR, RTC_CR_BKP);
000010  6801              LDR      r1,[r0,#0]
000012  6889              LDR      r1,[r1,#8]
000014  f4212180          BIC      r1,r1,#0x40000
000018  6802              LDR      r2,[r0,#0]
00001a  6091              STR      r1,[r2,#8]
;;;1750     __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
00001c  bf00              NOP      
00001e  21ff              MOVS     r1,#0xff
000020  6802              LDR      r2,[r0,#0]
000022  6251              STR      r1,[r2,#0x24]
000024  bf00              NOP      
;;;1751   }
000026  4770              BX       lr
;;;1752   
                          ENDP


                          AREA ||i.HAL_RTC_DST_ReadStoreOperation||, CODE, READONLY, ALIGN=1

                  HAL_RTC_DST_ReadStoreOperation PROC
;;;1757     */
;;;1758   uint32_t HAL_RTC_DST_ReadStoreOperation(RTC_HandleTypeDef *hrtc)
000000  4601              MOV      r1,r0
;;;1759   {
;;;1760     return READ_BIT(hrtc->Instance->CR, RTC_CR_BKP);
000002  6808              LDR      r0,[r1,#0]
000004  6880              LDR      r0,[r0,#8]
000006  f4002080          AND      r0,r0,#0x40000
;;;1761   }
00000a  4770              BX       lr
;;;1762   
                          ENDP


                          AREA ||i.HAL_RTC_DST_SetStoreOperation||, CODE, READONLY, ALIGN=1

                  HAL_RTC_DST_SetStoreOperation PROC
;;;1732     */
;;;1733   void HAL_RTC_DST_SetStoreOperation(RTC_HandleTypeDef *hrtc)
000000  bf00              NOP      
;;;1734   {
;;;1735     __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
000002  21ca              MOVS     r1,#0xca
000004  6802              LDR      r2,[r0,#0]
000006  6251              STR      r1,[r2,#0x24]
000008  2153              MOVS     r1,#0x53
00000a  6802              LDR      r2,[r0,#0]
00000c  6251              STR      r1,[r2,#0x24]
00000e  bf00              NOP      
;;;1736     SET_BIT(hrtc->Instance->CR, RTC_CR_BKP);
000010  6801              LDR      r1,[r0,#0]
000012  6889              LDR      r1,[r1,#8]
000014  f4412180          ORR      r1,r1,#0x40000
000018  6802              LDR      r2,[r0,#0]
00001a  6091              STR      r1,[r2,#8]
;;;1737     __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
00001c  bf00              NOP      
00001e  21ff              MOVS     r1,#0xff
000020  6802              LDR      r2,[r0,#0]
000022  6251              STR      r1,[r2,#0x24]
000024  bf00              NOP      
;;;1738   }
000026  4770              BX       lr
;;;1739   
                          ENDP


                          AREA ||i.HAL_RTC_DST_Sub1Hour||, CODE, READONLY, ALIGN=1

                  HAL_RTC_DST_Sub1Hour PROC
;;;1718     */
;;;1719   void HAL_RTC_DST_Sub1Hour(RTC_HandleTypeDef *hrtc)
000000  bf00              NOP      
;;;1720   {
;;;1721     __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
000002  21ca              MOVS     r1,#0xca
000004  6802              LDR      r2,[r0,#0]
000006  6251              STR      r1,[r2,#0x24]
000008  2153              MOVS     r1,#0x53
00000a  6802              LDR      r2,[r0,#0]
00000c  6251              STR      r1,[r2,#0x24]
00000e  bf00              NOP      
;;;1722     SET_BIT(hrtc->Instance->CR, RTC_CR_SUB1H);
000010  6801              LDR      r1,[r0,#0]
000012  6889              LDR      r1,[r1,#8]
000014  f4413100          ORR      r1,r1,#0x20000
000018  6802              LDR      r2,[r0,#0]
00001a  6091              STR      r1,[r2,#8]
;;;1723     __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
00001c  bf00              NOP      
00001e  21ff              MOVS     r1,#0xff
000020  6802              LDR      r2,[r0,#0]
000022  6251              STR      r1,[r2,#0x24]
000024  bf00              NOP      
;;;1724   }
000026  4770              BX       lr
;;;1725   
                          ENDP


                          AREA ||i.HAL_RTC_DeInit||, CODE, READONLY, ALIGN=2

                  HAL_RTC_DeInit PROC
;;;362      */
;;;363    HAL_StatusTypeDef HAL_RTC_DeInit(RTC_HandleTypeDef *hrtc)
000000  b570              PUSH     {r4-r6,lr}
;;;364    {
000002  4604              MOV      r4,r0
;;;365      HAL_StatusTypeDef status = HAL_ERROR;
000004  2501              MOVS     r5,#1
;;;366    
;;;367      /* Check the parameters */
;;;368      assert_param(IS_RTC_ALL_INSTANCE(hrtc->Instance));
;;;369    
;;;370      /* Set RTC state */
;;;371      hrtc->State = HAL_RTC_STATE_BUSY;
000006  2002              MOVS     r0,#2
000008  7760              STRB     r0,[r4,#0x1d]
;;;372    
;;;373      /* Disable the write protection for RTC registers */
;;;374      __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
00000a  bf00              NOP      
00000c  20ca              MOVS     r0,#0xca
00000e  6821              LDR      r1,[r4,#0]
000010  6248              STR      r0,[r1,#0x24]
000012  2053              MOVS     r0,#0x53
000014  6821              LDR      r1,[r4,#0]
000016  6248              STR      r0,[r1,#0x24]
000018  bf00              NOP      
;;;375    
;;;376      /* Enter Initialization mode */
;;;377      status = RTC_EnterInitMode(hrtc);
00001a  4620              MOV      r0,r4
00001c  f7fffffe          BL       RTC_EnterInitMode
000020  4605              MOV      r5,r0
;;;378    
;;;379      if (status == HAL_OK)
000022  bb2d              CBNZ     r5,|L8.112|
;;;380      {
;;;381        /* Reset RTC registers */
;;;382        hrtc->Instance->TR = 0x00000000U;
000024  2000              MOVS     r0,#0
000026  6821              LDR      r1,[r4,#0]
000028  6008              STR      r0,[r1,#0]
;;;383        hrtc->Instance->DR = (RTC_DR_WDU_0 | RTC_DR_MU_0 | RTC_DR_DU_0);
00002a  f2421001          MOV      r0,#0x2101
00002e  6821              LDR      r1,[r4,#0]
000030  6048              STR      r0,[r1,#4]
;;;384        hrtc->Instance->CR  &= 0x00000000U;
000032  6820              LDR      r0,[r4,#0]
000034  6880              LDR      r0,[r0,#8]
000036  2000              MOVS     r0,#0
000038  6821              LDR      r1,[r4,#0]
00003a  6088              STR      r0,[r1,#8]
;;;385        hrtc->Instance->WUTR = RTC_WUTR_WUT;
00003c  f64f70ff          MOV      r0,#0xffff
000040  6821              LDR      r1,[r4,#0]
000042  6148              STR      r0,[r1,#0x14]
;;;386        hrtc->Instance->PRER = (uint32_t)(RTC_PRER_PREDIV_A | 0x000000FFU);
000044  4814              LDR      r0,|L8.152|
000046  6821              LDR      r1,[r4,#0]
000048  6108              STR      r0,[r1,#0x10]
;;;387        hrtc->Instance->CALIBR = 0x00000000U;
00004a  2000              MOVS     r0,#0
00004c  6821              LDR      r1,[r4,#0]
00004e  6188              STR      r0,[r1,#0x18]
;;;388        hrtc->Instance->ALRMAR   = 0x00000000U;
000050  6821              LDR      r1,[r4,#0]
000052  61c8              STR      r0,[r1,#0x1c]
;;;389        hrtc->Instance->ALRMBR   = 0x00000000U;
000054  6821              LDR      r1,[r4,#0]
000056  6208              STR      r0,[r1,#0x20]
;;;390        hrtc->Instance->CALR     = 0x00000000U;
000058  6821              LDR      r1,[r4,#0]
00005a  63c8              STR      r0,[r1,#0x3c]
;;;391        hrtc->Instance->SHIFTR   = 0x00000000U;
00005c  6821              LDR      r1,[r4,#0]
00005e  62c8              STR      r0,[r1,#0x2c]
;;;392        hrtc->Instance->ALRMASSR = 0x00000000U;
000060  6821              LDR      r1,[r4,#0]
000062  6448              STR      r0,[r1,#0x44]
;;;393        hrtc->Instance->ALRMBSSR = 0x00000000U;
000064  6821              LDR      r1,[r4,#0]
000066  6488              STR      r0,[r1,#0x48]
;;;394    
;;;395        /* Exit Initialization mode */
;;;396        status = RTC_ExitInitMode(hrtc);
000068  4620              MOV      r0,r4
00006a  f7fffffe          BL       RTC_ExitInitMode
00006e  4605              MOV      r5,r0
                  |L8.112|
;;;397      }
;;;398    
;;;399      /* Enable the write protection for RTC registers */
;;;400      __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
000070  bf00              NOP      
000072  20ff              MOVS     r0,#0xff
000074  6821              LDR      r1,[r4,#0]
000076  6248              STR      r0,[r1,#0x24]
000078  bf00              NOP      
;;;401    
;;;402      if (status == HAL_OK)
00007a  b93d              CBNZ     r5,|L8.140|
;;;403      {
;;;404        /* Reset Tamper and alternate functions configuration register */
;;;405        hrtc->Instance->TAFCR = 0x00000000U;
00007c  2000              MOVS     r0,#0
00007e  6821              LDR      r1,[r4,#0]
000080  6408              STR      r0,[r1,#0x40]
;;;406    
;;;407    #if (USE_HAL_RTC_REGISTER_CALLBACKS == 1)
;;;408        if (hrtc->MspDeInitCallback == NULL)
;;;409        {
;;;410          hrtc->MspDeInitCallback = HAL_RTC_MspDeInit;
;;;411        }
;;;412    
;;;413        /* DeInit the low level hardware: CLOCK, NVIC.*/
;;;414        hrtc->MspDeInitCallback(hrtc);
;;;415    #else /* USE_HAL_RTC_REGISTER_CALLBACKS */
;;;416        /* De-Initialize RTC MSP */
;;;417        HAL_RTC_MspDeInit(hrtc);
000082  4620              MOV      r0,r4
000084  f7fffffe          BL       HAL_RTC_MspDeInit
;;;418    #endif /* USE_HAL_RTC_REGISTER_CALLBACKS */
;;;419    
;;;420        hrtc->State = HAL_RTC_STATE_RESET;
000088  2000              MOVS     r0,#0
00008a  7760              STRB     r0,[r4,#0x1d]
                  |L8.140|
;;;421      }
;;;422    
;;;423      /* Release Lock */
;;;424      __HAL_UNLOCK(hrtc);
00008c  bf00              NOP      
00008e  2000              MOVS     r0,#0
000090  7720              STRB     r0,[r4,#0x1c]
000092  bf00              NOP      
;;;425    
;;;426      return status;
000094  4628              MOV      r0,r5
;;;427    }
000096  bd70              POP      {r4-r6,pc}
;;;428    
                          ENDP

                  |L8.152|
                          DCD      0x007f00ff

                          AREA ||i.HAL_RTC_DeactivateAlarm||, CODE, READONLY, ALIGN=1

                  HAL_RTC_DeactivateAlarm PROC
;;;1394     */
;;;1395   HAL_StatusTypeDef HAL_RTC_DeactivateAlarm(RTC_HandleTypeDef *hrtc, uint32_t Alarm)
000000  b570              PUSH     {r4-r6,lr}
;;;1396   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;1397     uint32_t tickstart = 0U;
000006  2600              MOVS     r6,#0
;;;1398   
;;;1399     /* Check the parameters */
;;;1400     assert_param(IS_RTC_ALARM(Alarm));
;;;1401   
;;;1402     /* Process Locked */
;;;1403     __HAL_LOCK(hrtc);
000008  bf00              NOP      
00000a  7f20              LDRB     r0,[r4,#0x1c]
00000c  2801              CMP      r0,#1
00000e  d101              BNE      |L9.20|
000010  2002              MOVS     r0,#2
                  |L9.18|
;;;1404   
;;;1405     hrtc->State = HAL_RTC_STATE_BUSY;
;;;1406   
;;;1407     /* Disable the write protection for RTC registers */
;;;1408     __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
;;;1409   
;;;1410     if (Alarm == RTC_ALARM_A)
;;;1411     {
;;;1412       /* Disable Alarm A */
;;;1413       __HAL_RTC_ALARMA_DISABLE(hrtc);
;;;1414   
;;;1415       /* In case interrupt mode is used, the interrupt source must be disabled */
;;;1416       __HAL_RTC_ALARM_DISABLE_IT(hrtc, RTC_IT_ALRA);
;;;1417   
;;;1418       /* Get tick */
;;;1419       tickstart = HAL_GetTick();
;;;1420   
;;;1421       /* Wait till RTC ALRxWF flag is set and if timeout is reached exit */
;;;1422       while (__HAL_RTC_ALARM_GET_FLAG(hrtc, RTC_FLAG_ALRAWF) == 0U)
;;;1423       {
;;;1424         if ((HAL_GetTick() - tickstart) > RTC_TIMEOUT_VALUE)
;;;1425         {
;;;1426           /* Enable the write protection for RTC registers */
;;;1427           __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
;;;1428   
;;;1429           hrtc->State = HAL_RTC_STATE_TIMEOUT;
;;;1430   
;;;1431           /* Process Unlocked */
;;;1432           __HAL_UNLOCK(hrtc);
;;;1433   
;;;1434           return HAL_TIMEOUT;
;;;1435         }
;;;1436       }
;;;1437     }
;;;1438     else
;;;1439     {
;;;1440       /* Disable Alarm B */
;;;1441       __HAL_RTC_ALARMB_DISABLE(hrtc);
;;;1442   
;;;1443       /* In case interrupt mode is used, the interrupt source must be disabled */
;;;1444       __HAL_RTC_ALARM_DISABLE_IT(hrtc, RTC_IT_ALRB);
;;;1445   
;;;1446       /* Get tick */
;;;1447       tickstart = HAL_GetTick();
;;;1448   
;;;1449       /* Wait till RTC ALRxWF flag is set and if timeout is reached exit */
;;;1450       while (__HAL_RTC_ALARM_GET_FLAG(hrtc, RTC_FLAG_ALRBWF) == 0U)
;;;1451       {
;;;1452         if ((HAL_GetTick() - tickstart) > RTC_TIMEOUT_VALUE)
;;;1453         {
;;;1454           /* Enable the write protection for RTC registers */
;;;1455           __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
;;;1456   
;;;1457           hrtc->State = HAL_RTC_STATE_TIMEOUT;
;;;1458   
;;;1459           /* Process Unlocked */
;;;1460           __HAL_UNLOCK(hrtc);
;;;1461   
;;;1462           return HAL_TIMEOUT;
;;;1463         }
;;;1464       }
;;;1465     }
;;;1466   
;;;1467     /* Enable the write protection for RTC registers */
;;;1468     __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
;;;1469   
;;;1470     hrtc->State = HAL_RTC_STATE_READY;
;;;1471   
;;;1472     /* Process Unlocked */
;;;1473     __HAL_UNLOCK(hrtc);
;;;1474   
;;;1475     return HAL_OK;
;;;1476   }
000012  bd70              POP      {r4-r6,pc}
                  |L9.20|
000014  2001              MOVS     r0,#1                 ;1403
000016  7720              STRB     r0,[r4,#0x1c]         ;1403
000018  bf00              NOP                            ;1403
00001a  2002              MOVS     r0,#2                 ;1405
00001c  7760              STRB     r0,[r4,#0x1d]         ;1405
00001e  bf00              NOP                            ;1408
000020  20ca              MOVS     r0,#0xca              ;1408
000022  6821              LDR      r1,[r4,#0]            ;1408
000024  6248              STR      r0,[r1,#0x24]         ;1408
000026  2053              MOVS     r0,#0x53              ;1408
000028  6821              LDR      r1,[r4,#0]            ;1408
00002a  6248              STR      r0,[r1,#0x24]         ;1408
00002c  bf00              NOP                            ;1408
00002e  f5b57f80          CMP      r5,#0x100             ;1410
000032  d129              BNE      |L9.136|
000034  6820              LDR      r0,[r4,#0]            ;1413
000036  6880              LDR      r0,[r0,#8]            ;1413
000038  f4207080          BIC      r0,r0,#0x100          ;1413
00003c  6821              LDR      r1,[r4,#0]            ;1413
00003e  6088              STR      r0,[r1,#8]            ;1413
000040  6820              LDR      r0,[r4,#0]            ;1416
000042  6880              LDR      r0,[r0,#8]            ;1416
000044  f4205080          BIC      r0,r0,#0x1000         ;1416
000048  6821              LDR      r1,[r4,#0]            ;1416
00004a  6088              STR      r0,[r1,#8]            ;1416
00004c  f7fffffe          BL       HAL_GetTick
000050  4606              MOV      r6,r0                 ;1419
000052  e012              B        |L9.122|
                  |L9.84|
000054  f7fffffe          BL       HAL_GetTick
000058  1b80              SUBS     r0,r0,r6              ;1424
00005a  f5b07f7a          CMP      r0,#0x3e8             ;1424
00005e  d90c              BLS      |L9.122|
000060  bf00              NOP                            ;1427
000062  20ff              MOVS     r0,#0xff              ;1427
000064  6821              LDR      r1,[r4,#0]            ;1427
000066  6248              STR      r0,[r1,#0x24]         ;1427
000068  bf00              NOP                            ;1427
00006a  2003              MOVS     r0,#3                 ;1429
00006c  7760              STRB     r0,[r4,#0x1d]         ;1429
00006e  bf00              NOP                            ;1432
000070  2000              MOVS     r0,#0                 ;1432
000072  7720              STRB     r0,[r4,#0x1c]         ;1432
000074  bf00              NOP                            ;1432
000076  2003              MOVS     r0,#3                 ;1434
000078  e7cb              B        |L9.18|
                  |L9.122|
00007a  6820              LDR      r0,[r4,#0]            ;1422
00007c  68c0              LDR      r0,[r0,#0xc]          ;1422
00007e  f0000001          AND      r0,r0,#1              ;1422
000082  2800              CMP      r0,#0                 ;1422
000084  d0e6              BEQ      |L9.84|
000086  e028              B        |L9.218|
                  |L9.136|
000088  6820              LDR      r0,[r4,#0]            ;1441
00008a  6880              LDR      r0,[r0,#8]            ;1441
00008c  f4207000          BIC      r0,r0,#0x200          ;1441
000090  6821              LDR      r1,[r4,#0]            ;1441
000092  6088              STR      r0,[r1,#8]            ;1441
000094  6820              LDR      r0,[r4,#0]            ;1444
000096  6880              LDR      r0,[r0,#8]            ;1444
000098  f4205000          BIC      r0,r0,#0x2000         ;1444
00009c  6821              LDR      r1,[r4,#0]            ;1444
00009e  6088              STR      r0,[r1,#8]            ;1444
0000a0  f7fffffe          BL       HAL_GetTick
0000a4  4606              MOV      r6,r0                 ;1447
0000a6  e012              B        |L9.206|
                  |L9.168|
0000a8  f7fffffe          BL       HAL_GetTick
0000ac  1b80              SUBS     r0,r0,r6              ;1452
0000ae  f5b07f7a          CMP      r0,#0x3e8             ;1452
0000b2  d90c              BLS      |L9.206|
0000b4  bf00              NOP                            ;1455
0000b6  20ff              MOVS     r0,#0xff              ;1455
0000b8  6821              LDR      r1,[r4,#0]            ;1455
0000ba  6248              STR      r0,[r1,#0x24]         ;1455
0000bc  bf00              NOP                            ;1455
0000be  2003              MOVS     r0,#3                 ;1457
0000c0  7760              STRB     r0,[r4,#0x1d]         ;1457
0000c2  bf00              NOP                            ;1460
0000c4  2000              MOVS     r0,#0                 ;1460
0000c6  7720              STRB     r0,[r4,#0x1c]         ;1460
0000c8  bf00              NOP                            ;1460
0000ca  2003              MOVS     r0,#3                 ;1462
0000cc  e7a1              B        |L9.18|
                  |L9.206|
0000ce  6820              LDR      r0,[r4,#0]            ;1450
0000d0  68c0              LDR      r0,[r0,#0xc]          ;1450
0000d2  f3c00040          UBFX     r0,r0,#1,#1           ;1450
0000d6  2800              CMP      r0,#0                 ;1450
0000d8  d0e6              BEQ      |L9.168|
                  |L9.218|
0000da  bf00              NOP                            ;1468
0000dc  20ff              MOVS     r0,#0xff              ;1468
0000de  6821              LDR      r1,[r4,#0]            ;1468
0000e0  6248              STR      r0,[r1,#0x24]         ;1468
0000e2  bf00              NOP                            ;1468
0000e4  2001              MOVS     r0,#1                 ;1470
0000e6  7760              STRB     r0,[r4,#0x1d]         ;1470
0000e8  bf00              NOP                            ;1473
0000ea  2000              MOVS     r0,#0                 ;1473
0000ec  7720              STRB     r0,[r4,#0x1c]         ;1473
0000ee  bf00              NOP                            ;1473
0000f0  bf00              NOP                            ;1475
0000f2  e78e              B        |L9.18|
;;;1477   
                          ENDP


                          AREA ||i.HAL_RTC_GetAlarm||, CODE, READONLY, ALIGN=1

                  HAL_RTC_GetAlarm PROC
;;;1492     */
;;;1493   HAL_StatusTypeDef HAL_RTC_GetAlarm(RTC_HandleTypeDef *hrtc, RTC_AlarmTypeDef *sAlarm, uint32_t Alarm, uint32_t Format)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1494   {
000004  4605              MOV      r5,r0
000006  460c              MOV      r4,r1
000008  4616              MOV      r6,r2
00000a  461f              MOV      r7,r3
;;;1495     uint32_t tmpreg = 0U;
00000c  2300              MOVS     r3,#0
;;;1496     uint32_t subsecondtmpreg = 0U;
00000e  4698              MOV      r8,r3
;;;1497   
;;;1498     /* Check the parameters */
;;;1499     assert_param(IS_RTC_FORMAT(Format));
;;;1500     assert_param(IS_RTC_ALARM(Alarm));
;;;1501   
;;;1502     if (Alarm == RTC_ALARM_A)
000010  f5b67f80          CMP      r6,#0x100
000014  d109              BNE      |L10.42|
;;;1503     {
;;;1504       sAlarm->Alarm = RTC_ALARM_A;
000016  f44f7080          MOV      r0,#0x100
00001a  6260              STR      r0,[r4,#0x24]
;;;1505   
;;;1506       tmpreg = (uint32_t)(hrtc->Instance->ALRMAR);
00001c  6828              LDR      r0,[r5,#0]
00001e  69c3              LDR      r3,[r0,#0x1c]
;;;1507       subsecondtmpreg = (uint32_t)((hrtc->Instance->ALRMASSR) & RTC_ALRMASSR_SS);
000020  6828              LDR      r0,[r5,#0]
000022  6c40              LDR      r0,[r0,#0x44]
000024  f3c0080e          UBFX     r8,r0,#0,#15
000028  e008              B        |L10.60|
                  |L10.42|
;;;1508     }
;;;1509     else
;;;1510     {
;;;1511       sAlarm->Alarm = RTC_ALARM_B;
00002a  f44f7000          MOV      r0,#0x200
00002e  6260              STR      r0,[r4,#0x24]
;;;1512   
;;;1513       tmpreg = (uint32_t)(hrtc->Instance->ALRMBR);
000030  6828              LDR      r0,[r5,#0]
000032  6a03              LDR      r3,[r0,#0x20]
;;;1514       subsecondtmpreg = (uint32_t)((hrtc->Instance->ALRMBSSR) & RTC_ALRMBSSR_SS);
000034  6828              LDR      r0,[r5,#0]
000036  6c80              LDR      r0,[r0,#0x48]
000038  f3c0080e          UBFX     r8,r0,#0,#15
                  |L10.60|
;;;1515     }
;;;1516   
;;;1517     /* Fill the structure with the read parameters */
;;;1518     sAlarm->AlarmTime.Hours      = (uint8_t) ((tmpreg & (RTC_ALRMAR_HT  | RTC_ALRMAR_HU))  >> RTC_ALRMAR_HU_Pos);
00003c  f3c34005          UBFX     r0,r3,#16,#6
000040  7020              STRB     r0,[r4,#0]
;;;1519     sAlarm->AlarmTime.Minutes    = (uint8_t) ((tmpreg & (RTC_ALRMAR_MNT | RTC_ALRMAR_MNU)) >> RTC_ALRMAR_MNU_Pos);
000042  f3c32006          UBFX     r0,r3,#8,#7
000046  7060              STRB     r0,[r4,#1]
;;;1520     sAlarm->AlarmTime.Seconds    = (uint8_t) ( tmpreg & (RTC_ALRMAR_ST  | RTC_ALRMAR_SU));
000048  f003007f          AND      r0,r3,#0x7f
00004c  70a0              STRB     r0,[r4,#2]
;;;1521     sAlarm->AlarmTime.TimeFormat = (uint8_t) ((tmpreg & RTC_ALRMAR_PM)                     >> RTC_TR_PM_Pos);
00004e  f3c35080          UBFX     r0,r3,#22,#1
000052  70e0              STRB     r0,[r4,#3]
;;;1522     sAlarm->AlarmTime.SubSeconds = (uint32_t) subsecondtmpreg;
000054  f8c48004          STR      r8,[r4,#4]
;;;1523     sAlarm->AlarmDateWeekDay     = (uint8_t) ((tmpreg & (RTC_ALRMAR_DT  | RTC_ALRMAR_DU))  >> RTC_ALRMAR_DU_Pos);
000058  f3c36005          UBFX     r0,r3,#24,#6
00005c  f8840020          STRB     r0,[r4,#0x20]
;;;1524     sAlarm->AlarmDateWeekDaySel  = (uint32_t) (tmpreg & RTC_ALRMAR_WDSEL);
000060  f0034080          AND      r0,r3,#0x40000000
000064  61e0              STR      r0,[r4,#0x1c]
;;;1525     sAlarm->AlarmMask            = (uint32_t) (tmpreg & RTC_ALARMMASK_ALL);
000066  f0033080          AND      r0,r3,#0x80808080
00006a  6160              STR      r0,[r4,#0x14]
;;;1526   
;;;1527     if (Format == RTC_FORMAT_BIN)
00006c  b98f              CBNZ     r7,|L10.146|
;;;1528     {
;;;1529       sAlarm->AlarmTime.Hours   = RTC_Bcd2ToByte(sAlarm->AlarmTime.Hours);
00006e  7820              LDRB     r0,[r4,#0]
000070  f7fffffe          BL       RTC_Bcd2ToByte
000074  7020              STRB     r0,[r4,#0]
;;;1530       sAlarm->AlarmTime.Minutes = RTC_Bcd2ToByte(sAlarm->AlarmTime.Minutes);
000076  7860              LDRB     r0,[r4,#1]
000078  f7fffffe          BL       RTC_Bcd2ToByte
00007c  7060              STRB     r0,[r4,#1]
;;;1531       sAlarm->AlarmTime.Seconds = RTC_Bcd2ToByte(sAlarm->AlarmTime.Seconds);
00007e  78a0              LDRB     r0,[r4,#2]
000080  f7fffffe          BL       RTC_Bcd2ToByte
000084  70a0              STRB     r0,[r4,#2]
;;;1532       sAlarm->AlarmDateWeekDay  = RTC_Bcd2ToByte(sAlarm->AlarmDateWeekDay);
000086  f8940020          LDRB     r0,[r4,#0x20]
00008a  f7fffffe          BL       RTC_Bcd2ToByte
00008e  f8840020          STRB     r0,[r4,#0x20]
                  |L10.146|
;;;1533     }
;;;1534   
;;;1535     return HAL_OK;
000092  2000              MOVS     r0,#0
;;;1536   }
000094  e8bd81f0          POP      {r4-r8,pc}
;;;1537   
                          ENDP


                          AREA ||i.HAL_RTC_GetDate||, CODE, READONLY, ALIGN=2

                  HAL_RTC_GetDate PROC
;;;945      */
;;;946    HAL_StatusTypeDef HAL_RTC_GetDate(RTC_HandleTypeDef *hrtc, RTC_DateTypeDef *sDate, uint32_t Format)
000000  b570              PUSH     {r4-r6,lr}
;;;947    {
000002  4605              MOV      r5,r0
000004  460b              MOV      r3,r1
000006  4616              MOV      r6,r2
;;;948      uint32_t datetmpreg = 0U;
000008  2400              MOVS     r4,#0
;;;949    
;;;950      /* Check the parameters */
;;;951      assert_param(IS_RTC_FORMAT(Format));
;;;952    
;;;953      /* Get the DR register */
;;;954      datetmpreg = (uint32_t)(hrtc->Instance->DR & RTC_DR_RESERVED_MASK);
00000a  6828              LDR      r0,[r5,#0]
00000c  6840              LDR      r0,[r0,#4]
00000e  490e              LDR      r1,|L11.72|
000010  ea000401          AND      r4,r0,r1
;;;955    
;;;956      /* Fill the structure fields with the read parameters */
;;;957      sDate->Year    = (uint8_t)((datetmpreg & (RTC_DR_YT | RTC_DR_YU)) >> RTC_DR_YU_Pos);
000014  0c20              LSRS     r0,r4,#16
000016  70d8              STRB     r0,[r3,#3]
;;;958      sDate->Month   = (uint8_t)((datetmpreg & (RTC_DR_MT | RTC_DR_MU)) >> RTC_DR_MU_Pos);
000018  f3c42004          UBFX     r0,r4,#8,#5
00001c  7058              STRB     r0,[r3,#1]
;;;959      sDate->Date    = (uint8_t) (datetmpreg & (RTC_DR_DT | RTC_DR_DU));
00001e  f004003f          AND      r0,r4,#0x3f
000022  7098              STRB     r0,[r3,#2]
;;;960      sDate->WeekDay = (uint8_t)((datetmpreg & (RTC_DR_WDU))            >> RTC_DR_WDU_Pos);
000024  f3c43042          UBFX     r0,r4,#13,#3
000028  7018              STRB     r0,[r3,#0]
;;;961    
;;;962      /* Check the input parameters format */
;;;963      if (Format == RTC_FORMAT_BIN)
00002a  b95e              CBNZ     r6,|L11.68|
;;;964      {
;;;965        /* Convert the date structure parameters to Binary format */
;;;966        sDate->Year  = (uint8_t)RTC_Bcd2ToByte(sDate->Year);
00002c  78d8              LDRB     r0,[r3,#3]
00002e  f7fffffe          BL       RTC_Bcd2ToByte
000032  70d8              STRB     r0,[r3,#3]
;;;967        sDate->Month = (uint8_t)RTC_Bcd2ToByte(sDate->Month);
000034  7858              LDRB     r0,[r3,#1]
000036  f7fffffe          BL       RTC_Bcd2ToByte
00003a  7058              STRB     r0,[r3,#1]
;;;968        sDate->Date  = (uint8_t)RTC_Bcd2ToByte(sDate->Date);
00003c  7898              LDRB     r0,[r3,#2]
00003e  f7fffffe          BL       RTC_Bcd2ToByte
000042  7098              STRB     r0,[r3,#2]
                  |L11.68|
;;;969      }
;;;970      return HAL_OK;
000044  2000              MOVS     r0,#0
;;;971    }
000046  bd70              POP      {r4-r6,pc}
;;;972    
                          ENDP

                  |L11.72|
                          DCD      0x00ffff3f

                          AREA ||i.HAL_RTC_GetState||, CODE, READONLY, ALIGN=1

                  HAL_RTC_GetState PROC
;;;1786     */
;;;1787   HAL_RTCStateTypeDef HAL_RTC_GetState(RTC_HandleTypeDef *hrtc)
000000  4601              MOV      r1,r0
;;;1788   {
;;;1789     return hrtc->State;
000002  7f48              LDRB     r0,[r1,#0x1d]
;;;1790   }
000004  4770              BX       lr
;;;1791   
                          ENDP


                          AREA ||i.HAL_RTC_GetTime||, CODE, READONLY, ALIGN=2

                  HAL_RTC_GetTime PROC
;;;811      */
;;;812    HAL_StatusTypeDef HAL_RTC_GetTime(RTC_HandleTypeDef *hrtc, RTC_TimeTypeDef *sTime, uint32_t Format)
000000  b570              PUSH     {r4-r6,lr}
;;;813    {
000002  4604              MOV      r4,r0
000004  460b              MOV      r3,r1
000006  4616              MOV      r6,r2
;;;814      uint32_t tmpreg = 0U;
000008  2500              MOVS     r5,#0
;;;815    
;;;816      /* Check the parameters */
;;;817      assert_param(IS_RTC_FORMAT(Format));
;;;818    
;;;819      /* Get subseconds value from the corresponding register */
;;;820      sTime->SubSeconds = (uint32_t)(hrtc->Instance->SSR);
00000a  6820              LDR      r0,[r4,#0]
00000c  6a80              LDR      r0,[r0,#0x28]
00000e  6058              STR      r0,[r3,#4]
;;;821    
;;;822      /* Get SecondFraction structure field from the corresponding register field*/
;;;823      sTime->SecondFraction = (uint32_t)(hrtc->Instance->PRER & RTC_PRER_PREDIV_S);
000010  6820              LDR      r0,[r4,#0]
000012  6900              LDR      r0,[r0,#0x10]
000014  f3c0000e          UBFX     r0,r0,#0,#15
000018  6098              STR      r0,[r3,#8]
;;;824    
;;;825      /* Get the TR register */
;;;826      tmpreg = (uint32_t)(hrtc->Instance->TR & RTC_TR_RESERVED_MASK);
00001a  6820              LDR      r0,[r4,#0]
00001c  6800              LDR      r0,[r0,#0]
00001e  490e              LDR      r1,|L13.88|
000020  ea000501          AND      r5,r0,r1
;;;827    
;;;828      /* Fill the structure fields with the read parameters */
;;;829      sTime->Hours      = (uint8_t)((tmpreg & (RTC_TR_HT  | RTC_TR_HU))  >> RTC_TR_HU_Pos);
000024  f3c54005          UBFX     r0,r5,#16,#6
000028  7018              STRB     r0,[r3,#0]
;;;830      sTime->Minutes    = (uint8_t)((tmpreg & (RTC_TR_MNT | RTC_TR_MNU)) >> RTC_TR_MNU_Pos);
00002a  f3c52006          UBFX     r0,r5,#8,#7
00002e  7058              STRB     r0,[r3,#1]
;;;831      sTime->Seconds    = (uint8_t)( tmpreg & (RTC_TR_ST  | RTC_TR_SU));
000030  f005007f          AND      r0,r5,#0x7f
000034  7098              STRB     r0,[r3,#2]
;;;832      sTime->TimeFormat = (uint8_t)((tmpreg & (RTC_TR_PM))               >> RTC_TR_PM_Pos);
000036  0da8              LSRS     r0,r5,#22
000038  70d8              STRB     r0,[r3,#3]
;;;833    
;;;834      /* Check the input parameters format */
;;;835      if (Format == RTC_FORMAT_BIN)
00003a  b95e              CBNZ     r6,|L13.84|
;;;836      {
;;;837        /* Convert the time structure parameters to Binary format */
;;;838        sTime->Hours = (uint8_t)RTC_Bcd2ToByte(sTime->Hours);
00003c  7818              LDRB     r0,[r3,#0]
00003e  f7fffffe          BL       RTC_Bcd2ToByte
000042  7018              STRB     r0,[r3,#0]
;;;839        sTime->Minutes = (uint8_t)RTC_Bcd2ToByte(sTime->Minutes);
000044  7858              LDRB     r0,[r3,#1]
000046  f7fffffe          BL       RTC_Bcd2ToByte
00004a  7058              STRB     r0,[r3,#1]
;;;840        sTime->Seconds = (uint8_t)RTC_Bcd2ToByte(sTime->Seconds);
00004c  7898              LDRB     r0,[r3,#2]
00004e  f7fffffe          BL       RTC_Bcd2ToByte
000052  7098              STRB     r0,[r3,#2]
                  |L13.84|
;;;841      }
;;;842    
;;;843      return HAL_OK;
000054  2000              MOVS     r0,#0
;;;844    }
000056  bd70              POP      {r4-r6,pc}
;;;845    
                          ENDP

                  |L13.88|
                          DCD      0x007f7f7f

                          AREA ||i.HAL_RTC_Init||, CODE, READONLY, ALIGN=2

                  HAL_RTC_Init PROC
;;;248      */
;;;249    HAL_StatusTypeDef HAL_RTC_Init(RTC_HandleTypeDef *hrtc)
000000  b570              PUSH     {r4-r6,lr}
;;;250    {
000002  4604              MOV      r4,r0
;;;251      HAL_StatusTypeDef status = HAL_ERROR;
000004  2501              MOVS     r5,#1
;;;252    
;;;253      /* Check RTC handler validity */
;;;254      if (hrtc == NULL)
000006  b90c              CBNZ     r4,|L14.12|
;;;255      {
;;;256        return HAL_ERROR;
000008  2001              MOVS     r0,#1
                  |L14.10|
;;;257      }
;;;258    
;;;259      /* Check the parameters */
;;;260      assert_param(IS_RTC_ALL_INSTANCE(hrtc->Instance));
;;;261      assert_param(IS_RTC_HOUR_FORMAT(hrtc->Init.HourFormat));
;;;262      assert_param(IS_RTC_ASYNCH_PREDIV(hrtc->Init.AsynchPrediv));
;;;263      assert_param(IS_RTC_SYNCH_PREDIV(hrtc->Init.SynchPrediv));
;;;264      assert_param(IS_RTC_OUTPUT(hrtc->Init.OutPut));
;;;265      assert_param(IS_RTC_OUTPUT_POL(hrtc->Init.OutPutPolarity));
;;;266      assert_param(IS_RTC_OUTPUT_TYPE(hrtc->Init.OutPutType));
;;;267    
;;;268    #if (USE_HAL_RTC_REGISTER_CALLBACKS == 1)
;;;269      if (hrtc->State == HAL_RTC_STATE_RESET)
;;;270      {
;;;271        /* Allocate lock resource and initialize it */
;;;272        hrtc->Lock = HAL_UNLOCKED;
;;;273    
;;;274        hrtc->AlarmAEventCallback          =  HAL_RTC_AlarmAEventCallback;        /* Legacy weak AlarmAEventCallback      */
;;;275        hrtc->AlarmBEventCallback          =  HAL_RTCEx_AlarmBEventCallback;      /* Legacy weak AlarmBEventCallback      */
;;;276        hrtc->TimeStampEventCallback       =  HAL_RTCEx_TimeStampEventCallback;   /* Legacy weak TimeStampEventCallback   */
;;;277        hrtc->WakeUpTimerEventCallback     =  HAL_RTCEx_WakeUpTimerEventCallback; /* Legacy weak WakeUpTimerEventCallback */
;;;278        hrtc->Tamper1EventCallback         =  HAL_RTCEx_Tamper1EventCallback;     /* Legacy weak Tamper1EventCallback     */
;;;279    #if defined(RTC_TAMPER2_SUPPORT)
;;;280        hrtc->Tamper2EventCallback         =  HAL_RTCEx_Tamper2EventCallback;     /* Legacy weak Tamper2EventCallback     */
;;;281    #endif /* RTC_TAMPER2_SUPPORT */
;;;282    
;;;283        if (hrtc->MspInitCallback == NULL)
;;;284        {
;;;285          hrtc->MspInitCallback = HAL_RTC_MspInit;
;;;286        }
;;;287        /* Init the low level hardware */
;;;288        hrtc->MspInitCallback(hrtc);
;;;289    
;;;290        if (hrtc->MspDeInitCallback == NULL)
;;;291        {
;;;292          hrtc->MspDeInitCallback = HAL_RTC_MspDeInit;
;;;293        }
;;;294      }
;;;295    #else /* USE_HAL_RTC_REGISTER_CALLBACKS */
;;;296      if (hrtc->State == HAL_RTC_STATE_RESET)
;;;297      {
;;;298        /* Allocate lock resource and initialize it */
;;;299        hrtc->Lock = HAL_UNLOCKED;
;;;300    
;;;301        /* Initialize RTC MSP */
;;;302        HAL_RTC_MspInit(hrtc);
;;;303      }
;;;304    #endif /* USE_HAL_RTC_REGISTER_CALLBACKS */
;;;305    
;;;306      /* Set RTC state */
;;;307      hrtc->State = HAL_RTC_STATE_BUSY;
;;;308    
;;;309      /* Check whether the calendar needs to be initialized */
;;;310      if (__HAL_RTC_IS_CALENDAR_INITIALIZED(hrtc) == 0U)
;;;311      {
;;;312        /* Disable the write protection for RTC registers */
;;;313        __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
;;;314    
;;;315        /* Enter Initialization mode */
;;;316        status = RTC_EnterInitMode(hrtc);
;;;317    
;;;318        if (status == HAL_OK)
;;;319        {
;;;320          /* Clear RTC_CR FMT, OSEL and POL Bits */
;;;321          hrtc->Instance->CR &= ((uint32_t)~(RTC_CR_FMT | RTC_CR_OSEL | RTC_CR_POL));
;;;322          /* Set RTC_CR register */
;;;323          hrtc->Instance->CR |= (uint32_t)(hrtc->Init.HourFormat | hrtc->Init.OutPut | hrtc->Init.OutPutPolarity);
;;;324    
;;;325          /* Configure the RTC PRER */
;;;326          hrtc->Instance->PRER = (uint32_t)(hrtc->Init.SynchPrediv);
;;;327          hrtc->Instance->PRER |= (uint32_t)(hrtc->Init.AsynchPrediv << RTC_PRER_PREDIV_A_Pos);
;;;328    
;;;329          /* Exit Initialization mode */
;;;330          status = RTC_ExitInitMode(hrtc);
;;;331        }
;;;332    
;;;333        if (status == HAL_OK)
;;;334        {
;;;335          hrtc->Instance->TAFCR &= (uint32_t)~RTC_OUTPUT_TYPE_PUSHPULL;
;;;336          hrtc->Instance->TAFCR |= (uint32_t)(hrtc->Init.OutPutType);
;;;337        }
;;;338    
;;;339        /* Enable the write protection for RTC registers */
;;;340        __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
;;;341      }
;;;342      else
;;;343      {
;;;344        /* The calendar is already initialized */
;;;345        status = HAL_OK;
;;;346      }
;;;347    
;;;348      if (status == HAL_OK)
;;;349      {
;;;350        hrtc->State = HAL_RTC_STATE_READY;
;;;351      }
;;;352    
;;;353      return status;
;;;354    }
00000a  bd70              POP      {r4-r6,pc}
                  |L14.12|
00000c  7f60              LDRB     r0,[r4,#0x1d]         ;296
00000e  b920              CBNZ     r0,|L14.26|
000010  2000              MOVS     r0,#0                 ;299
000012  7720              STRB     r0,[r4,#0x1c]         ;299
000014  4620              MOV      r0,r4                 ;302
000016  f7fffffe          BL       HAL_RTC_MspInit
                  |L14.26|
00001a  2002              MOVS     r0,#2                 ;307
00001c  7760              STRB     r0,[r4,#0x1d]         ;307
00001e  6820              LDR      r0,[r4,#0]            ;310
000020  68c0              LDR      r0,[r0,#0xc]          ;310
000022  f3c01000          UBFX     r0,r0,#4,#1           ;310
000026  2800              CMP      r0,#0                 ;310
000028  d13c              BNE      |L14.164|
00002a  bf00              NOP                            ;313
00002c  20ca              MOVS     r0,#0xca              ;313
00002e  6821              LDR      r1,[r4,#0]            ;313
000030  6248              STR      r0,[r1,#0x24]         ;313
000032  2053              MOVS     r0,#0x53              ;313
000034  6821              LDR      r1,[r4,#0]            ;313
000036  6248              STR      r0,[r1,#0x24]         ;313
000038  bf00              NOP                            ;313
00003a  4620              MOV      r0,r4                 ;316
00003c  f7fffffe          BL       RTC_EnterInitMode
000040  4605              MOV      r5,r0                 ;316
000042  b9ed              CBNZ     r5,|L14.128|
000044  6820              LDR      r0,[r4,#0]            ;321
000046  6880              LDR      r0,[r0,#8]            ;321
000048  4919              LDR      r1,|L14.176|
00004a  4008              ANDS     r0,r0,r1              ;321
00004c  6821              LDR      r1,[r4,#0]            ;321
00004e  6088              STR      r0,[r1,#8]            ;321
000050  6921              LDR      r1,[r4,#0x10]         ;323
000052  6860              LDR      r0,[r4,#4]            ;323
000054  4308              ORRS     r0,r0,r1              ;323
000056  6961              LDR      r1,[r4,#0x14]         ;323
000058  4308              ORRS     r0,r0,r1              ;323
00005a  6821              LDR      r1,[r4,#0]            ;323
00005c  6889              LDR      r1,[r1,#8]            ;323
00005e  4308              ORRS     r0,r0,r1              ;323
000060  6821              LDR      r1,[r4,#0]            ;323
000062  6088              STR      r0,[r1,#8]            ;323
000064  6821              LDR      r1,[r4,#0]            ;326
000066  68e0              LDR      r0,[r4,#0xc]          ;326
000068  6108              STR      r0,[r1,#0x10]         ;326
00006a  6820              LDR      r0,[r4,#0]            ;327
00006c  6901              LDR      r1,[r0,#0x10]         ;327
00006e  8920              LDRH     r0,[r4,#8]            ;327
000070  ea414000          ORR      r0,r1,r0,LSL #16      ;327
000074  6821              LDR      r1,[r4,#0]            ;327
000076  6108              STR      r0,[r1,#0x10]         ;327
000078  4620              MOV      r0,r4                 ;330
00007a  f7fffffe          BL       RTC_ExitInitMode
00007e  4605              MOV      r5,r0                 ;330
                  |L14.128|
000080  b95d              CBNZ     r5,|L14.154|
000082  6820              LDR      r0,[r4,#0]            ;335
000084  6c00              LDR      r0,[r0,#0x40]         ;335
000086  f4202080          BIC      r0,r0,#0x40000        ;335
00008a  6821              LDR      r1,[r4,#0]            ;335
00008c  6408              STR      r0,[r1,#0x40]         ;335
00008e  6820              LDR      r0,[r4,#0]            ;336
000090  6c00              LDR      r0,[r0,#0x40]         ;336
000092  69a1              LDR      r1,[r4,#0x18]         ;336
000094  4308              ORRS     r0,r0,r1              ;336
000096  6821              LDR      r1,[r4,#0]            ;336
000098  6408              STR      r0,[r1,#0x40]         ;336
                  |L14.154|
00009a  bf00              NOP                            ;340
00009c  20ff              MOVS     r0,#0xff              ;340
00009e  6821              LDR      r1,[r4,#0]            ;340
0000a0  6248              STR      r0,[r1,#0x24]         ;340
0000a2  e000              B        |L14.166|
                  |L14.164|
0000a4  2500              MOVS     r5,#0                 ;345
                  |L14.166|
0000a6  b90d              CBNZ     r5,|L14.172|
0000a8  2001              MOVS     r0,#1                 ;350
0000aa  7760              STRB     r0,[r4,#0x1d]         ;350
                  |L14.172|
0000ac  4628              MOV      r0,r5                 ;353
0000ae  e7ac              B        |L14.10|
;;;355    
                          ENDP

                  |L14.176|
                          DCD      0xff8fffbf

                          AREA ||i.HAL_RTC_MspDeInit||, CODE, READONLY, ALIGN=1

                  HAL_RTC_MspDeInit PROC
;;;656      */
;;;657    __weak void HAL_RTC_MspDeInit(RTC_HandleTypeDef *hrtc)
000000  4770              BX       lr
;;;658    {
;;;659      /* Prevent unused argument(s) compilation warning */
;;;660      UNUSED(hrtc);
;;;661    
;;;662      /* NOTE: This function should not be modified, when the callback is needed,
;;;663               the HAL_RTC_MspDeInit could be implemented in the user file
;;;664       */
;;;665    }
;;;666    
                          ENDP


                          AREA ||i.HAL_RTC_MspInit||, CODE, READONLY, ALIGN=1

                  HAL_RTC_MspInit PROC
;;;640      */
;;;641    __weak void HAL_RTC_MspInit(RTC_HandleTypeDef *hrtc)
000000  4770              BX       lr
;;;642    {
;;;643      /* Prevent unused argument(s) compilation warning */
;;;644      UNUSED(hrtc);
;;;645    
;;;646      /* NOTE: This function should not be modified, when the callback is needed,
;;;647               the HAL_RTC_MspInit could be implemented in the user file
;;;648       */
;;;649    }
;;;650    
                          ENDP


                          AREA ||i.HAL_RTC_PollForAlarmAEvent||, CODE, READONLY, ALIGN=1

                  HAL_RTC_PollForAlarmAEvent PROC
;;;1611     */
;;;1612   HAL_StatusTypeDef HAL_RTC_PollForAlarmAEvent(RTC_HandleTypeDef *hrtc, uint32_t Timeout)
000000  b570              PUSH     {r4-r6,lr}
;;;1613   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;1614     uint32_t tickstart = 0U;
000006  2600              MOVS     r6,#0
;;;1615   
;;;1616     /* Get tick */
;;;1617     tickstart = HAL_GetTick();
000008  f7fffffe          BL       HAL_GetTick
00000c  4606              MOV      r6,r0
;;;1618   
;;;1619     /* Wait till RTC ALRAF flag is set and if timeout is reached exit */
;;;1620     while (__HAL_RTC_ALARM_GET_FLAG(hrtc, RTC_FLAG_ALRAF) == 0U)
00000e  e00a              B        |L17.38|
                  |L17.16|
;;;1621     {
;;;1622       if (Timeout != HAL_MAX_DELAY)
000010  1c68              ADDS     r0,r5,#1
000012  b140              CBZ      r0,|L17.38|
;;;1623       {
;;;1624         if ((Timeout == 0U) || ((HAL_GetTick() - tickstart) > Timeout))
000014  b125              CBZ      r5,|L17.32|
000016  f7fffffe          BL       HAL_GetTick
00001a  1b80              SUBS     r0,r0,r6
00001c  42a8              CMP      r0,r5
00001e  d902              BLS      |L17.38|
                  |L17.32|
;;;1625         {
;;;1626           hrtc->State = HAL_RTC_STATE_TIMEOUT;
000020  2003              MOVS     r0,#3
000022  7760              STRB     r0,[r4,#0x1d]
                  |L17.36|
;;;1627           return HAL_TIMEOUT;
;;;1628         }
;;;1629       }
;;;1630     }
;;;1631   
;;;1632     /* Clear the Alarm flag */
;;;1633     __HAL_RTC_ALARM_CLEAR_FLAG(hrtc, RTC_FLAG_ALRAF);
;;;1634   
;;;1635     /* Change RTC state */
;;;1636     hrtc->State = HAL_RTC_STATE_READY;
;;;1637   
;;;1638     return HAL_OK;
;;;1639   }
000024  bd70              POP      {r4-r6,pc}
                  |L17.38|
000026  6820              LDR      r0,[r4,#0]            ;1620
000028  68c0              LDR      r0,[r0,#0xc]          ;1620
00002a  f3c02000          UBFX     r0,r0,#8,#1           ;1620
00002e  2800              CMP      r0,#0                 ;1620
000030  d0ee              BEQ      |L17.16|
000032  6820              LDR      r0,[r4,#0]            ;1633
000034  68c0              LDR      r0,[r0,#0xc]          ;1633
000036  f0000080          AND      r0,r0,#0x80           ;1633
00003a  f46070c0          ORN      r0,r0,#0x180          ;1633
00003e  6821              LDR      r1,[r4,#0]            ;1633
000040  60c8              STR      r0,[r1,#0xc]          ;1633
000042  2001              MOVS     r0,#1                 ;1636
000044  7760              STRB     r0,[r4,#0x1d]         ;1636
000046  2000              MOVS     r0,#0                 ;1638
000048  e7ec              B        |L17.36|
;;;1640   
                          ENDP


                          AREA ||i.HAL_RTC_SetAlarm||, CODE, READONLY, ALIGN=1

                  HAL_RTC_SetAlarm PROC
;;;1003     */
;;;1004   HAL_StatusTypeDef HAL_RTC_SetAlarm(RTC_HandleTypeDef *hrtc, RTC_AlarmTypeDef *sAlarm, uint32_t Format)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;1005   {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
;;;1006     uint32_t tickstart = 0U;
00000a  2700              MOVS     r7,#0
;;;1007     uint32_t tmpreg = 0U;
00000c  46b8              MOV      r8,r7
;;;1008     uint32_t subsecondtmpreg = 0U;
00000e  46b9              MOV      r9,r7
;;;1009   
;;;1010     /* Check the parameters */
;;;1011     assert_param(IS_RTC_FORMAT(Format));
;;;1012     assert_param(IS_RTC_ALARM(sAlarm->Alarm));
;;;1013     assert_param(IS_RTC_ALARM_MASK(sAlarm->AlarmMask));
;;;1014     assert_param(IS_RTC_ALARM_DATE_WEEKDAY_SEL(sAlarm->AlarmDateWeekDaySel));
;;;1015     assert_param(IS_RTC_ALARM_SUB_SECOND_VALUE(sAlarm->AlarmTime.SubSeconds));
;;;1016     assert_param(IS_RTC_ALARM_SUB_SECOND_MASK(sAlarm->AlarmSubSecondMask));
;;;1017   
;;;1018     /* Process Locked */
;;;1019     __HAL_LOCK(hrtc);
000010  bf00              NOP      
000012  7f20              LDRB     r0,[r4,#0x1c]
000014  2801              CMP      r0,#1
000016  d102              BNE      |L18.30|
000018  2002              MOVS     r0,#2
                  |L18.26|
;;;1020   
;;;1021     /* Change RTC state to BUSY */
;;;1022     hrtc->State = HAL_RTC_STATE_BUSY;
;;;1023   
;;;1024     /* Check the data format (binary or BCD) and store the Alarm time and date
;;;1025        configuration accordingly */
;;;1026     if (Format == RTC_FORMAT_BIN)
;;;1027     {
;;;1028       if ((hrtc->Instance->CR & RTC_CR_FMT) != 0U)
;;;1029       {
;;;1030         assert_param(IS_RTC_HOUR12(sAlarm->AlarmTime.Hours));
;;;1031         assert_param(IS_RTC_HOURFORMAT12(sAlarm->AlarmTime.TimeFormat));
;;;1032       }
;;;1033       else
;;;1034       {
;;;1035         sAlarm->AlarmTime.TimeFormat = 0x00U;
;;;1036         assert_param(IS_RTC_HOUR24(sAlarm->AlarmTime.Hours));
;;;1037       }
;;;1038       assert_param(IS_RTC_MINUTES(sAlarm->AlarmTime.Minutes));
;;;1039       assert_param(IS_RTC_SECONDS(sAlarm->AlarmTime.Seconds));
;;;1040   
;;;1041       if (sAlarm->AlarmDateWeekDaySel == RTC_ALARMDATEWEEKDAYSEL_DATE)
;;;1042       {
;;;1043         assert_param(IS_RTC_ALARM_DATE_WEEKDAY_DATE(sAlarm->AlarmDateWeekDay));
;;;1044       }
;;;1045       else
;;;1046       {
;;;1047         assert_param(IS_RTC_ALARM_DATE_WEEKDAY_WEEKDAY(sAlarm->AlarmDateWeekDay));
;;;1048       }
;;;1049   
;;;1050       tmpreg = (((uint32_t)RTC_ByteToBcd2(sAlarm->AlarmTime.Hours)   << RTC_ALRMAR_HU_Pos)  | \
;;;1051                 ((uint32_t)RTC_ByteToBcd2(sAlarm->AlarmTime.Minutes) << RTC_ALRMAR_MNU_Pos) | \
;;;1052                 ((uint32_t)RTC_ByteToBcd2(sAlarm->AlarmTime.Seconds))                       | \
;;;1053                 ((uint32_t)(sAlarm->AlarmTime.TimeFormat)            << RTC_TR_PM_Pos)      | \
;;;1054                 ((uint32_t)RTC_ByteToBcd2(sAlarm->AlarmDateWeekDay)  << RTC_ALRMAR_DU_Pos)  | \
;;;1055                 ((uint32_t)sAlarm->AlarmDateWeekDaySel)                                     | \
;;;1056                 ((uint32_t)sAlarm->AlarmMask));
;;;1057     }
;;;1058     else
;;;1059     {
;;;1060       if ((hrtc->Instance->CR & RTC_CR_FMT) != 0U)
;;;1061       {
;;;1062         assert_param(IS_RTC_HOUR12(RTC_Bcd2ToByte(sAlarm->AlarmTime.Hours)));
;;;1063         assert_param(IS_RTC_HOURFORMAT12(sAlarm->AlarmTime.TimeFormat));
;;;1064       }
;;;1065       else
;;;1066       {
;;;1067         sAlarm->AlarmTime.TimeFormat = 0x00U;
;;;1068         assert_param(IS_RTC_HOUR24(RTC_Bcd2ToByte(sAlarm->AlarmTime.Hours)));
;;;1069       }
;;;1070   
;;;1071       assert_param(IS_RTC_MINUTES(RTC_Bcd2ToByte(sAlarm->AlarmTime.Minutes)));
;;;1072       assert_param(IS_RTC_SECONDS(RTC_Bcd2ToByte(sAlarm->AlarmTime.Seconds)));
;;;1073   
;;;1074       if (sAlarm->AlarmDateWeekDaySel == RTC_ALARMDATEWEEKDAYSEL_DATE)
;;;1075       {
;;;1076         assert_param(IS_RTC_ALARM_DATE_WEEKDAY_DATE(RTC_Bcd2ToByte(sAlarm->AlarmDateWeekDay)));
;;;1077       }
;;;1078       else
;;;1079       {
;;;1080         assert_param(IS_RTC_ALARM_DATE_WEEKDAY_WEEKDAY(RTC_Bcd2ToByte(sAlarm->AlarmDateWeekDay)));
;;;1081       }
;;;1082   
;;;1083       tmpreg = (((uint32_t)(sAlarm->AlarmTime.Hours)      << RTC_ALRMAR_HU_Pos)  | \
;;;1084                 ((uint32_t)(sAlarm->AlarmTime.Minutes)    << RTC_ALRMAR_MNU_Pos) | \
;;;1085                 ((uint32_t) sAlarm->AlarmTime.Seconds)                           | \
;;;1086                 ((uint32_t)(sAlarm->AlarmTime.TimeFormat) << RTC_TR_PM_Pos)      | \
;;;1087                 ((uint32_t)(sAlarm->AlarmDateWeekDay)     << RTC_ALRMAR_DU_Pos)  | \
;;;1088                 ((uint32_t) sAlarm->AlarmDateWeekDaySel)                         | \
;;;1089                 ((uint32_t) sAlarm->AlarmMask));
;;;1090     }
;;;1091   
;;;1092     /* Store the Alarm subseconds configuration */
;;;1093     subsecondtmpreg = (uint32_t)((uint32_t)(sAlarm->AlarmTime.SubSeconds) | \
;;;1094                                  (uint32_t)(sAlarm->AlarmSubSecondMask));
;;;1095   
;;;1096     /* Disable the write protection for RTC registers */
;;;1097     __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
;;;1098   
;;;1099     /* Configure the Alarm register */
;;;1100     if (sAlarm->Alarm == RTC_ALARM_A)
;;;1101     {
;;;1102       /* Disable the Alarm A */
;;;1103       __HAL_RTC_ALARMA_DISABLE(hrtc);
;;;1104   
;;;1105       /* In case interrupt mode is used, the interrupt source must be disabled */
;;;1106       __HAL_RTC_ALARM_DISABLE_IT(hrtc, RTC_IT_ALRA);
;;;1107   
;;;1108       /* Clear the Alarm flag */
;;;1109       __HAL_RTC_ALARM_CLEAR_FLAG(hrtc, RTC_FLAG_ALRAF);
;;;1110   
;;;1111       /* Get tick */
;;;1112       tickstart = HAL_GetTick();
;;;1113   
;;;1114       /* Wait till RTC ALRAWF flag is set and if timeout is reached exit */
;;;1115       while (__HAL_RTC_ALARM_GET_FLAG(hrtc, RTC_FLAG_ALRAWF) == 0U)
;;;1116       {
;;;1117         if ((HAL_GetTick() - tickstart) > RTC_TIMEOUT_VALUE)
;;;1118         {
;;;1119           /* Enable the write protection for RTC registers */
;;;1120           __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
;;;1121   
;;;1122           hrtc->State = HAL_RTC_STATE_TIMEOUT;
;;;1123   
;;;1124           /* Process Unlocked */
;;;1125           __HAL_UNLOCK(hrtc);
;;;1126   
;;;1127           return HAL_TIMEOUT;
;;;1128         }
;;;1129       }
;;;1130   
;;;1131       hrtc->Instance->ALRMAR = (uint32_t)tmpreg;
;;;1132       /* Configure the Alarm A Subseconds register */
;;;1133       hrtc->Instance->ALRMASSR = subsecondtmpreg;
;;;1134       /* Configure the Alarm state: Enable Alarm */
;;;1135       __HAL_RTC_ALARMA_ENABLE(hrtc);
;;;1136     }
;;;1137     else
;;;1138     {
;;;1139       /* Disable the Alarm B */
;;;1140       __HAL_RTC_ALARMB_DISABLE(hrtc);
;;;1141   
;;;1142       /* In case interrupt mode is used, the interrupt source must be disabled */
;;;1143       __HAL_RTC_ALARM_DISABLE_IT(hrtc, RTC_IT_ALRB);
;;;1144   
;;;1145       /* Clear the Alarm flag */
;;;1146       __HAL_RTC_ALARM_CLEAR_FLAG(hrtc, RTC_FLAG_ALRBF);
;;;1147   
;;;1148       /* Get tick */
;;;1149       tickstart = HAL_GetTick();
;;;1150   
;;;1151       /* Wait till RTC ALRBWF flag is set and if timeout is reached exit */
;;;1152       while (__HAL_RTC_ALARM_GET_FLAG(hrtc, RTC_FLAG_ALRBWF) == 0U)
;;;1153       {
;;;1154         if ((HAL_GetTick() - tickstart) > RTC_TIMEOUT_VALUE)
;;;1155         {
;;;1156           /* Enable the write protection for RTC registers */
;;;1157           __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
;;;1158   
;;;1159           hrtc->State = HAL_RTC_STATE_TIMEOUT;
;;;1160   
;;;1161           /* Process Unlocked */
;;;1162           __HAL_UNLOCK(hrtc);
;;;1163   
;;;1164           return HAL_TIMEOUT;
;;;1165         }
;;;1166       }
;;;1167   
;;;1168       hrtc->Instance->ALRMBR = (uint32_t)tmpreg;
;;;1169       /* Configure the Alarm B Subseconds register */
;;;1170       hrtc->Instance->ALRMBSSR = subsecondtmpreg;
;;;1171       /* Configure the Alarm state: Enable Alarm */
;;;1172       __HAL_RTC_ALARMB_ENABLE(hrtc);
;;;1173     }
;;;1174   
;;;1175     /* Enable the write protection for RTC registers */
;;;1176     __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
;;;1177   
;;;1178     /* Change RTC state back to READY */
;;;1179     hrtc->State = HAL_RTC_STATE_READY;
;;;1180   
;;;1181     /* Process Unlocked */
;;;1182     __HAL_UNLOCK(hrtc);
;;;1183   
;;;1184     return HAL_OK;
;;;1185   }
00001a  e8bd87f0          POP      {r4-r10,pc}
                  |L18.30|
00001e  2001              MOVS     r0,#1                 ;1019
000020  7720              STRB     r0,[r4,#0x1c]         ;1019
000022  bf00              NOP                            ;1019
000024  2002              MOVS     r0,#2                 ;1022
000026  7760              STRB     r0,[r4,#0x1d]         ;1022
000028  bb46              CBNZ     r6,|L18.124|
00002a  6820              LDR      r0,[r4,#0]            ;1028
00002c  6880              LDR      r0,[r0,#8]            ;1028
00002e  f0000040          AND      r0,r0,#0x40           ;1028
000032  b100              CBZ      r0,|L18.54|
000034  e002              B        |L18.60|
                  |L18.54|
000036  2000              MOVS     r0,#0                 ;1035
000038  70e8              STRB     r0,[r5,#3]            ;1035
00003a  bf00              NOP                            ;1036
                  |L18.60|
00003c  69e8              LDR      r0,[r5,#0x1c]         ;1041
00003e  b900              CBNZ     r0,|L18.66|
000040  e000              B        |L18.68|
                  |L18.66|
000042  bf00              NOP                            ;1047
                  |L18.68|
000044  7828              LDRB     r0,[r5,#0]            ;1050
000046  f7fffffe          BL       RTC_ByteToBcd2
00004a  0403              LSLS     r3,r0,#16             ;1050
00004c  7868              LDRB     r0,[r5,#1]            ;1050
00004e  f7fffffe          BL       RTC_ByteToBcd2
000052  ea432300          ORR      r3,r3,r0,LSL #8       ;1050
000056  78a8              LDRB     r0,[r5,#2]            ;1050
000058  f7fffffe          BL       RTC_ByteToBcd2
00005c  4303              ORRS     r3,r3,r0              ;1050
00005e  78e8              LDRB     r0,[r5,#3]            ;1050
000060  ea435380          ORR      r3,r3,r0,LSL #22      ;1050
000064  f8950020          LDRB     r0,[r5,#0x20]         ;1050
000068  f7fffffe          BL       RTC_ByteToBcd2
00006c  ea436000          ORR      r0,r3,r0,LSL #24      ;1050
000070  69e9              LDR      r1,[r5,#0x1c]         ;1050
000072  4308              ORRS     r0,r0,r1              ;1050
000074  6969              LDR      r1,[r5,#0x14]         ;1050
000076  ea400801          ORR      r8,r0,r1              ;1050
00007a  e01f              B        |L18.188|
                  |L18.124|
00007c  6820              LDR      r0,[r4,#0]            ;1060
00007e  6880              LDR      r0,[r0,#8]            ;1060
000080  f0000040          AND      r0,r0,#0x40           ;1060
000084  b100              CBZ      r0,|L18.136|
000086  e002              B        |L18.142|
                  |L18.136|
000088  2000              MOVS     r0,#0                 ;1067
00008a  70e8              STRB     r0,[r5,#3]            ;1067
00008c  bf00              NOP                            ;1068
                  |L18.142|
00008e  69e8              LDR      r0,[r5,#0x1c]         ;1074
000090  b900              CBNZ     r0,|L18.148|
000092  e000              B        |L18.150|
                  |L18.148|
000094  bf00              NOP                            ;1080
                  |L18.150|
000096  7828              LDRB     r0,[r5,#0]            ;1083
000098  0400              LSLS     r0,r0,#16             ;1083
00009a  7869              LDRB     r1,[r5,#1]            ;1083
00009c  ea402001          ORR      r0,r0,r1,LSL #8       ;1083
0000a0  78a9              LDRB     r1,[r5,#2]            ;1083
0000a2  4308              ORRS     r0,r0,r1              ;1083
0000a4  78e9              LDRB     r1,[r5,#3]            ;1083
0000a6  ea405081          ORR      r0,r0,r1,LSL #22      ;1083
0000aa  f8951020          LDRB     r1,[r5,#0x20]         ;1083
0000ae  ea406001          ORR      r0,r0,r1,LSL #24      ;1083
0000b2  69e9              LDR      r1,[r5,#0x1c]         ;1083
0000b4  4308              ORRS     r0,r0,r1              ;1083
0000b6  6969              LDR      r1,[r5,#0x14]         ;1083
0000b8  ea400801          ORR      r8,r0,r1              ;1083
                  |L18.188|
0000bc  69a9              LDR      r1,[r5,#0x18]         ;1093
0000be  6868              LDR      r0,[r5,#4]            ;1093
0000c0  ea400901          ORR      r9,r0,r1              ;1093
0000c4  bf00              NOP                            ;1097
0000c6  20ca              MOVS     r0,#0xca              ;1097
0000c8  6821              LDR      r1,[r4,#0]            ;1097
0000ca  6248              STR      r0,[r1,#0x24]         ;1097
0000cc  2053              MOVS     r0,#0x53              ;1097
0000ce  6821              LDR      r1,[r4,#0]            ;1097
0000d0  6248              STR      r0,[r1,#0x24]         ;1097
0000d2  bf00              NOP                            ;1097
0000d4  6a68              LDR      r0,[r5,#0x24]         ;1100
0000d6  f5b07f80          CMP      r0,#0x100             ;1100
0000da  d13d              BNE      |L18.344|
0000dc  6820              LDR      r0,[r4,#0]            ;1103
0000de  6880              LDR      r0,[r0,#8]            ;1103
0000e0  f4207080          BIC      r0,r0,#0x100          ;1103
0000e4  6821              LDR      r1,[r4,#0]            ;1103
0000e6  6088              STR      r0,[r1,#8]            ;1103
0000e8  6820              LDR      r0,[r4,#0]            ;1106
0000ea  6880              LDR      r0,[r0,#8]            ;1106
0000ec  f4205080          BIC      r0,r0,#0x1000         ;1106
0000f0  6821              LDR      r1,[r4,#0]            ;1106
0000f2  6088              STR      r0,[r1,#8]            ;1106
0000f4  6820              LDR      r0,[r4,#0]            ;1109
0000f6  68c0              LDR      r0,[r0,#0xc]          ;1109
0000f8  f0000080          AND      r0,r0,#0x80           ;1109
0000fc  f46070c0          ORN      r0,r0,#0x180          ;1109
000100  6821              LDR      r1,[r4,#0]            ;1109
000102  60c8              STR      r0,[r1,#0xc]          ;1109
000104  f7fffffe          BL       HAL_GetTick
000108  4607              MOV      r7,r0                 ;1112
00010a  e012              B        |L18.306|
                  |L18.268|
00010c  f7fffffe          BL       HAL_GetTick
000110  1bc0              SUBS     r0,r0,r7              ;1117
000112  f5b07f7a          CMP      r0,#0x3e8             ;1117
000116  d90c              BLS      |L18.306|
000118  bf00              NOP                            ;1120
00011a  20ff              MOVS     r0,#0xff              ;1120
00011c  6821              LDR      r1,[r4,#0]            ;1120
00011e  6248              STR      r0,[r1,#0x24]         ;1120
000120  bf00              NOP                            ;1120
000122  2003              MOVS     r0,#3                 ;1122
000124  7760              STRB     r0,[r4,#0x1d]         ;1122
000126  bf00              NOP                            ;1125
000128  2000              MOVS     r0,#0                 ;1125
00012a  7720              STRB     r0,[r4,#0x1c]         ;1125
00012c  bf00              NOP                            ;1125
00012e  2003              MOVS     r0,#3                 ;1127
000130  e773              B        |L18.26|
                  |L18.306|
000132  6820              LDR      r0,[r4,#0]            ;1115
000134  68c0              LDR      r0,[r0,#0xc]          ;1115
000136  f0000001          AND      r0,r0,#1              ;1115
00013a  2800              CMP      r0,#0                 ;1115
00013c  d0e6              BEQ      |L18.268|
00013e  6820              LDR      r0,[r4,#0]            ;1131
000140  f8c0801c          STR      r8,[r0,#0x1c]         ;1131
000144  6820              LDR      r0,[r4,#0]            ;1133
000146  f8c09044          STR      r9,[r0,#0x44]         ;1133
00014a  6820              LDR      r0,[r4,#0]            ;1135
00014c  6880              LDR      r0,[r0,#8]            ;1135
00014e  f4407080          ORR      r0,r0,#0x100          ;1135
000152  6821              LDR      r1,[r4,#0]            ;1135
000154  6088              STR      r0,[r1,#8]            ;1135
000156  e03c              B        |L18.466|
                  |L18.344|
000158  6820              LDR      r0,[r4,#0]            ;1140
00015a  6880              LDR      r0,[r0,#8]            ;1140
00015c  f4207000          BIC      r0,r0,#0x200          ;1140
000160  6821              LDR      r1,[r4,#0]            ;1140
000162  6088              STR      r0,[r1,#8]            ;1140
000164  6820              LDR      r0,[r4,#0]            ;1143
000166  6880              LDR      r0,[r0,#8]            ;1143
000168  f4205000          BIC      r0,r0,#0x2000         ;1143
00016c  6821              LDR      r1,[r4,#0]            ;1143
00016e  6088              STR      r0,[r1,#8]            ;1143
000170  6820              LDR      r0,[r4,#0]            ;1146
000172  68c0              LDR      r0,[r0,#0xc]          ;1146
000174  f0000080          AND      r0,r0,#0x80           ;1146
000178  f4607020          ORN      r0,r0,#0x280          ;1146
00017c  6821              LDR      r1,[r4,#0]            ;1146
00017e  60c8              STR      r0,[r1,#0xc]          ;1146
000180  f7fffffe          BL       HAL_GetTick
000184  4607              MOV      r7,r0                 ;1149
000186  e012              B        |L18.430|
                  |L18.392|
000188  f7fffffe          BL       HAL_GetTick
00018c  1bc0              SUBS     r0,r0,r7              ;1154
00018e  f5b07f7a          CMP      r0,#0x3e8             ;1154
000192  d90c              BLS      |L18.430|
000194  bf00              NOP                            ;1157
000196  20ff              MOVS     r0,#0xff              ;1157
000198  6821              LDR      r1,[r4,#0]            ;1157
00019a  6248              STR      r0,[r1,#0x24]         ;1157
00019c  bf00              NOP                            ;1157
00019e  2003              MOVS     r0,#3                 ;1159
0001a0  7760              STRB     r0,[r4,#0x1d]         ;1159
0001a2  bf00              NOP                            ;1162
0001a4  2000              MOVS     r0,#0                 ;1162
0001a6  7720              STRB     r0,[r4,#0x1c]         ;1162
0001a8  bf00              NOP                            ;1162
0001aa  2003              MOVS     r0,#3                 ;1164
0001ac  e735              B        |L18.26|
                  |L18.430|
0001ae  6820              LDR      r0,[r4,#0]            ;1152
0001b0  68c0              LDR      r0,[r0,#0xc]          ;1152
0001b2  f3c00040          UBFX     r0,r0,#1,#1           ;1152
0001b6  2800              CMP      r0,#0                 ;1152
0001b8  d0e6              BEQ      |L18.392|
0001ba  6820              LDR      r0,[r4,#0]            ;1168
0001bc  f8c08020          STR      r8,[r0,#0x20]         ;1168
0001c0  6820              LDR      r0,[r4,#0]            ;1170
0001c2  f8c09048          STR      r9,[r0,#0x48]         ;1170
0001c6  6820              LDR      r0,[r4,#0]            ;1172
0001c8  6880              LDR      r0,[r0,#8]            ;1172
0001ca  f4407000          ORR      r0,r0,#0x200          ;1172
0001ce  6821              LDR      r1,[r4,#0]            ;1172
0001d0  6088              STR      r0,[r1,#8]            ;1172
                  |L18.466|
0001d2  bf00              NOP                            ;1176
0001d4  20ff              MOVS     r0,#0xff              ;1176
0001d6  6821              LDR      r1,[r4,#0]            ;1176
0001d8  6248              STR      r0,[r1,#0x24]         ;1176
0001da  bf00              NOP                            ;1176
0001dc  2001              MOVS     r0,#1                 ;1179
0001de  7760              STRB     r0,[r4,#0x1d]         ;1179
0001e0  bf00              NOP                            ;1182
0001e2  2000              MOVS     r0,#0                 ;1182
0001e4  7720              STRB     r0,[r4,#0x1c]         ;1182
0001e6  bf00              NOP                            ;1182
0001e8  bf00              NOP                            ;1184
0001ea  e716              B        |L18.26|
;;;1186   
                          ENDP


                          AREA ||i.HAL_RTC_SetAlarm_IT||, CODE, READONLY, ALIGN=2

                  HAL_RTC_SetAlarm_IT PROC
;;;1200     */
;;;1201   HAL_StatusTypeDef HAL_RTC_SetAlarm_IT(RTC_HandleTypeDef *hrtc, RTC_AlarmTypeDef *sAlarm, uint32_t Format)
000000  e92d41f8          PUSH     {r3-r8,lr}
;;;1202   {
000004  4603              MOV      r3,r0
000006  460c              MOV      r4,r1
000008  4615              MOV      r5,r2
;;;1203     __IO uint32_t count  = RTC_TIMEOUT_VALUE * (SystemCoreClock / 32U / 1000U);
00000a  4883              LDR      r0,|L19.536|
00000c  6800              LDR      r0,[r0,#0]  ; SystemCoreClock
00000e  0940              LSRS     r0,r0,#5
000010  f44f717a          MOV      r1,#0x3e8
000014  fbb0f0f1          UDIV     r0,r0,r1
000018  4348              MULS     r0,r1,r0
00001a  9000              STR      r0,[sp,#0]
;;;1204          uint32_t tmpreg = 0U;
00001c  2600              MOVS     r6,#0
;;;1205          uint32_t subsecondtmpreg = 0U;
00001e  2700              MOVS     r7,#0
;;;1206   
;;;1207     /* Check the parameters */
;;;1208     assert_param(IS_RTC_FORMAT(Format));
;;;1209     assert_param(IS_RTC_ALARM(sAlarm->Alarm));
;;;1210     assert_param(IS_RTC_ALARM_MASK(sAlarm->AlarmMask));
;;;1211     assert_param(IS_RTC_ALARM_DATE_WEEKDAY_SEL(sAlarm->AlarmDateWeekDaySel));
;;;1212     assert_param(IS_RTC_ALARM_SUB_SECOND_VALUE(sAlarm->AlarmTime.SubSeconds));
;;;1213     assert_param(IS_RTC_ALARM_SUB_SECOND_MASK(sAlarm->AlarmSubSecondMask));
;;;1214   
;;;1215     /* Process Locked */
;;;1216     __HAL_LOCK(hrtc);
000020  bf00              NOP      
000022  7f18              LDRB     r0,[r3,#0x1c]
000024  2801              CMP      r0,#1
000026  d102              BNE      |L19.46|
000028  2002              MOVS     r0,#2
                  |L19.42|
;;;1217   
;;;1218     /* Change RTC state to BUSY */
;;;1219     hrtc->State = HAL_RTC_STATE_BUSY;
;;;1220   
;;;1221     /* Check the data format (binary or BCD) and store the Alarm time and date
;;;1222        configuration accordingly */
;;;1223     if (Format == RTC_FORMAT_BIN)
;;;1224     {
;;;1225       if ((hrtc->Instance->CR & RTC_CR_FMT) != 0U)
;;;1226       {
;;;1227         assert_param(IS_RTC_HOUR12(sAlarm->AlarmTime.Hours));
;;;1228         assert_param(IS_RTC_HOURFORMAT12(sAlarm->AlarmTime.TimeFormat));
;;;1229       }
;;;1230       else
;;;1231       {
;;;1232         sAlarm->AlarmTime.TimeFormat = 0x00U;
;;;1233         assert_param(IS_RTC_HOUR24(sAlarm->AlarmTime.Hours));
;;;1234       }
;;;1235       assert_param(IS_RTC_MINUTES(sAlarm->AlarmTime.Minutes));
;;;1236       assert_param(IS_RTC_SECONDS(sAlarm->AlarmTime.Seconds));
;;;1237   
;;;1238       if (sAlarm->AlarmDateWeekDaySel == RTC_ALARMDATEWEEKDAYSEL_DATE)
;;;1239       {
;;;1240         assert_param(IS_RTC_ALARM_DATE_WEEKDAY_DATE(sAlarm->AlarmDateWeekDay));
;;;1241       }
;;;1242       else
;;;1243       {
;;;1244         assert_param(IS_RTC_ALARM_DATE_WEEKDAY_WEEKDAY(sAlarm->AlarmDateWeekDay));
;;;1245       }
;;;1246   
;;;1247       tmpreg = (((uint32_t)RTC_ByteToBcd2(sAlarm->AlarmTime.Hours)   << RTC_ALRMAR_HU_Pos)  | \
;;;1248                 ((uint32_t)RTC_ByteToBcd2(sAlarm->AlarmTime.Minutes) << RTC_ALRMAR_MNU_Pos) | \
;;;1249                 ((uint32_t)RTC_ByteToBcd2(sAlarm->AlarmTime.Seconds))                       | \
;;;1250                 ((uint32_t)(sAlarm->AlarmTime.TimeFormat)            << RTC_TR_PM_Pos)      | \
;;;1251                 ((uint32_t)RTC_ByteToBcd2(sAlarm->AlarmDateWeekDay)  << RTC_ALRMAR_DU_Pos)  | \
;;;1252                 ((uint32_t)sAlarm->AlarmDateWeekDaySel)                                     | \
;;;1253                 ((uint32_t)sAlarm->AlarmMask));
;;;1254     }
;;;1255     else
;;;1256     {
;;;1257       if ((hrtc->Instance->CR & RTC_CR_FMT) != 0U)
;;;1258       {
;;;1259         assert_param(IS_RTC_HOUR12(RTC_Bcd2ToByte(sAlarm->AlarmTime.Hours)));
;;;1260         assert_param(IS_RTC_HOURFORMAT12(sAlarm->AlarmTime.TimeFormat));
;;;1261       }
;;;1262       else
;;;1263       {
;;;1264         sAlarm->AlarmTime.TimeFormat = 0x00U;
;;;1265         assert_param(IS_RTC_HOUR24(RTC_Bcd2ToByte(sAlarm->AlarmTime.Hours)));
;;;1266       }
;;;1267   
;;;1268       assert_param(IS_RTC_MINUTES(RTC_Bcd2ToByte(sAlarm->AlarmTime.Minutes)));
;;;1269       assert_param(IS_RTC_SECONDS(RTC_Bcd2ToByte(sAlarm->AlarmTime.Seconds)));
;;;1270   
;;;1271       if (sAlarm->AlarmDateWeekDaySel == RTC_ALARMDATEWEEKDAYSEL_DATE)
;;;1272       {
;;;1273         assert_param(IS_RTC_ALARM_DATE_WEEKDAY_DATE(RTC_Bcd2ToByte(sAlarm->AlarmDateWeekDay)));
;;;1274       }
;;;1275       else
;;;1276       {
;;;1277         assert_param(IS_RTC_ALARM_DATE_WEEKDAY_WEEKDAY(RTC_Bcd2ToByte(sAlarm->AlarmDateWeekDay)));
;;;1278       }
;;;1279   
;;;1280       tmpreg = (((uint32_t)(sAlarm->AlarmTime.Hours)      << RTC_ALRMAR_HU_Pos)  | \
;;;1281                 ((uint32_t)(sAlarm->AlarmTime.Minutes)    << RTC_ALRMAR_MNU_Pos) | \
;;;1282                 ((uint32_t) sAlarm->AlarmTime.Seconds)                           | \
;;;1283                 ((uint32_t)(sAlarm->AlarmTime.TimeFormat) << RTC_TR_PM_Pos)      | \
;;;1284                 ((uint32_t)(sAlarm->AlarmDateWeekDay)     << RTC_ALRMAR_DU_Pos)  | \
;;;1285                 ((uint32_t) sAlarm->AlarmDateWeekDaySel)                         | \
;;;1286                 ((uint32_t) sAlarm->AlarmMask));
;;;1287     }
;;;1288   
;;;1289     /* Store the Alarm subseconds configuration */
;;;1290     subsecondtmpreg = (uint32_t)((uint32_t)(sAlarm->AlarmTime.SubSeconds) | \
;;;1291                                  (uint32_t)(sAlarm->AlarmSubSecondMask));
;;;1292   
;;;1293     /* Disable the write protection for RTC registers */
;;;1294     __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
;;;1295   
;;;1296     /* Configure the Alarm register */
;;;1297     if (sAlarm->Alarm == RTC_ALARM_A)
;;;1298     {
;;;1299       /* Disable the Alarm A */
;;;1300       __HAL_RTC_ALARMA_DISABLE(hrtc);
;;;1301   
;;;1302       /* Clear the Alarm flag */
;;;1303       __HAL_RTC_ALARM_CLEAR_FLAG(hrtc, RTC_FLAG_ALRAF);
;;;1304   
;;;1305       /* Wait till RTC ALRAWF flag is set and if timeout is reached exit */
;;;1306       do
;;;1307       {
;;;1308         count = count - 1U;
;;;1309         if (count == 0U)
;;;1310         {
;;;1311           /* Enable the write protection for RTC registers */
;;;1312           __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
;;;1313   
;;;1314           hrtc->State = HAL_RTC_STATE_TIMEOUT;
;;;1315   
;;;1316           /* Process Unlocked */
;;;1317           __HAL_UNLOCK(hrtc);
;;;1318   
;;;1319           return HAL_TIMEOUT;
;;;1320         }
;;;1321       } while (__HAL_RTC_ALARM_GET_FLAG(hrtc, RTC_FLAG_ALRAWF) == 0U);
;;;1322   
;;;1323       hrtc->Instance->ALRMAR = (uint32_t)tmpreg;
;;;1324       /* Configure the Alarm A Subseconds register */
;;;1325       hrtc->Instance->ALRMASSR = subsecondtmpreg;
;;;1326       /* Configure the Alarm state: Enable Alarm */
;;;1327       __HAL_RTC_ALARMA_ENABLE(hrtc);
;;;1328       /* Configure the Alarm interrupt */
;;;1329       __HAL_RTC_ALARM_ENABLE_IT(hrtc, RTC_IT_ALRA);
;;;1330     }
;;;1331     else
;;;1332     {
;;;1333       /* Disable the Alarm B */
;;;1334       __HAL_RTC_ALARMB_DISABLE(hrtc);
;;;1335   
;;;1336       /* Clear the Alarm flag */
;;;1337       __HAL_RTC_ALARM_CLEAR_FLAG(hrtc, RTC_FLAG_ALRBF);
;;;1338   
;;;1339       /* Reload the counter */
;;;1340       count = RTC_TIMEOUT_VALUE * (SystemCoreClock / 32U / 1000U);
;;;1341   
;;;1342       /* Wait till RTC ALRBWF flag is set and if timeout is reached exit */
;;;1343       do
;;;1344       {
;;;1345         count = count - 1U;
;;;1346         if (count == 0U)
;;;1347         {
;;;1348           /* Enable the write protection for RTC registers */
;;;1349           __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
;;;1350   
;;;1351           hrtc->State = HAL_RTC_STATE_TIMEOUT;
;;;1352   
;;;1353           /* Process Unlocked */
;;;1354           __HAL_UNLOCK(hrtc);
;;;1355   
;;;1356           return HAL_TIMEOUT;
;;;1357         }
;;;1358       } while (__HAL_RTC_ALARM_GET_FLAG(hrtc, RTC_FLAG_ALRBWF) == 0U);
;;;1359   
;;;1360       hrtc->Instance->ALRMBR = (uint32_t)tmpreg;
;;;1361       /* Configure the Alarm B Subseconds register */
;;;1362       hrtc->Instance->ALRMBSSR = subsecondtmpreg;
;;;1363       /* Configure the Alarm state: Enable Alarm */
;;;1364       __HAL_RTC_ALARMB_ENABLE(hrtc);
;;;1365       /* Configure the Alarm interrupt */
;;;1366       __HAL_RTC_ALARM_ENABLE_IT(hrtc, RTC_IT_ALRB);
;;;1367     }
;;;1368   
;;;1369     /* RTC Alarm Interrupt Configuration: EXTI configuration */
;;;1370     __HAL_RTC_ALARM_EXTI_ENABLE_IT();
;;;1371     __HAL_RTC_ALARM_EXTI_ENABLE_RISING_EDGE();
;;;1372   
;;;1373     /* Enable the write protection for RTC registers */
;;;1374     __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
;;;1375   
;;;1376     /* Change RTC state back to READY */
;;;1377     hrtc->State = HAL_RTC_STATE_READY;
;;;1378   
;;;1379     /* Process Unlocked */
;;;1380     __HAL_UNLOCK(hrtc);
;;;1381   
;;;1382     return HAL_OK;
;;;1383   }
00002a  e8bd81f8          POP      {r3-r8,pc}
                  |L19.46|
00002e  2001              MOVS     r0,#1                 ;1216
000030  7718              STRB     r0,[r3,#0x1c]         ;1216
000032  bf00              NOP                            ;1216
000034  2002              MOVS     r0,#2                 ;1219
000036  7758              STRB     r0,[r3,#0x1d]         ;1219
000038  bb55              CBNZ     r5,|L19.144|
00003a  6818              LDR      r0,[r3,#0]            ;1225
00003c  6880              LDR      r0,[r0,#8]            ;1225
00003e  f0000040          AND      r0,r0,#0x40           ;1225
000042  b100              CBZ      r0,|L19.70|
000044  e002              B        |L19.76|
                  |L19.70|
000046  2000              MOVS     r0,#0                 ;1232
000048  70e0              STRB     r0,[r4,#3]            ;1232
00004a  bf00              NOP                            ;1233
                  |L19.76|
00004c  69e0              LDR      r0,[r4,#0x1c]         ;1238
00004e  b900              CBNZ     r0,|L19.82|
000050  e000              B        |L19.84|
                  |L19.82|
000052  bf00              NOP                            ;1244
                  |L19.84|
000054  7820              LDRB     r0,[r4,#0]            ;1247
000056  f7fffffe          BL       RTC_ByteToBcd2
00005a  ea4f4800          LSL      r8,r0,#16             ;1247
00005e  7860              LDRB     r0,[r4,#1]            ;1247
000060  f7fffffe          BL       RTC_ByteToBcd2
000064  ea482800          ORR      r8,r8,r0,LSL #8       ;1247
000068  78a0              LDRB     r0,[r4,#2]            ;1247
00006a  f7fffffe          BL       RTC_ByteToBcd2
00006e  ea480800          ORR      r8,r8,r0              ;1247
000072  78e0              LDRB     r0,[r4,#3]            ;1247
000074  ea485880          ORR      r8,r8,r0,LSL #22      ;1247
000078  f8940020          LDRB     r0,[r4,#0x20]         ;1247
00007c  f7fffffe          BL       RTC_ByteToBcd2
000080  ea486000          ORR      r0,r8,r0,LSL #24      ;1247
000084  69e1              LDR      r1,[r4,#0x1c]         ;1247
000086  4308              ORRS     r0,r0,r1              ;1247
000088  6961              LDR      r1,[r4,#0x14]         ;1247
00008a  ea400601          ORR      r6,r0,r1              ;1247
00008e  e01f              B        |L19.208|
                  |L19.144|
000090  6818              LDR      r0,[r3,#0]            ;1257
000092  6880              LDR      r0,[r0,#8]            ;1257
000094  f0000040          AND      r0,r0,#0x40           ;1257
000098  b100              CBZ      r0,|L19.156|
00009a  e002              B        |L19.162|
                  |L19.156|
00009c  2000              MOVS     r0,#0                 ;1264
00009e  70e0              STRB     r0,[r4,#3]            ;1264
0000a0  bf00              NOP                            ;1265
                  |L19.162|
0000a2  69e0              LDR      r0,[r4,#0x1c]         ;1271
0000a4  b900              CBNZ     r0,|L19.168|
0000a6  e000              B        |L19.170|
                  |L19.168|
0000a8  bf00              NOP                            ;1277
                  |L19.170|
0000aa  7820              LDRB     r0,[r4,#0]            ;1280
0000ac  0400              LSLS     r0,r0,#16             ;1280
0000ae  7861              LDRB     r1,[r4,#1]            ;1280
0000b0  ea402001          ORR      r0,r0,r1,LSL #8       ;1280
0000b4  78a1              LDRB     r1,[r4,#2]            ;1280
0000b6  4308              ORRS     r0,r0,r1              ;1280
0000b8  78e1              LDRB     r1,[r4,#3]            ;1280
0000ba  ea405081          ORR      r0,r0,r1,LSL #22      ;1280
0000be  f8941020          LDRB     r1,[r4,#0x20]         ;1280
0000c2  ea406001          ORR      r0,r0,r1,LSL #24      ;1280
0000c6  69e1              LDR      r1,[r4,#0x1c]         ;1280
0000c8  4308              ORRS     r0,r0,r1              ;1280
0000ca  6961              LDR      r1,[r4,#0x14]         ;1280
0000cc  ea400601          ORR      r6,r0,r1              ;1280
                  |L19.208|
0000d0  69a1              LDR      r1,[r4,#0x18]         ;1290
0000d2  6860              LDR      r0,[r4,#4]            ;1290
0000d4  ea400701          ORR      r7,r0,r1              ;1290
0000d8  bf00              NOP                            ;1294
0000da  20ca              MOVS     r0,#0xca              ;1294
0000dc  6819              LDR      r1,[r3,#0]            ;1294
0000de  6248              STR      r0,[r1,#0x24]         ;1294
0000e0  2053              MOVS     r0,#0x53              ;1294
0000e2  6819              LDR      r1,[r3,#0]            ;1294
0000e4  6248              STR      r0,[r1,#0x24]         ;1294
0000e6  bf00              NOP                            ;1294
0000e8  6a60              LDR      r0,[r4,#0x24]         ;1297
0000ea  f5b07f80          CMP      r0,#0x100             ;1297
0000ee  d137              BNE      |L19.352|
0000f0  6818              LDR      r0,[r3,#0]            ;1300
0000f2  6880              LDR      r0,[r0,#8]            ;1300
0000f4  f4207080          BIC      r0,r0,#0x100          ;1300
0000f8  6819              LDR      r1,[r3,#0]            ;1300
0000fa  6088              STR      r0,[r1,#8]            ;1300
0000fc  6818              LDR      r0,[r3,#0]            ;1303
0000fe  68c0              LDR      r0,[r0,#0xc]          ;1303
000100  f0000080          AND      r0,r0,#0x80           ;1303
000104  f46070c0          ORN      r0,r0,#0x180          ;1303
000108  6819              LDR      r1,[r3,#0]            ;1303
00010a  60c8              STR      r0,[r1,#0xc]          ;1303
00010c  bf00              NOP                            ;1306
                  |L19.270|
00010e  9800              LDR      r0,[sp,#0]            ;1308
000110  1e40              SUBS     r0,r0,#1              ;1308
000112  9000              STR      r0,[sp,#0]            ;1308
000114  9800              LDR      r0,[sp,#0]            ;1309
000116  b960              CBNZ     r0,|L19.306|
000118  bf00              NOP                            ;1312
00011a  20ff              MOVS     r0,#0xff              ;1312
00011c  6819              LDR      r1,[r3,#0]            ;1312
00011e  6248              STR      r0,[r1,#0x24]         ;1312
000120  bf00              NOP                            ;1312
000122  2003              MOVS     r0,#3                 ;1314
000124  7758              STRB     r0,[r3,#0x1d]         ;1314
000126  bf00              NOP                            ;1317
000128  2000              MOVS     r0,#0                 ;1317
00012a  7718              STRB     r0,[r3,#0x1c]         ;1317
00012c  bf00              NOP                            ;1317
00012e  2003              MOVS     r0,#3                 ;1319
000130  e77b              B        |L19.42|
                  |L19.306|
000132  6818              LDR      r0,[r3,#0]            ;1321
000134  68c0              LDR      r0,[r0,#0xc]          ;1321
000136  f0000001          AND      r0,r0,#1              ;1321
00013a  2800              CMP      r0,#0                 ;1321
00013c  d0e7              BEQ      |L19.270|
00013e  6818              LDR      r0,[r3,#0]            ;1323
000140  61c6              STR      r6,[r0,#0x1c]         ;1323
000142  6818              LDR      r0,[r3,#0]            ;1325
000144  6447              STR      r7,[r0,#0x44]         ;1325
000146  6818              LDR      r0,[r3,#0]            ;1327
000148  6880              LDR      r0,[r0,#8]            ;1327
00014a  f4407080          ORR      r0,r0,#0x100          ;1327
00014e  6819              LDR      r1,[r3,#0]            ;1327
000150  6088              STR      r0,[r1,#8]            ;1327
000152  6818              LDR      r0,[r3,#0]            ;1329
000154  6880              LDR      r0,[r0,#8]            ;1329
000156  f4405080          ORR      r0,r0,#0x1000         ;1329
00015a  6819              LDR      r1,[r3,#0]            ;1329
00015c  6088              STR      r0,[r1,#8]            ;1329
00015e  e03f              B        |L19.480|
                  |L19.352|
000160  6818              LDR      r0,[r3,#0]            ;1334
000162  6880              LDR      r0,[r0,#8]            ;1334
000164  f4207000          BIC      r0,r0,#0x200          ;1334
000168  6819              LDR      r1,[r3,#0]            ;1334
00016a  6088              STR      r0,[r1,#8]            ;1334
00016c  6818              LDR      r0,[r3,#0]            ;1337
00016e  68c0              LDR      r0,[r0,#0xc]          ;1337
000170  f0000080          AND      r0,r0,#0x80           ;1337
000174  f4607020          ORN      r0,r0,#0x280          ;1337
000178  6819              LDR      r1,[r3,#0]            ;1337
00017a  60c8              STR      r0,[r1,#0xc]          ;1337
00017c  4826              LDR      r0,|L19.536|
00017e  6800              LDR      r0,[r0,#0]            ;1340  ; SystemCoreClock
000180  0940              LSRS     r0,r0,#5              ;1340
000182  f44f717a          MOV      r1,#0x3e8             ;1340
000186  fbb0f0f1          UDIV     r0,r0,r1              ;1340
00018a  4348              MULS     r0,r1,r0              ;1340
00018c  9000              STR      r0,[sp,#0]            ;1340
00018e  bf00              NOP                            ;1343
                  |L19.400|
000190  9800              LDR      r0,[sp,#0]            ;1345
000192  1e40              SUBS     r0,r0,#1              ;1345
000194  9000              STR      r0,[sp,#0]            ;1345
000196  9800              LDR      r0,[sp,#0]            ;1346
000198  b960              CBNZ     r0,|L19.436|
00019a  bf00              NOP                            ;1349
00019c  20ff              MOVS     r0,#0xff              ;1349
00019e  6819              LDR      r1,[r3,#0]            ;1349
0001a0  6248              STR      r0,[r1,#0x24]         ;1349
0001a2  bf00              NOP                            ;1349
0001a4  2003              MOVS     r0,#3                 ;1351
0001a6  7758              STRB     r0,[r3,#0x1d]         ;1351
0001a8  bf00              NOP                            ;1354
0001aa  2000              MOVS     r0,#0                 ;1354
0001ac  7718              STRB     r0,[r3,#0x1c]         ;1354
0001ae  bf00              NOP                            ;1354
0001b0  2003              MOVS     r0,#3                 ;1356
0001b2  e73a              B        |L19.42|
                  |L19.436|
0001b4  6818              LDR      r0,[r3,#0]            ;1358
0001b6  68c0              LDR      r0,[r0,#0xc]          ;1358
0001b8  f3c00040          UBFX     r0,r0,#1,#1           ;1358
0001bc  2800              CMP      r0,#0                 ;1358
0001be  d0e7              BEQ      |L19.400|
0001c0  6818              LDR      r0,[r3,#0]            ;1360
0001c2  6206              STR      r6,[r0,#0x20]         ;1360
0001c4  6818              LDR      r0,[r3,#0]            ;1362
0001c6  6487              STR      r7,[r0,#0x48]         ;1362
0001c8  6818              LDR      r0,[r3,#0]            ;1364
0001ca  6880              LDR      r0,[r0,#8]            ;1364
0001cc  f4407000          ORR      r0,r0,#0x200          ;1364
0001d0  6819              LDR      r1,[r3,#0]            ;1364
0001d2  6088              STR      r0,[r1,#8]            ;1364
0001d4  6818              LDR      r0,[r3,#0]            ;1366
0001d6  6880              LDR      r0,[r0,#8]            ;1366
0001d8  f4405000          ORR      r0,r0,#0x2000         ;1366
0001dc  6819              LDR      r1,[r3,#0]            ;1366
0001de  6088              STR      r0,[r1,#8]            ;1366
                  |L19.480|
0001e0  480e              LDR      r0,|L19.540|
0001e2  6800              LDR      r0,[r0,#0]            ;1370
0001e4  f4403000          ORR      r0,r0,#0x20000        ;1370
0001e8  490c              LDR      r1,|L19.540|
0001ea  6008              STR      r0,[r1,#0]            ;1370
0001ec  480b              LDR      r0,|L19.540|
0001ee  3008              ADDS     r0,r0,#8              ;1371
0001f0  6800              LDR      r0,[r0,#0]            ;1371
0001f2  f4403000          ORR      r0,r0,#0x20000        ;1371
0001f6  4909              LDR      r1,|L19.540|
0001f8  3108              ADDS     r1,r1,#8              ;1371
0001fa  6008              STR      r0,[r1,#0]            ;1371
0001fc  bf00              NOP                            ;1374
0001fe  20ff              MOVS     r0,#0xff              ;1374
000200  6819              LDR      r1,[r3,#0]            ;1374
000202  6248              STR      r0,[r1,#0x24]         ;1374
000204  bf00              NOP                            ;1374
000206  2001              MOVS     r0,#1                 ;1377
000208  7758              STRB     r0,[r3,#0x1d]         ;1377
00020a  bf00              NOP                            ;1380
00020c  2000              MOVS     r0,#0                 ;1380
00020e  7718              STRB     r0,[r3,#0x1c]         ;1380
000210  bf00              NOP                            ;1380
000212  bf00              NOP                            ;1382
000214  e709              B        |L19.42|
;;;1384   
                          ENDP

000216  0000              DCW      0x0000
                  |L19.536|
                          DCD      SystemCoreClock
                  |L19.540|
                          DCD      0x40013c00

                          AREA ||i.HAL_RTC_SetDate||, CODE, READONLY, ALIGN=2

                  HAL_RTC_SetDate PROC
;;;856      */
;;;857    HAL_StatusTypeDef HAL_RTC_SetDate(RTC_HandleTypeDef *hrtc, RTC_DateTypeDef *sDate, uint32_t Format)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;858    {
000004  4605              MOV      r5,r0
000006  460c              MOV      r4,r1
000008  4617              MOV      r7,r2
;;;859      uint32_t datetmpreg = 0U;
00000a  f04f0800          MOV      r8,#0
;;;860      HAL_StatusTypeDef status;
;;;861    
;;;862      /* Check the parameters */
;;;863      assert_param(IS_RTC_FORMAT(Format));
;;;864    
;;;865      /* Process Locked */
;;;866      __HAL_LOCK(hrtc);
00000e  bf00              NOP      
000010  7f28              LDRB     r0,[r5,#0x1c]
000012  2801              CMP      r0,#1
000014  d102              BNE      |L20.28|
000016  2002              MOVS     r0,#2
                  |L20.24|
;;;867    
;;;868      hrtc->State = HAL_RTC_STATE_BUSY;
;;;869    
;;;870      if ((Format == RTC_FORMAT_BIN) && ((sDate->Month & 0x10U) == 0x10U))
;;;871      {
;;;872        sDate->Month = (uint8_t)((sDate->Month & (uint8_t)~(0x10U)) + (uint8_t)0x0AU);
;;;873      }
;;;874    
;;;875      assert_param(IS_RTC_WEEKDAY(sDate->WeekDay));
;;;876    
;;;877      if (Format == RTC_FORMAT_BIN)
;;;878      {
;;;879        assert_param(IS_RTC_YEAR(sDate->Year));
;;;880        assert_param(IS_RTC_MONTH(sDate->Month));
;;;881        assert_param(IS_RTC_DATE(sDate->Date));
;;;882    
;;;883        datetmpreg = (((uint32_t)RTC_ByteToBcd2(sDate->Year)  << RTC_DR_YU_Pos) | \
;;;884                      ((uint32_t)RTC_ByteToBcd2(sDate->Month) << RTC_DR_MU_Pos) | \
;;;885                      ((uint32_t)RTC_ByteToBcd2(sDate->Date))                   | \
;;;886                      ((uint32_t)sDate->WeekDay               << RTC_DR_WDU_Pos));
;;;887      }
;;;888      else
;;;889      {
;;;890        assert_param(IS_RTC_YEAR(RTC_Bcd2ToByte(sDate->Year)));
;;;891        assert_param(IS_RTC_MONTH(RTC_Bcd2ToByte(sDate->Month)));
;;;892        assert_param(IS_RTC_DATE(RTC_Bcd2ToByte(sDate->Date)));
;;;893    
;;;894        datetmpreg = ((((uint32_t)sDate->Year)    << RTC_DR_YU_Pos) | \
;;;895                      (((uint32_t)sDate->Month)   << RTC_DR_MU_Pos) | \
;;;896                      ((uint32_t) sDate->Date)                      | \
;;;897                      (((uint32_t)sDate->WeekDay) << RTC_DR_WDU_Pos));
;;;898      }
;;;899    
;;;900      /* Disable the write protection for RTC registers */
;;;901      __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
;;;902    
;;;903      /* Enter Initialization mode */
;;;904      status = RTC_EnterInitMode(hrtc);
;;;905    
;;;906      if (status == HAL_OK)
;;;907      {
;;;908        /* Set the RTC_DR register */
;;;909        hrtc->Instance->DR = (uint32_t)(datetmpreg & RTC_DR_RESERVED_MASK);
;;;910    
;;;911        /* Exit Initialization mode */
;;;912        status = RTC_ExitInitMode(hrtc);
;;;913      }
;;;914    
;;;915      if (status == HAL_OK)
;;;916      {
;;;917        hrtc->State = HAL_RTC_STATE_READY;
;;;918      }
;;;919    
;;;920      /* Enable the write protection for RTC registers */
;;;921      __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
;;;922    
;;;923      /* Process Unlocked */
;;;924      __HAL_UNLOCK(hrtc);
;;;925    
;;;926      return status;
;;;927    }
000018  e8bd81f0          POP      {r4-r8,pc}
                  |L20.28|
00001c  2001              MOVS     r0,#1                 ;866
00001e  7728              STRB     r0,[r5,#0x1c]         ;866
000020  bf00              NOP                            ;866
000022  2002              MOVS     r0,#2                 ;868
000024  7768              STRB     r0,[r5,#0x1d]         ;868
000026  b94f              CBNZ     r7,|L20.60|
000028  7860              LDRB     r0,[r4,#1]            ;870
00002a  f0000010          AND      r0,r0,#0x10           ;870
00002e  2810              CMP      r0,#0x10              ;870
000030  d104              BNE      |L20.60|
000032  7860              LDRB     r0,[r4,#1]            ;872
000034  f00000ef          AND      r0,r0,#0xef           ;872
000038  300a              ADDS     r0,r0,#0xa            ;872
00003a  7060              STRB     r0,[r4,#1]            ;872
                  |L20.60|
00003c  b987              CBNZ     r7,|L20.96|
00003e  78e0              LDRB     r0,[r4,#3]            ;883
000040  f7fffffe          BL       RTC_ByteToBcd2
000044  0403              LSLS     r3,r0,#16             ;883
000046  7860              LDRB     r0,[r4,#1]            ;883
000048  f7fffffe          BL       RTC_ByteToBcd2
00004c  ea432300          ORR      r3,r3,r0,LSL #8       ;883
000050  78a0              LDRB     r0,[r4,#2]            ;883
000052  f7fffffe          BL       RTC_ByteToBcd2
000056  4303              ORRS     r3,r3,r0              ;883
000058  7820              LDRB     r0,[r4,#0]            ;883
00005a  ea433840          ORR      r8,r3,r0,LSL #13      ;883
00005e  e009              B        |L20.116|
                  |L20.96|
000060  78e0              LDRB     r0,[r4,#3]            ;894
000062  0400              LSLS     r0,r0,#16             ;894
000064  7861              LDRB     r1,[r4,#1]            ;894
000066  ea402001          ORR      r0,r0,r1,LSL #8       ;894
00006a  78a1              LDRB     r1,[r4,#2]            ;894
00006c  4308              ORRS     r0,r0,r1              ;894
00006e  7821              LDRB     r1,[r4,#0]            ;894
000070  ea403841          ORR      r8,r0,r1,LSL #13      ;894
                  |L20.116|
000074  bf00              NOP                            ;901
000076  20ca              MOVS     r0,#0xca              ;901
000078  6829              LDR      r1,[r5,#0]            ;901
00007a  6248              STR      r0,[r1,#0x24]         ;901
00007c  2053              MOVS     r0,#0x53              ;901
00007e  6829              LDR      r1,[r5,#0]            ;901
000080  6248              STR      r0,[r1,#0x24]         ;901
000082  bf00              NOP                            ;901
000084  4628              MOV      r0,r5                 ;904
000086  f7fffffe          BL       RTC_EnterInitMode
00008a  4606              MOV      r6,r0                 ;904
00008c  b946              CBNZ     r6,|L20.160|
00008e  480b              LDR      r0,|L20.188|
000090  ea080000          AND      r0,r8,r0              ;909
000094  6829              LDR      r1,[r5,#0]            ;909
000096  6048              STR      r0,[r1,#4]            ;909
000098  4628              MOV      r0,r5                 ;912
00009a  f7fffffe          BL       RTC_ExitInitMode
00009e  4606              MOV      r6,r0                 ;912
                  |L20.160|
0000a0  b90e              CBNZ     r6,|L20.166|
0000a2  2001              MOVS     r0,#1                 ;917
0000a4  7768              STRB     r0,[r5,#0x1d]         ;917
                  |L20.166|
0000a6  bf00              NOP                            ;921
0000a8  20ff              MOVS     r0,#0xff              ;921
0000aa  6829              LDR      r1,[r5,#0]            ;921
0000ac  6248              STR      r0,[r1,#0x24]         ;921
0000ae  bf00              NOP                            ;921
0000b0  bf00              NOP                            ;924
0000b2  2000              MOVS     r0,#0                 ;924
0000b4  7728              STRB     r0,[r5,#0x1c]         ;924
0000b6  bf00              NOP                            ;924
0000b8  4630              MOV      r0,r6                 ;926
0000ba  e7ad              B        |L20.24|
;;;928    
                          ENDP

                  |L20.188|
                          DCD      0x00ffff3f

                          AREA ||i.HAL_RTC_SetTime||, CODE, READONLY, ALIGN=2

                  HAL_RTC_SetTime PROC
;;;697      */
;;;698    HAL_StatusTypeDef HAL_RTC_SetTime(RTC_HandleTypeDef *hrtc, RTC_TimeTypeDef *sTime, uint32_t Format)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;699    {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4617              MOV      r7,r2
;;;700      uint32_t tmpreg = 0U;
00000a  f04f0800          MOV      r8,#0
;;;701      HAL_StatusTypeDef status;
;;;702    
;;;703      /* Check the parameters */
;;;704      assert_param(IS_RTC_FORMAT(Format));
;;;705      assert_param(IS_RTC_DAYLIGHT_SAVING(sTime->DayLightSaving));
;;;706      assert_param(IS_RTC_STORE_OPERATION(sTime->StoreOperation));
;;;707    
;;;708      /* Process Locked */
;;;709      __HAL_LOCK(hrtc);
00000e  bf00              NOP      
000010  7f20              LDRB     r0,[r4,#0x1c]
000012  2801              CMP      r0,#1
000014  d102              BNE      |L21.28|
000016  2002              MOVS     r0,#2
                  |L21.24|
;;;710    
;;;711      hrtc->State = HAL_RTC_STATE_BUSY;
;;;712    
;;;713      if (Format == RTC_FORMAT_BIN)
;;;714      {
;;;715        if ((hrtc->Instance->CR & RTC_CR_FMT) != 0U)
;;;716        {
;;;717          assert_param(IS_RTC_HOUR12(sTime->Hours));
;;;718          assert_param(IS_RTC_HOURFORMAT12(sTime->TimeFormat));
;;;719        }
;;;720        else
;;;721        {
;;;722          sTime->TimeFormat = 0x00U;
;;;723          assert_param(IS_RTC_HOUR24(sTime->Hours));
;;;724        }
;;;725        assert_param(IS_RTC_MINUTES(sTime->Minutes));
;;;726        assert_param(IS_RTC_SECONDS(sTime->Seconds));
;;;727    
;;;728        tmpreg = (uint32_t)(( (uint32_t)RTC_ByteToBcd2(sTime->Hours)   << RTC_TR_HU_Pos)  | \
;;;729                            ( (uint32_t)RTC_ByteToBcd2(sTime->Minutes) << RTC_TR_MNU_Pos) | \
;;;730                            ( (uint32_t)RTC_ByteToBcd2(sTime->Seconds))                   | \
;;;731                            (((uint32_t)sTime->TimeFormat)             << RTC_TR_PM_Pos));
;;;732      }
;;;733      else
;;;734      {
;;;735        if ((hrtc->Instance->CR & RTC_CR_FMT) != 0U)
;;;736        {
;;;737          assert_param(IS_RTC_HOUR12(RTC_Bcd2ToByte(sTime->Hours)));
;;;738          assert_param(IS_RTC_HOURFORMAT12(sTime->TimeFormat));
;;;739        }
;;;740        else
;;;741        {
;;;742          sTime->TimeFormat = 0x00U;
;;;743          assert_param(IS_RTC_HOUR24(RTC_Bcd2ToByte(sTime->Hours)));
;;;744        }
;;;745        assert_param(IS_RTC_MINUTES(RTC_Bcd2ToByte(sTime->Minutes)));
;;;746        assert_param(IS_RTC_SECONDS(RTC_Bcd2ToByte(sTime->Seconds)));
;;;747        tmpreg = (((uint32_t)(sTime->Hours)      << RTC_TR_HU_Pos)  | \
;;;748                  ((uint32_t)(sTime->Minutes)    << RTC_TR_MNU_Pos) | \
;;;749                  ((uint32_t) sTime->Seconds)                       | \
;;;750                  ((uint32_t)(sTime->TimeFormat) << RTC_TR_PM_Pos));
;;;751      }
;;;752    
;;;753      /* Disable the write protection for RTC registers */
;;;754      __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
;;;755    
;;;756      /* Enter Initialization mode */
;;;757      status = RTC_EnterInitMode(hrtc);
;;;758    
;;;759      if (status == HAL_OK)
;;;760      {
;;;761        /* Set the RTC_TR register */
;;;762        hrtc->Instance->TR = (uint32_t)(tmpreg & RTC_TR_RESERVED_MASK);
;;;763    
;;;764        /* Clear the bits to be configured (Deprecated. Use HAL_RTC_DST_xxx functions instead) */
;;;765        hrtc->Instance->CR &= (uint32_t)~RTC_CR_BKP;
;;;766    
;;;767        /* Configure the RTC_CR register (Deprecated. Use HAL_RTC_DST_xxx functions instead) */
;;;768        hrtc->Instance->CR |= (uint32_t)(sTime->DayLightSaving | sTime->StoreOperation);
;;;769    
;;;770        /* Exit Initialization mode */
;;;771        status = RTC_ExitInitMode(hrtc);
;;;772      }
;;;773    
;;;774      if (status == HAL_OK)
;;;775      {
;;;776        hrtc->State = HAL_RTC_STATE_READY;
;;;777      }
;;;778    
;;;779      /* Enable the write protection for RTC registers */
;;;780      __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
;;;781    
;;;782      /* Process Unlocked */
;;;783      __HAL_UNLOCK(hrtc);
;;;784    
;;;785      return status;
;;;786    }
000018  e8bd81f0          POP      {r4-r8,pc}
                  |L21.28|
00001c  2001              MOVS     r0,#1                 ;709
00001e  7720              STRB     r0,[r4,#0x1c]         ;709
000020  bf00              NOP                            ;709
000022  2002              MOVS     r0,#2                 ;711
000024  7760              STRB     r0,[r4,#0x1d]         ;711
000026  b9cf              CBNZ     r7,|L21.92|
000028  6820              LDR      r0,[r4,#0]            ;715
00002a  6880              LDR      r0,[r0,#8]            ;715
00002c  f0000040          AND      r0,r0,#0x40           ;715
000030  b100              CBZ      r0,|L21.52|
000032  e002              B        |L21.58|
                  |L21.52|
000034  2000              MOVS     r0,#0                 ;722
000036  70e8              STRB     r0,[r5,#3]            ;722
000038  bf00              NOP                            ;723
                  |L21.58|
00003a  7828              LDRB     r0,[r5,#0]            ;728
00003c  f7fffffe          BL       RTC_ByteToBcd2
000040  0403              LSLS     r3,r0,#16             ;728
000042  7868              LDRB     r0,[r5,#1]            ;728
000044  f7fffffe          BL       RTC_ByteToBcd2
000048  ea432300          ORR      r3,r3,r0,LSL #8       ;728
00004c  78a8              LDRB     r0,[r5,#2]            ;728
00004e  f7fffffe          BL       RTC_ByteToBcd2
000052  4303              ORRS     r3,r3,r0              ;728
000054  78e8              LDRB     r0,[r5,#3]            ;728
000056  ea435880          ORR      r8,r3,r0,LSL #22      ;728
00005a  e012              B        |L21.130|
                  |L21.92|
00005c  6820              LDR      r0,[r4,#0]            ;735
00005e  6880              LDR      r0,[r0,#8]            ;735
000060  f0000040          AND      r0,r0,#0x40           ;735
000064  b100              CBZ      r0,|L21.104|
000066  e002              B        |L21.110|
                  |L21.104|
000068  2000              MOVS     r0,#0                 ;742
00006a  70e8              STRB     r0,[r5,#3]            ;742
00006c  bf00              NOP                            ;743
                  |L21.110|
00006e  7828              LDRB     r0,[r5,#0]            ;747
000070  0400              LSLS     r0,r0,#16             ;747
000072  7869              LDRB     r1,[r5,#1]            ;747
000074  ea402001          ORR      r0,r0,r1,LSL #8       ;747
000078  78a9              LDRB     r1,[r5,#2]            ;747
00007a  4308              ORRS     r0,r0,r1              ;747
00007c  78e9              LDRB     r1,[r5,#3]            ;747
00007e  ea405881          ORR      r8,r0,r1,LSL #22      ;747
                  |L21.130|
000082  bf00              NOP                            ;754
000084  20ca              MOVS     r0,#0xca              ;754
000086  6821              LDR      r1,[r4,#0]            ;754
000088  6248              STR      r0,[r1,#0x24]         ;754
00008a  2053              MOVS     r0,#0x53              ;754
00008c  6821              LDR      r1,[r4,#0]            ;754
00008e  6248              STR      r0,[r1,#0x24]         ;754
000090  bf00              NOP                            ;754
000092  4620              MOV      r0,r4                 ;757
000094  f7fffffe          BL       RTC_EnterInitMode
000098  4606              MOV      r6,r0                 ;757
00009a  b9b6              CBNZ     r6,|L21.202|
00009c  4812              LDR      r0,|L21.232|
00009e  ea080000          AND      r0,r8,r0              ;762
0000a2  6821              LDR      r1,[r4,#0]            ;762
0000a4  6008              STR      r0,[r1,#0]            ;762
0000a6  6820              LDR      r0,[r4,#0]            ;765
0000a8  6880              LDR      r0,[r0,#8]            ;765
0000aa  f4202080          BIC      r0,r0,#0x40000        ;765
0000ae  6821              LDR      r1,[r4,#0]            ;765
0000b0  6088              STR      r0,[r1,#8]            ;765
0000b2  e9d50103          LDRD     r0,r1,[r5,#0xc]       ;768
0000b6  4308              ORRS     r0,r0,r1              ;768
0000b8  6821              LDR      r1,[r4,#0]            ;768
0000ba  6889              LDR      r1,[r1,#8]            ;768
0000bc  4308              ORRS     r0,r0,r1              ;768
0000be  6821              LDR      r1,[r4,#0]            ;768
0000c0  6088              STR      r0,[r1,#8]            ;768
0000c2  4620              MOV      r0,r4                 ;771
0000c4  f7fffffe          BL       RTC_ExitInitMode
0000c8  4606              MOV      r6,r0                 ;771
                  |L21.202|
0000ca  b90e              CBNZ     r6,|L21.208|
0000cc  2001              MOVS     r0,#1                 ;776
0000ce  7760              STRB     r0,[r4,#0x1d]         ;776
                  |L21.208|
0000d0  bf00              NOP                            ;780
0000d2  20ff              MOVS     r0,#0xff              ;780
0000d4  6821              LDR      r1,[r4,#0]            ;780
0000d6  6248              STR      r0,[r1,#0x24]         ;780
0000d8  bf00              NOP                            ;780
0000da  bf00              NOP                            ;783
0000dc  2000              MOVS     r0,#0                 ;783
0000de  7720              STRB     r0,[r4,#0x1c]         ;783
0000e0  bf00              NOP                            ;783
0000e2  4630              MOV      r0,r6                 ;785
0000e4  e798              B        |L21.24|
;;;787    
                          ENDP

0000e6  0000              DCW      0x0000
                  |L21.232|
                          DCD      0x007f7f7f

                          AREA ||i.HAL_RTC_WaitForSynchro||, CODE, READONLY, ALIGN=2

                  HAL_RTC_WaitForSynchro PROC
;;;1675     */
;;;1676   HAL_StatusTypeDef HAL_RTC_WaitForSynchro(RTC_HandleTypeDef *hrtc)
000000  b570              PUSH     {r4-r6,lr}
;;;1677   {
000002  4604              MOV      r4,r0
;;;1678     uint32_t tickstart = 0U;
000004  2500              MOVS     r5,#0
;;;1679   
;;;1680     /* Clear RSF flag, keep reserved bits at reset values (setting other flags has no effect) */
;;;1681     hrtc->Instance->ISR = ((uint32_t)(RTC_RSF_MASK & RTC_ISR_RESERVED_MASK));
000006  480b              LDR      r0,|L22.52|
000008  6821              LDR      r1,[r4,#0]
00000a  60c8              STR      r0,[r1,#0xc]
;;;1682   
;;;1683     /* Get tick */
;;;1684     tickstart = HAL_GetTick();
00000c  f7fffffe          BL       HAL_GetTick
000010  4605              MOV      r5,r0
;;;1685   
;;;1686     /* Wait the registers to be synchronised */
;;;1687     while ((hrtc->Instance->ISR & RTC_ISR_RSF) == 0U)
000012  e007              B        |L22.36|
                  |L22.20|
;;;1688     {
;;;1689       if ((HAL_GetTick() - tickstart) > RTC_TIMEOUT_VALUE)
000014  f7fffffe          BL       HAL_GetTick
000018  1b40              SUBS     r0,r0,r5
00001a  f5b07f7a          CMP      r0,#0x3e8
00001e  d901              BLS      |L22.36|
;;;1690       {
;;;1691         return HAL_TIMEOUT;
000020  2003              MOVS     r0,#3
                  |L22.34|
;;;1692       }
;;;1693     }
;;;1694   
;;;1695     return HAL_OK;
;;;1696   }
000022  bd70              POP      {r4-r6,pc}
                  |L22.36|
000024  6820              LDR      r0,[r4,#0]            ;1687
000026  68c0              LDR      r0,[r0,#0xc]          ;1687
000028  f0000020          AND      r0,r0,#0x20           ;1687
00002c  2800              CMP      r0,#0                 ;1687
00002e  d0f1              BEQ      |L22.20|
000030  2000              MOVS     r0,#0                 ;1695
000032  e7f6              B        |L22.34|
;;;1697   
                          ENDP

                  |L22.52|
                          DCD      0x00013f5f

                          AREA ||i.RTC_Bcd2ToByte||, CODE, READONLY, ALIGN=1

                  RTC_Bcd2ToByte PROC
;;;1891     */
;;;1892   uint8_t RTC_Bcd2ToByte(uint8_t number)
000000  4601              MOV      r1,r0
;;;1893   {
;;;1894     uint32_t tens = 0U;
000002  bf00              NOP      
;;;1895     tens = (((uint32_t)number & 0xF0U) >> 4U) * 10U;
000004  0908              LSRS     r0,r1,#4
000006  eb000080          ADD      r0,r0,r0,LSL #2
00000a  0042              LSLS     r2,r0,#1
;;;1896     return (uint8_t)(tens + ((uint32_t)number & 0x0FU));
00000c  f001000f          AND      r0,r1,#0xf
000010  4410              ADD      r0,r0,r2
000012  b2c0              UXTB     r0,r0
;;;1897   }
000014  4770              BX       lr
;;;1898   
                          ENDP


                          AREA ||i.RTC_ByteToBcd2||, CODE, READONLY, ALIGN=1

                  RTC_ByteToBcd2 PROC
;;;1873     */
;;;1874   uint8_t RTC_ByteToBcd2(uint8_t number)
000000  4601              MOV      r1,r0
;;;1875   {
;;;1876     uint32_t bcdhigh = 0U;
000002  2200              MOVS     r2,#0
;;;1877   
;;;1878     while (number >= 10U)
000004  e003              B        |L24.14|
                  |L24.6|
;;;1879     {
;;;1880       bcdhigh++;
000006  1c52              ADDS     r2,r2,#1
;;;1881       number -= 10U;
000008  f1a1000a          SUB      r0,r1,#0xa
00000c  b2c1              UXTB     r1,r0
                  |L24.14|
00000e  290a              CMP      r1,#0xa               ;1878
000010  d2f9              BCS      |L24.6|
;;;1882     }
;;;1883   
;;;1884     return ((uint8_t)(bcdhigh << 4U) | number);
000012  0710              LSLS     r0,r2,#28
000014  ea416010          ORR      r0,r1,r0,LSR #24
;;;1885   }
000018  4770              BX       lr
;;;1886   
                          ENDP


                          AREA ||i.RTC_EnterInitMode||, CODE, READONLY, ALIGN=1

                  RTC_EnterInitMode PROC
;;;1812     */
;;;1813   HAL_StatusTypeDef RTC_EnterInitMode(RTC_HandleTypeDef *hrtc)
000000  b570              PUSH     {r4-r6,lr}
;;;1814   {
000002  4604              MOV      r4,r0
;;;1815     uint32_t tickstart = 0U;
000004  2600              MOVS     r6,#0
;;;1816     HAL_StatusTypeDef status = HAL_OK;
000006  2500              MOVS     r5,#0
;;;1817   
;;;1818     /* Check that Initialization mode is not already set */
;;;1819     if (READ_BIT(hrtc->Instance->ISR, RTC_ISR_INITF) == 0U)
000008  6820              LDR      r0,[r4,#0]
00000a  68c0              LDR      r0,[r0,#0xc]
00000c  f0000040          AND      r0,r0,#0x40
000010  b9c8              CBNZ     r0,|L25.70|
;;;1820     {
;;;1821       /* Set INIT bit to enter Initialization mode */
;;;1822       SET_BIT(hrtc->Instance->ISR, RTC_ISR_INIT);
000012  6820              LDR      r0,[r4,#0]
000014  68c0              LDR      r0,[r0,#0xc]
000016  f0400080          ORR      r0,r0,#0x80
00001a  6821              LDR      r1,[r4,#0]
00001c  60c8              STR      r0,[r1,#0xc]
;;;1823   
;;;1824       /* Get tick */
;;;1825       tickstart = HAL_GetTick();
00001e  f7fffffe          BL       HAL_GetTick
000022  4606              MOV      r6,r0
;;;1826   
;;;1827       /* Wait till RTC is in INIT state and if timeout is reached exit */
;;;1828       while ((READ_BIT(hrtc->Instance->ISR, RTC_ISR_INITF) == 0U) && (status != HAL_ERROR))
000024  e008              B        |L25.56|
                  |L25.38|
;;;1829       {
;;;1830         if ((HAL_GetTick() - tickstart) > RTC_TIMEOUT_VALUE)
000026  f7fffffe          BL       HAL_GetTick
00002a  1b80              SUBS     r0,r0,r6
00002c  f5b07f7a          CMP      r0,#0x3e8
000030  d902              BLS      |L25.56|
;;;1831         {
;;;1832           /* Set RTC state */
;;;1833           hrtc->State = HAL_RTC_STATE_ERROR;
000032  2004              MOVS     r0,#4
000034  7760              STRB     r0,[r4,#0x1d]
;;;1834           status = HAL_ERROR;
000036  2501              MOVS     r5,#1
                  |L25.56|
000038  6820              LDR      r0,[r4,#0]            ;1828
00003a  68c0              LDR      r0,[r0,#0xc]          ;1828
00003c  f0000040          AND      r0,r0,#0x40           ;1828
000040  b908              CBNZ     r0,|L25.70|
000042  2d01              CMP      r5,#1                 ;1828
000044  d1ef              BNE      |L25.38|
                  |L25.70|
;;;1835         }
;;;1836       }
;;;1837     }
;;;1838   
;;;1839     return status;
000046  4628              MOV      r0,r5
;;;1840   }
000048  bd70              POP      {r4-r6,pc}
;;;1841   
                          ENDP


                          AREA ||i.RTC_ExitInitMode||, CODE, READONLY, ALIGN=1

                  RTC_ExitInitMode PROC
;;;1847     */
;;;1848   HAL_StatusTypeDef RTC_ExitInitMode(RTC_HandleTypeDef *hrtc)
000000  b570              PUSH     {r4-r6,lr}
;;;1849   {
000002  4604              MOV      r4,r0
;;;1850     HAL_StatusTypeDef status = HAL_OK;
000004  2500              MOVS     r5,#0
;;;1851   
;;;1852     /* Clear INIT bit to exit Initialization mode */
;;;1853     CLEAR_BIT(hrtc->Instance->ISR, RTC_ISR_INIT);
000006  6820              LDR      r0,[r4,#0]
000008  68c0              LDR      r0,[r0,#0xc]
00000a  f0200080          BIC      r0,r0,#0x80
00000e  6821              LDR      r1,[r4,#0]
000010  60c8              STR      r0,[r1,#0xc]
;;;1854   
;;;1855     /* If CR_BYPSHAD bit = 0, wait for synchro */
;;;1856     if (READ_BIT(hrtc->Instance->CR, RTC_CR_BYPSHAD) == 0U)
000012  6820              LDR      r0,[r4,#0]
000014  6880              LDR      r0,[r0,#8]
000016  f0000020          AND      r0,r0,#0x20
00001a  b930              CBNZ     r0,|L26.42|
;;;1857     {
;;;1858       if (HAL_RTC_WaitForSynchro(hrtc) != HAL_OK)
00001c  4620              MOV      r0,r4
00001e  f7fffffe          BL       HAL_RTC_WaitForSynchro
000022  b110              CBZ      r0,|L26.42|
;;;1859       {
;;;1860         /* Set RTC state */
;;;1861         hrtc->State = HAL_RTC_STATE_ERROR;
000024  2004              MOVS     r0,#4
000026  7760              STRB     r0,[r4,#0x1d]
;;;1862         status = HAL_ERROR;
000028  2501              MOVS     r5,#1
                  |L26.42|
;;;1863       }
;;;1864     }
;;;1865   
;;;1866     return status;
00002a  4628              MOV      r0,r5
;;;1867   }
00002c  bd70              POP      {r4-r6,pc}
;;;1868   
                          ENDP


;*** Start embedded assembler ***

#line 1 "../Drivers/STM32F4xx_HAL_Driver/Src/stm32f4xx_hal_rtc.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___19_stm32f4xx_hal_rtc_c_c7052556____REV16|
#line 208 "../Drivers/CMSIS/Include/cmsis_armcc.h"
|__asm___19_stm32f4xx_hal_rtc_c_c7052556____REV16| PROC
#line 209

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___19_stm32f4xx_hal_rtc_c_c7052556____REVSH|
#line 223
|__asm___19_stm32f4xx_hal_rtc_c_c7052556____REVSH| PROC
#line 224

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___19_stm32f4xx_hal_rtc_c_c7052556____RRX|
#line 410
|__asm___19_stm32f4xx_hal_rtc_c_c7052556____RRX| PROC
#line 411

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
