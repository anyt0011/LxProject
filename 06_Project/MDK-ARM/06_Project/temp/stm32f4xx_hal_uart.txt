; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: ArmCC [4d365d]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\06_project\stm32f4xx_hal_uart.o --asm_dir=.\06_Project\temp\ --list_dir=.\06_Project\temp\ --depend=.\06_project\stm32f4xx_hal_uart.d --cpu=Cortex-M4.fp.sp --apcs=interwork -O0 --diag_suppress=9931 -I../Core/Inc -I../Drivers/STM32F4xx_HAL_Driver/Inc -I../Drivers/STM32F4xx_HAL_Driver/Inc/Legacy -I../Drivers/CMSIS/Device/ST/STM32F4xx/Include -I../Drivers/CMSIS/Include -I../APP/Key/Inc -I../APP/Led/Inc -I../Middlewares/Third_Party/FreeRTOS/Source/include -I../Middlewares/Third_Party/FreeRTOS/Source/CMSIS_RTOS_V2 -I../Middlewares/Third_Party/FreeRTOS/Source/portable/RVDS/ARM_CM4F -I.\RTE\_06_Project -IF:\software\ARM_ENV\Keil\Packs\ARM\CMSIS\5.9.0\CMSIS\Core\Include -IF:\software\ARM_ENV\Keil\Packs\Keil\STM32F4xx_DFP\2.17.1\Drivers\CMSIS\Device\ST\STM32F4xx\Include -D__MICROLIB -D__UVISION_VERSION=538 -D_RTE_ -DSTM32F411xE -D_RTE_ -DUSE_HAL_DRIVER -DSTM32F411xE --omf_browse=.\06_project\stm32f4xx_hal_uart.crf ../Drivers/STM32F4xx_HAL_Driver/Src/stm32f4xx_hal_uart.c]
                          THUMB

                          AREA ||i.HAL_HalfDuplex_EnableReceiver||, CODE, READONLY, ALIGN=1

                  HAL_HalfDuplex_EnableReceiver PROC
;;;2870     */
;;;2871   HAL_StatusTypeDef HAL_HalfDuplex_EnableReceiver(UART_HandleTypeDef *huart)
000000  4601              MOV      r1,r0
;;;2872   {
;;;2873     uint32_t tmpreg = 0x00U;
000002  2200              MOVS     r2,#0
;;;2874   
;;;2875     /* Process Locked */
;;;2876     __HAL_LOCK(huart);
000004  bf00              NOP      
000006  f8910040          LDRB     r0,[r1,#0x40]
00000a  2801              CMP      r0,#1
00000c  d101              BNE      |L1.18|
00000e  2002              MOVS     r0,#2
                  |L1.16|
;;;2877   
;;;2878     huart->gState = HAL_UART_STATE_BUSY;
;;;2879   
;;;2880     /*-------------------------- USART CR1 Configuration -----------------------*/
;;;2881     tmpreg = huart->Instance->CR1;
;;;2882   
;;;2883     /* Clear TE and RE bits */
;;;2884     tmpreg &= (uint32_t)~((uint32_t)(USART_CR1_TE | USART_CR1_RE));
;;;2885   
;;;2886     /* Enable the USART's receive interface by setting the RE bit in the USART CR1 register */
;;;2887     tmpreg |= (uint32_t)USART_CR1_RE;
;;;2888   
;;;2889     /* Write to USART CR1 */
;;;2890     WRITE_REG(huart->Instance->CR1, (uint32_t)tmpreg);
;;;2891   
;;;2892     huart->gState = HAL_UART_STATE_READY;
;;;2893   
;;;2894     /* Process Unlocked */
;;;2895     __HAL_UNLOCK(huart);
;;;2896   
;;;2897     return HAL_OK;
;;;2898   }
000010  4770              BX       lr
                  |L1.18|
000012  2001              MOVS     r0,#1                 ;2876
000014  f8810040          STRB     r0,[r1,#0x40]         ;2876
000018  bf00              NOP                            ;2876
00001a  2024              MOVS     r0,#0x24              ;2878
00001c  f8810041          STRB     r0,[r1,#0x41]         ;2878
000020  6808              LDR      r0,[r1,#0]            ;2881
000022  68c2              LDR      r2,[r0,#0xc]          ;2881
000024  f022020c          BIC      r2,r2,#0xc            ;2884
000028  f0420204          ORR      r2,r2,#4              ;2887
00002c  6808              LDR      r0,[r1,#0]            ;2890
00002e  60c2              STR      r2,[r0,#0xc]          ;2890
000030  2020              MOVS     r0,#0x20              ;2892
000032  f8810041          STRB     r0,[r1,#0x41]         ;2892
000036  bf00              NOP                            ;2895
000038  2000              MOVS     r0,#0                 ;2895
00003a  f8810040          STRB     r0,[r1,#0x40]         ;2895
00003e  bf00              NOP                            ;2895
000040  bf00              NOP                            ;2897
000042  e7e5              B        |L1.16|
;;;2899   
                          ENDP


                          AREA ||i.HAL_HalfDuplex_EnableTransmitter||, CODE, READONLY, ALIGN=1

                  HAL_HalfDuplex_EnableTransmitter PROC
;;;2835     */
;;;2836   HAL_StatusTypeDef HAL_HalfDuplex_EnableTransmitter(UART_HandleTypeDef *huart)
000000  4601              MOV      r1,r0
;;;2837   {
;;;2838     uint32_t tmpreg = 0x00U;
000002  2200              MOVS     r2,#0
;;;2839   
;;;2840     /* Process Locked */
;;;2841     __HAL_LOCK(huart);
000004  bf00              NOP      
000006  f8910040          LDRB     r0,[r1,#0x40]
00000a  2801              CMP      r0,#1
00000c  d101              BNE      |L2.18|
00000e  2002              MOVS     r0,#2
                  |L2.16|
;;;2842   
;;;2843     huart->gState = HAL_UART_STATE_BUSY;
;;;2844   
;;;2845     /*-------------------------- USART CR1 Configuration -----------------------*/
;;;2846     tmpreg = huart->Instance->CR1;
;;;2847   
;;;2848     /* Clear TE and RE bits */
;;;2849     tmpreg &= (uint32_t)~((uint32_t)(USART_CR1_TE | USART_CR1_RE));
;;;2850   
;;;2851     /* Enable the USART's transmit interface by setting the TE bit in the USART CR1 register */
;;;2852     tmpreg |= (uint32_t)USART_CR1_TE;
;;;2853   
;;;2854     /* Write to USART CR1 */
;;;2855     WRITE_REG(huart->Instance->CR1, (uint32_t)tmpreg);
;;;2856   
;;;2857     huart->gState = HAL_UART_STATE_READY;
;;;2858   
;;;2859     /* Process Unlocked */
;;;2860     __HAL_UNLOCK(huart);
;;;2861   
;;;2862     return HAL_OK;
;;;2863   }
000010  4770              BX       lr
                  |L2.18|
000012  2001              MOVS     r0,#1                 ;2841
000014  f8810040          STRB     r0,[r1,#0x40]         ;2841
000018  bf00              NOP                            ;2841
00001a  2024              MOVS     r0,#0x24              ;2843
00001c  f8810041          STRB     r0,[r1,#0x41]         ;2843
000020  6808              LDR      r0,[r1,#0]            ;2846
000022  68c2              LDR      r2,[r0,#0xc]          ;2846
000024  f022020c          BIC      r2,r2,#0xc            ;2849
000028  f0420208          ORR      r2,r2,#8              ;2852
00002c  6808              LDR      r0,[r1,#0]            ;2855
00002e  60c2              STR      r2,[r0,#0xc]          ;2855
000030  2020              MOVS     r0,#0x20              ;2857
000032  f8810041          STRB     r0,[r1,#0x41]         ;2857
000036  bf00              NOP                            ;2860
000038  2000              MOVS     r0,#0                 ;2860
00003a  f8810040          STRB     r0,[r1,#0x40]         ;2860
00003e  bf00              NOP                            ;2860
000040  bf00              NOP                            ;2862
000042  e7e5              B        |L2.16|
;;;2864   
                          ENDP


                          AREA ||i.HAL_HalfDuplex_Init||, CODE, READONLY, ALIGN=1

                  HAL_HalfDuplex_Init PROC
;;;434      */
;;;435    HAL_StatusTypeDef HAL_HalfDuplex_Init(UART_HandleTypeDef *huart)
000000  b510              PUSH     {r4,lr}
;;;436    {
000002  4604              MOV      r4,r0
;;;437      /* Check the UART handle allocation */
;;;438      if (huart == NULL)
000004  b90c              CBNZ     r4,|L3.10|
;;;439      {
;;;440        return HAL_ERROR;
000006  2001              MOVS     r0,#1
                  |L3.8|
;;;441      }
;;;442    
;;;443      /* Check the parameters */
;;;444      assert_param(IS_UART_HALFDUPLEX_INSTANCE(huart->Instance));
;;;445      assert_param(IS_UART_WORD_LENGTH(huart->Init.WordLength));
;;;446      assert_param(IS_UART_OVERSAMPLING(huart->Init.OverSampling));
;;;447    
;;;448      if (huart->gState == HAL_UART_STATE_RESET)
;;;449      {
;;;450        /* Allocate lock resource and initialize it */
;;;451        huart->Lock = HAL_UNLOCKED;
;;;452    
;;;453    #if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
;;;454        UART_InitCallbacksToDefault(huart);
;;;455    
;;;456        if (huart->MspInitCallback == NULL)
;;;457        {
;;;458          huart->MspInitCallback = HAL_UART_MspInit;
;;;459        }
;;;460    
;;;461        /* Init the low level hardware */
;;;462        huart->MspInitCallback(huart);
;;;463    #else
;;;464        /* Init the low level hardware : GPIO, CLOCK */
;;;465        HAL_UART_MspInit(huart);
;;;466    #endif /* (USE_HAL_UART_REGISTER_CALLBACKS) */
;;;467      }
;;;468    
;;;469      huart->gState = HAL_UART_STATE_BUSY;
;;;470    
;;;471      /* Disable the peripheral */
;;;472      __HAL_UART_DISABLE(huart);
;;;473    
;;;474      /* Set the UART Communication parameters */
;;;475      UART_SetConfig(huart);
;;;476    
;;;477      /* In half-duplex mode, the following bits must be kept cleared:
;;;478         - LINEN and CLKEN bits in the USART_CR2 register,
;;;479         - SCEN and IREN bits in the USART_CR3 register.*/
;;;480      CLEAR_BIT(huart->Instance->CR2, (USART_CR2_LINEN | USART_CR2_CLKEN));
;;;481      CLEAR_BIT(huart->Instance->CR3, (USART_CR3_IREN | USART_CR3_SCEN));
;;;482    
;;;483      /* Enable the Half-Duplex mode by setting the HDSEL bit in the CR3 register */
;;;484      SET_BIT(huart->Instance->CR3, USART_CR3_HDSEL);
;;;485    
;;;486      /* Enable the peripheral */
;;;487      __HAL_UART_ENABLE(huart);
;;;488    
;;;489      /* Initialize the UART state*/
;;;490      huart->ErrorCode = HAL_UART_ERROR_NONE;
;;;491      huart->gState = HAL_UART_STATE_READY;
;;;492      huart->RxState = HAL_UART_STATE_READY;
;;;493      huart->RxEventType = HAL_UART_RXEVENT_TC;
;;;494    
;;;495      return HAL_OK;
;;;496    }
000008  bd10              POP      {r4,pc}
                  |L3.10|
00000a  f8940041          LDRB     r0,[r4,#0x41]         ;448
00000e  b928              CBNZ     r0,|L3.28|
000010  2000              MOVS     r0,#0                 ;451
000012  f8840040          STRB     r0,[r4,#0x40]         ;451
000016  4620              MOV      r0,r4                 ;465
000018  f7fffffe          BL       HAL_UART_MspInit
                  |L3.28|
00001c  2024              MOVS     r0,#0x24              ;469
00001e  f8840041          STRB     r0,[r4,#0x41]         ;469
000022  6820              LDR      r0,[r4,#0]            ;472
000024  68c0              LDR      r0,[r0,#0xc]          ;472
000026  f4205000          BIC      r0,r0,#0x2000         ;472
00002a  6821              LDR      r1,[r4,#0]            ;472
00002c  60c8              STR      r0,[r1,#0xc]          ;472
00002e  4620              MOV      r0,r4                 ;475
000030  f7fffffe          BL       UART_SetConfig
000034  6820              LDR      r0,[r4,#0]            ;480
000036  6900              LDR      r0,[r0,#0x10]         ;480
000038  f4204090          BIC      r0,r0,#0x4800         ;480
00003c  6821              LDR      r1,[r4,#0]            ;480
00003e  6108              STR      r0,[r1,#0x10]         ;480
000040  6820              LDR      r0,[r4,#0]            ;481
000042  6940              LDR      r0,[r0,#0x14]         ;481
000044  f0200022          BIC      r0,r0,#0x22           ;481
000048  6821              LDR      r1,[r4,#0]            ;481
00004a  6148              STR      r0,[r1,#0x14]         ;481
00004c  6820              LDR      r0,[r4,#0]            ;484
00004e  6940              LDR      r0,[r0,#0x14]         ;484
000050  f0400008          ORR      r0,r0,#8              ;484
000054  6821              LDR      r1,[r4,#0]            ;484
000056  6148              STR      r0,[r1,#0x14]         ;484
000058  6820              LDR      r0,[r4,#0]            ;487
00005a  68c0              LDR      r0,[r0,#0xc]          ;487
00005c  f4405000          ORR      r0,r0,#0x2000         ;487
000060  6821              LDR      r1,[r4,#0]            ;487
000062  60c8              STR      r0,[r1,#0xc]          ;487
000064  2000              MOVS     r0,#0                 ;490
000066  6460              STR      r0,[r4,#0x44]         ;490
000068  2020              MOVS     r0,#0x20              ;491
00006a  f8840041          STRB     r0,[r4,#0x41]         ;491
00006e  f8840042          STRB     r0,[r4,#0x42]         ;492
000072  2000              MOVS     r0,#0                 ;493
000074  6360              STR      r0,[r4,#0x34]         ;493
000076  bf00              NOP                            ;495
000078  e7c6              B        |L3.8|
;;;497    
                          ENDP


                          AREA ||i.HAL_LIN_Init||, CODE, READONLY, ALIGN=1

                  HAL_LIN_Init PROC
;;;508      */
;;;509    HAL_StatusTypeDef HAL_LIN_Init(UART_HandleTypeDef *huart, uint32_t BreakDetectLength)
000000  b570              PUSH     {r4-r6,lr}
;;;510    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;511      /* Check the UART handle allocation */
;;;512      if (huart == NULL)
000006  b90c              CBNZ     r4,|L4.12|
;;;513      {
;;;514        return HAL_ERROR;
000008  2001              MOVS     r0,#1
                  |L4.10|
;;;515      }
;;;516    
;;;517      /* Check the LIN UART instance */
;;;518      assert_param(IS_UART_LIN_INSTANCE(huart->Instance));
;;;519    
;;;520      /* Check the Break detection length parameter */
;;;521      assert_param(IS_UART_LIN_BREAK_DETECT_LENGTH(BreakDetectLength));
;;;522      assert_param(IS_UART_LIN_WORD_LENGTH(huart->Init.WordLength));
;;;523      assert_param(IS_UART_LIN_OVERSAMPLING(huart->Init.OverSampling));
;;;524    
;;;525      if (huart->gState == HAL_UART_STATE_RESET)
;;;526      {
;;;527        /* Allocate lock resource and initialize it */
;;;528        huart->Lock = HAL_UNLOCKED;
;;;529    
;;;530    #if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
;;;531        UART_InitCallbacksToDefault(huart);
;;;532    
;;;533        if (huart->MspInitCallback == NULL)
;;;534        {
;;;535          huart->MspInitCallback = HAL_UART_MspInit;
;;;536        }
;;;537    
;;;538        /* Init the low level hardware */
;;;539        huart->MspInitCallback(huart);
;;;540    #else
;;;541        /* Init the low level hardware : GPIO, CLOCK */
;;;542        HAL_UART_MspInit(huart);
;;;543    #endif /* (USE_HAL_UART_REGISTER_CALLBACKS) */
;;;544      }
;;;545    
;;;546      huart->gState = HAL_UART_STATE_BUSY;
;;;547    
;;;548      /* Disable the peripheral */
;;;549      __HAL_UART_DISABLE(huart);
;;;550    
;;;551      /* Set the UART Communication parameters */
;;;552      UART_SetConfig(huart);
;;;553    
;;;554      /* In LIN mode, the following bits must be kept cleared:
;;;555         - CLKEN bits in the USART_CR2 register,
;;;556         - SCEN, HDSEL and IREN bits in the USART_CR3 register.*/
;;;557      CLEAR_BIT(huart->Instance->CR2, (USART_CR2_CLKEN));
;;;558      CLEAR_BIT(huart->Instance->CR3, (USART_CR3_HDSEL | USART_CR3_IREN | USART_CR3_SCEN));
;;;559    
;;;560      /* Enable the LIN mode by setting the LINEN bit in the CR2 register */
;;;561      SET_BIT(huart->Instance->CR2, USART_CR2_LINEN);
;;;562    
;;;563      /* Set the USART LIN Break detection length. */
;;;564      CLEAR_BIT(huart->Instance->CR2, USART_CR2_LBDL);
;;;565      SET_BIT(huart->Instance->CR2, BreakDetectLength);
;;;566    
;;;567      /* Enable the peripheral */
;;;568      __HAL_UART_ENABLE(huart);
;;;569    
;;;570      /* Initialize the UART state*/
;;;571      huart->ErrorCode = HAL_UART_ERROR_NONE;
;;;572      huart->gState = HAL_UART_STATE_READY;
;;;573      huart->RxState = HAL_UART_STATE_READY;
;;;574      huart->RxEventType = HAL_UART_RXEVENT_TC;
;;;575    
;;;576      return HAL_OK;
;;;577    }
00000a  bd70              POP      {r4-r6,pc}
                  |L4.12|
00000c  f8940041          LDRB     r0,[r4,#0x41]         ;525
000010  b928              CBNZ     r0,|L4.30|
000012  2000              MOVS     r0,#0                 ;528
000014  f8840040          STRB     r0,[r4,#0x40]         ;528
000018  4620              MOV      r0,r4                 ;542
00001a  f7fffffe          BL       HAL_UART_MspInit
                  |L4.30|
00001e  2024              MOVS     r0,#0x24              ;546
000020  f8840041          STRB     r0,[r4,#0x41]         ;546
000024  6820              LDR      r0,[r4,#0]            ;549
000026  68c0              LDR      r0,[r0,#0xc]          ;549
000028  f4205000          BIC      r0,r0,#0x2000         ;549
00002c  6821              LDR      r1,[r4,#0]            ;549
00002e  60c8              STR      r0,[r1,#0xc]          ;549
000030  4620              MOV      r0,r4                 ;552
000032  f7fffffe          BL       UART_SetConfig
000036  6820              LDR      r0,[r4,#0]            ;557
000038  6900              LDR      r0,[r0,#0x10]         ;557
00003a  f4206000          BIC      r0,r0,#0x800          ;557
00003e  6821              LDR      r1,[r4,#0]            ;557
000040  6108              STR      r0,[r1,#0x10]         ;557
000042  6820              LDR      r0,[r4,#0]            ;558
000044  6940              LDR      r0,[r0,#0x14]         ;558
000046  f020002a          BIC      r0,r0,#0x2a           ;558
00004a  6821              LDR      r1,[r4,#0]            ;558
00004c  6148              STR      r0,[r1,#0x14]         ;558
00004e  6820              LDR      r0,[r4,#0]            ;561
000050  6900              LDR      r0,[r0,#0x10]         ;561
000052  f4404080          ORR      r0,r0,#0x4000         ;561
000056  6821              LDR      r1,[r4,#0]            ;561
000058  6108              STR      r0,[r1,#0x10]         ;561
00005a  6820              LDR      r0,[r4,#0]            ;564
00005c  6900              LDR      r0,[r0,#0x10]         ;564
00005e  f0200020          BIC      r0,r0,#0x20           ;564
000062  6821              LDR      r1,[r4,#0]            ;564
000064  6108              STR      r0,[r1,#0x10]         ;564
000066  6820              LDR      r0,[r4,#0]            ;565
000068  6900              LDR      r0,[r0,#0x10]         ;565
00006a  4328              ORRS     r0,r0,r5              ;565
00006c  6821              LDR      r1,[r4,#0]            ;565
00006e  6108              STR      r0,[r1,#0x10]         ;565
000070  6820              LDR      r0,[r4,#0]            ;568
000072  68c0              LDR      r0,[r0,#0xc]          ;568
000074  f4405000          ORR      r0,r0,#0x2000         ;568
000078  6821              LDR      r1,[r4,#0]            ;568
00007a  60c8              STR      r0,[r1,#0xc]          ;568
00007c  2000              MOVS     r0,#0                 ;571
00007e  6460              STR      r0,[r4,#0x44]         ;571
000080  2020              MOVS     r0,#0x20              ;572
000082  f8840041          STRB     r0,[r4,#0x41]         ;572
000086  f8840042          STRB     r0,[r4,#0x42]         ;573
00008a  2000              MOVS     r0,#0                 ;574
00008c  6360              STR      r0,[r4,#0x34]         ;574
00008e  bf00              NOP                            ;576
000090  e7bb              B        |L4.10|
;;;578    
                          ENDP


                          AREA ||i.HAL_LIN_SendBreak||, CODE, READONLY, ALIGN=1

                  HAL_LIN_SendBreak PROC
;;;2752     */
;;;2753   HAL_StatusTypeDef HAL_LIN_SendBreak(UART_HandleTypeDef *huart)
000000  4601              MOV      r1,r0
;;;2754   {
;;;2755     /* Check the parameters */
;;;2756     assert_param(IS_UART_INSTANCE(huart->Instance));
;;;2757   
;;;2758     /* Process Locked */
;;;2759     __HAL_LOCK(huart);
000002  bf00              NOP      
000004  f8910040          LDRB     r0,[r1,#0x40]
000008  2801              CMP      r0,#1
00000a  d101              BNE      |L5.16|
00000c  2002              MOVS     r0,#2
                  |L5.14|
;;;2760   
;;;2761     huart->gState = HAL_UART_STATE_BUSY;
;;;2762   
;;;2763     /* Send break characters */
;;;2764     ATOMIC_SET_BIT(huart->Instance->CR1, USART_CR1_SBK);
;;;2765   
;;;2766     huart->gState = HAL_UART_STATE_READY;
;;;2767   
;;;2768     /* Process Unlocked */
;;;2769     __HAL_UNLOCK(huart);
;;;2770   
;;;2771     return HAL_OK;
;;;2772   }
00000e  4770              BX       lr
                  |L5.16|
000010  2001              MOVS     r0,#1                 ;2759
000012  f8810040          STRB     r0,[r1,#0x40]         ;2759
000016  bf00              NOP                            ;2759
000018  2024              MOVS     r0,#0x24              ;2761
00001a  f8810041          STRB     r0,[r1,#0x41]         ;2761
00001e  bf00              NOP                            ;2764
000020  bf00              NOP                            ;2764
                  |L5.34|
000022  680a              LDR      r2,[r1,#0]            ;2764
000024  320c              ADDS     r2,r2,#0xc            ;2764
000026  e8522f00          LDREX    r2,[r2,#0]            ;2764
00002a  f0420001          ORR      r0,r2,#1              ;2764
00002e  680a              LDR      r2,[r1,#0]            ;2764
000030  320c              ADDS     r2,r2,#0xc            ;2764
000032  e8420300          STREX    r3,r0,[r2,#0]         ;2764
000036  2b00              CMP      r3,#0                 ;2764
000038  d1f3              BNE      |L5.34|
00003a  bf00              NOP                            ;2764
00003c  2020              MOVS     r0,#0x20              ;2766
00003e  f8810041          STRB     r0,[r1,#0x41]         ;2766
000042  bf00              NOP                            ;2769
000044  2000              MOVS     r0,#0                 ;2769
000046  f8810040          STRB     r0,[r1,#0x40]         ;2769
00004a  bf00              NOP                            ;2769
00004c  bf00              NOP                            ;2771
00004e  e7de              B        |L5.14|
;;;2773   
                          ENDP


                          AREA ||i.HAL_MultiProcessor_EnterMuteMode||, CODE, READONLY, ALIGN=1

                  HAL_MultiProcessor_EnterMuteMode PROC
;;;2779     */
;;;2780   HAL_StatusTypeDef HAL_MultiProcessor_EnterMuteMode(UART_HandleTypeDef *huart)
000000  4601              MOV      r1,r0
;;;2781   {
;;;2782     /* Check the parameters */
;;;2783     assert_param(IS_UART_INSTANCE(huart->Instance));
;;;2784   
;;;2785     /* Process Locked */
;;;2786     __HAL_LOCK(huart);
000002  bf00              NOP      
000004  f8910040          LDRB     r0,[r1,#0x40]
000008  2801              CMP      r0,#1
00000a  d101              BNE      |L6.16|
00000c  2002              MOVS     r0,#2
                  |L6.14|
;;;2787   
;;;2788     huart->gState = HAL_UART_STATE_BUSY;
;;;2789   
;;;2790     /* Enable the USART mute mode  by setting the RWU bit in the CR1 register */
;;;2791     ATOMIC_SET_BIT(huart->Instance->CR1, USART_CR1_RWU);
;;;2792   
;;;2793     huart->gState = HAL_UART_STATE_READY;
;;;2794     huart->RxEventType = HAL_UART_RXEVENT_TC;
;;;2795   
;;;2796     /* Process Unlocked */
;;;2797     __HAL_UNLOCK(huart);
;;;2798   
;;;2799     return HAL_OK;
;;;2800   }
00000e  4770              BX       lr
                  |L6.16|
000010  2001              MOVS     r0,#1                 ;2786
000012  f8810040          STRB     r0,[r1,#0x40]         ;2786
000016  bf00              NOP                            ;2786
000018  2024              MOVS     r0,#0x24              ;2788
00001a  f8810041          STRB     r0,[r1,#0x41]         ;2788
00001e  bf00              NOP                            ;2791
000020  bf00              NOP                            ;2791
                  |L6.34|
000022  680a              LDR      r2,[r1,#0]            ;2791
000024  320c              ADDS     r2,r2,#0xc            ;2791
000026  e8522f00          LDREX    r2,[r2,#0]            ;2791
00002a  f0420002          ORR      r0,r2,#2              ;2791
00002e  680a              LDR      r2,[r1,#0]            ;2791
000030  320c              ADDS     r2,r2,#0xc            ;2791
000032  e8420300          STREX    r3,r0,[r2,#0]         ;2791
000036  2b00              CMP      r3,#0                 ;2791
000038  d1f3              BNE      |L6.34|
00003a  bf00              NOP                            ;2791
00003c  2020              MOVS     r0,#0x20              ;2793
00003e  f8810041          STRB     r0,[r1,#0x41]         ;2793
000042  2000              MOVS     r0,#0                 ;2794
000044  6348              STR      r0,[r1,#0x34]         ;2794
000046  bf00              NOP                            ;2797
000048  f8810040          STRB     r0,[r1,#0x40]         ;2797
00004c  bf00              NOP                            ;2797
00004e  bf00              NOP                            ;2799
000050  e7dd              B        |L6.14|
;;;2801   
                          ENDP


                          AREA ||i.HAL_MultiProcessor_ExitMuteMode||, CODE, READONLY, ALIGN=1

                  HAL_MultiProcessor_ExitMuteMode PROC
;;;2807     */
;;;2808   HAL_StatusTypeDef HAL_MultiProcessor_ExitMuteMode(UART_HandleTypeDef *huart)
000000  4601              MOV      r1,r0
;;;2809   {
;;;2810     /* Check the parameters */
;;;2811     assert_param(IS_UART_INSTANCE(huart->Instance));
;;;2812   
;;;2813     /* Process Locked */
;;;2814     __HAL_LOCK(huart);
000002  bf00              NOP      
000004  f8910040          LDRB     r0,[r1,#0x40]
000008  2801              CMP      r0,#1
00000a  d101              BNE      |L7.16|
00000c  2002              MOVS     r0,#2
                  |L7.14|
;;;2815   
;;;2816     huart->gState = HAL_UART_STATE_BUSY;
;;;2817   
;;;2818     /* Disable the USART mute mode by clearing the RWU bit in the CR1 register */
;;;2819     ATOMIC_CLEAR_BIT(huart->Instance->CR1, USART_CR1_RWU);
;;;2820   
;;;2821     huart->gState = HAL_UART_STATE_READY;
;;;2822     huart->RxEventType = HAL_UART_RXEVENT_TC;
;;;2823   
;;;2824     /* Process Unlocked */
;;;2825     __HAL_UNLOCK(huart);
;;;2826   
;;;2827     return HAL_OK;
;;;2828   }
00000e  4770              BX       lr
                  |L7.16|
000010  2001              MOVS     r0,#1                 ;2814
000012  f8810040          STRB     r0,[r1,#0x40]         ;2814
000016  bf00              NOP                            ;2814
000018  2024              MOVS     r0,#0x24              ;2816
00001a  f8810041          STRB     r0,[r1,#0x41]         ;2816
00001e  bf00              NOP                            ;2819
000020  bf00              NOP                            ;2819
                  |L7.34|
000022  680a              LDR      r2,[r1,#0]            ;2819
000024  320c              ADDS     r2,r2,#0xc            ;2819
000026  e8522f00          LDREX    r2,[r2,#0]            ;2819
00002a  f0220002          BIC      r0,r2,#2              ;2819
00002e  680a              LDR      r2,[r1,#0]            ;2819
000030  320c              ADDS     r2,r2,#0xc            ;2819
000032  e8420300          STREX    r3,r0,[r2,#0]         ;2819
000036  2b00              CMP      r3,#0                 ;2819
000038  d1f3              BNE      |L7.34|
00003a  bf00              NOP                            ;2819
00003c  2020              MOVS     r0,#0x20              ;2821
00003e  f8810041          STRB     r0,[r1,#0x41]         ;2821
000042  2000              MOVS     r0,#0                 ;2822
000044  6348              STR      r0,[r1,#0x34]         ;2822
000046  bf00              NOP                            ;2825
000048  f8810040          STRB     r0,[r1,#0x40]         ;2825
00004c  bf00              NOP                            ;2825
00004e  bf00              NOP                            ;2827
000050  e7dd              B        |L7.14|
;;;2829   
                          ENDP


                          AREA ||i.HAL_MultiProcessor_Init||, CODE, READONLY, ALIGN=1

                  HAL_MultiProcessor_Init PROC
;;;590      */
;;;591    HAL_StatusTypeDef HAL_MultiProcessor_Init(UART_HandleTypeDef *huart, uint8_t Address, uint32_t WakeUpMethod)
000000  b570              PUSH     {r4-r6,lr}
;;;592    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
000006  4616              MOV      r6,r2
;;;593      /* Check the UART handle allocation */
;;;594      if (huart == NULL)
000008  b90c              CBNZ     r4,|L8.14|
;;;595      {
;;;596        return HAL_ERROR;
00000a  2001              MOVS     r0,#1
                  |L8.12|
;;;597      }
;;;598    
;;;599      /* Check the parameters */
;;;600      assert_param(IS_UART_INSTANCE(huart->Instance));
;;;601    
;;;602      /* Check the Address & wake up method parameters */
;;;603      assert_param(IS_UART_WAKEUPMETHOD(WakeUpMethod));
;;;604      assert_param(IS_UART_ADDRESS(Address));
;;;605      assert_param(IS_UART_WORD_LENGTH(huart->Init.WordLength));
;;;606      assert_param(IS_UART_OVERSAMPLING(huart->Init.OverSampling));
;;;607    
;;;608      if (huart->gState == HAL_UART_STATE_RESET)
;;;609      {
;;;610        /* Allocate lock resource and initialize it */
;;;611        huart->Lock = HAL_UNLOCKED;
;;;612    
;;;613    #if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
;;;614        UART_InitCallbacksToDefault(huart);
;;;615    
;;;616        if (huart->MspInitCallback == NULL)
;;;617        {
;;;618          huart->MspInitCallback = HAL_UART_MspInit;
;;;619        }
;;;620    
;;;621        /* Init the low level hardware */
;;;622        huart->MspInitCallback(huart);
;;;623    #else
;;;624        /* Init the low level hardware : GPIO, CLOCK */
;;;625        HAL_UART_MspInit(huart);
;;;626    #endif /* (USE_HAL_UART_REGISTER_CALLBACKS) */
;;;627      }
;;;628    
;;;629      huart->gState = HAL_UART_STATE_BUSY;
;;;630    
;;;631      /* Disable the peripheral */
;;;632      __HAL_UART_DISABLE(huart);
;;;633    
;;;634      /* Set the UART Communication parameters */
;;;635      UART_SetConfig(huart);
;;;636    
;;;637      /* In Multi-Processor mode, the following bits must be kept cleared:
;;;638         - LINEN and CLKEN bits in the USART_CR2 register,
;;;639         - SCEN, HDSEL and IREN  bits in the USART_CR3 register */
;;;640      CLEAR_BIT(huart->Instance->CR2, (USART_CR2_LINEN | USART_CR2_CLKEN));
;;;641      CLEAR_BIT(huart->Instance->CR3, (USART_CR3_SCEN | USART_CR3_HDSEL | USART_CR3_IREN));
;;;642    
;;;643      /* Set the USART address node */
;;;644      CLEAR_BIT(huart->Instance->CR2, USART_CR2_ADD);
;;;645      SET_BIT(huart->Instance->CR2, Address);
;;;646    
;;;647      /* Set the wake up method by setting the WAKE bit in the CR1 register */
;;;648      CLEAR_BIT(huart->Instance->CR1, USART_CR1_WAKE);
;;;649      SET_BIT(huart->Instance->CR1, WakeUpMethod);
;;;650    
;;;651      /* Enable the peripheral */
;;;652      __HAL_UART_ENABLE(huart);
;;;653    
;;;654      /* Initialize the UART state */
;;;655      huart->ErrorCode = HAL_UART_ERROR_NONE;
;;;656      huart->gState = HAL_UART_STATE_READY;
;;;657      huart->RxState = HAL_UART_STATE_READY;
;;;658      huart->RxEventType = HAL_UART_RXEVENT_TC;
;;;659    
;;;660      return HAL_OK;
;;;661    }
00000c  bd70              POP      {r4-r6,pc}
                  |L8.14|
00000e  f8940041          LDRB     r0,[r4,#0x41]         ;608
000012  b928              CBNZ     r0,|L8.32|
000014  2000              MOVS     r0,#0                 ;611
000016  f8840040          STRB     r0,[r4,#0x40]         ;611
00001a  4620              MOV      r0,r4                 ;625
00001c  f7fffffe          BL       HAL_UART_MspInit
                  |L8.32|
000020  2024              MOVS     r0,#0x24              ;629
000022  f8840041          STRB     r0,[r4,#0x41]         ;629
000026  6820              LDR      r0,[r4,#0]            ;632
000028  68c0              LDR      r0,[r0,#0xc]          ;632
00002a  f4205000          BIC      r0,r0,#0x2000         ;632
00002e  6821              LDR      r1,[r4,#0]            ;632
000030  60c8              STR      r0,[r1,#0xc]          ;632
000032  4620              MOV      r0,r4                 ;635
000034  f7fffffe          BL       UART_SetConfig
000038  6820              LDR      r0,[r4,#0]            ;640
00003a  6900              LDR      r0,[r0,#0x10]         ;640
00003c  f4204090          BIC      r0,r0,#0x4800         ;640
000040  6821              LDR      r1,[r4,#0]            ;640
000042  6108              STR      r0,[r1,#0x10]         ;640
000044  6820              LDR      r0,[r4,#0]            ;641
000046  6940              LDR      r0,[r0,#0x14]         ;641
000048  f020002a          BIC      r0,r0,#0x2a           ;641
00004c  6821              LDR      r1,[r4,#0]            ;641
00004e  6148              STR      r0,[r1,#0x14]         ;641
000050  6820              LDR      r0,[r4,#0]            ;644
000052  6900              LDR      r0,[r0,#0x10]         ;644
000054  f020000f          BIC      r0,r0,#0xf            ;644
000058  6821              LDR      r1,[r4,#0]            ;644
00005a  6108              STR      r0,[r1,#0x10]         ;644
00005c  6820              LDR      r0,[r4,#0]            ;645
00005e  6900              LDR      r0,[r0,#0x10]         ;645
000060  4328              ORRS     r0,r0,r5              ;645
000062  6821              LDR      r1,[r4,#0]            ;645
000064  6108              STR      r0,[r1,#0x10]         ;645
000066  6820              LDR      r0,[r4,#0]            ;648
000068  68c0              LDR      r0,[r0,#0xc]          ;648
00006a  f4206000          BIC      r0,r0,#0x800          ;648
00006e  6821              LDR      r1,[r4,#0]            ;648
000070  60c8              STR      r0,[r1,#0xc]          ;648
000072  6820              LDR      r0,[r4,#0]            ;649
000074  68c0              LDR      r0,[r0,#0xc]          ;649
000076  4330              ORRS     r0,r0,r6              ;649
000078  6821              LDR      r1,[r4,#0]            ;649
00007a  60c8              STR      r0,[r1,#0xc]          ;649
00007c  6820              LDR      r0,[r4,#0]            ;652
00007e  68c0              LDR      r0,[r0,#0xc]          ;652
000080  f4405000          ORR      r0,r0,#0x2000         ;652
000084  6821              LDR      r1,[r4,#0]            ;652
000086  60c8              STR      r0,[r1,#0xc]          ;652
000088  2000              MOVS     r0,#0                 ;655
00008a  6460              STR      r0,[r4,#0x44]         ;655
00008c  2020              MOVS     r0,#0x20              ;656
00008e  f8840041          STRB     r0,[r4,#0x41]         ;656
000092  f8840042          STRB     r0,[r4,#0x42]         ;657
000096  2000              MOVS     r0,#0                 ;658
000098  6360              STR      r0,[r4,#0x34]         ;658
00009a  bf00              NOP                            ;660
00009c  e7b6              B        |L8.12|
;;;662    
                          ENDP


                          AREA ||i.HAL_UARTEx_GetRxEventType||, CODE, READONLY, ALIGN=1

                  HAL_UARTEx_GetRxEventType PROC
;;;1840     */
;;;1841   HAL_UART_RxEventTypeTypeDef HAL_UARTEx_GetRxEventType(UART_HandleTypeDef *huart)
000000  4601              MOV      r1,r0
;;;1842   {
;;;1843     /* Return Rx Event type value, as stored in UART handle */
;;;1844     return(huart->RxEventType);
000002  6b48              LDR      r0,[r1,#0x34]
;;;1845   }
000004  4770              BX       lr
;;;1846   
                          ENDP


                          AREA ||i.HAL_UARTEx_ReceiveToIdle||, CODE, READONLY, ALIGN=1

                  HAL_UARTEx_ReceiveToIdle PROC
;;;1587     */
;;;1588   HAL_StatusTypeDef HAL_UARTEx_ReceiveToIdle(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size, uint16_t *RxLen,
000000  e92d4ff8          PUSH     {r3-r11,lr}
;;;1589                                              uint32_t Timeout)
;;;1590   {
000004  4604              MOV      r4,r0
000006  460f              MOV      r7,r1
000008  4690              MOV      r8,r2
00000a  461d              MOV      r5,r3
00000c  f8dda028          LDR      r10,[sp,#0x28]
;;;1591     uint8_t  *pdata8bits;
;;;1592     uint16_t *pdata16bits;
;;;1593     uint32_t tickstart;
;;;1594   
;;;1595     /* Check that a Rx process is not already ongoing */
;;;1596     if (huart->RxState == HAL_UART_STATE_READY)
000010  f8940042          LDRB     r0,[r4,#0x42]
000014  2820              CMP      r0,#0x20
000016  d178              BNE      |L10.266|
;;;1597     {
;;;1598       if ((pData == NULL) || (Size == 0U))
000018  b117              CBZ      r7,|L10.32|
00001a  f1b80f00          CMP      r8,#0
00001e  d102              BNE      |L10.38|
                  |L10.32|
;;;1599       {
;;;1600         return  HAL_ERROR;
000020  2001              MOVS     r0,#1
                  |L10.34|
;;;1601       }
;;;1602   
;;;1603       huart->ErrorCode = HAL_UART_ERROR_NONE;
;;;1604       huart->RxState = HAL_UART_STATE_BUSY_RX;
;;;1605       huart->ReceptionType = HAL_UART_RECEPTION_TOIDLE;
;;;1606       huart->RxEventType = HAL_UART_RXEVENT_TC;
;;;1607   
;;;1608       /* Init tickstart for timeout management */
;;;1609       tickstart = HAL_GetTick();
;;;1610   
;;;1611       huart->RxXferSize  = Size;
;;;1612       huart->RxXferCount = Size;
;;;1613   
;;;1614       /* In case of 9bits/No Parity transfer, pRxData needs to be handled as a uint16_t pointer */
;;;1615       if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
;;;1616       {
;;;1617         pdata8bits  = NULL;
;;;1618         pdata16bits = (uint16_t *) pData;
;;;1619       }
;;;1620       else
;;;1621       {
;;;1622         pdata8bits  = pData;
;;;1623         pdata16bits = NULL;
;;;1624       }
;;;1625   
;;;1626       /* Initialize output number of received elements */
;;;1627       *RxLen = 0U;
;;;1628   
;;;1629       /* as long as data have to be received */
;;;1630       while (huart->RxXferCount > 0U)
;;;1631       {
;;;1632         /* Check if IDLE flag is set */
;;;1633         if (__HAL_UART_GET_FLAG(huart, UART_FLAG_IDLE))
;;;1634         {
;;;1635           /* Clear IDLE flag in ISR */
;;;1636           __HAL_UART_CLEAR_IDLEFLAG(huart);
;;;1637   
;;;1638           /* If Set, but no data ever received, clear flag without exiting loop */
;;;1639           /* If Set, and data has already been received, this means Idle Event is valid : End reception */
;;;1640           if (*RxLen > 0U)
;;;1641           {
;;;1642             huart->RxEventType = HAL_UART_RXEVENT_IDLE;
;;;1643             huart->RxState = HAL_UART_STATE_READY;
;;;1644   
;;;1645             return HAL_OK;
;;;1646           }
;;;1647         }
;;;1648   
;;;1649         /* Check if RXNE flag is set */
;;;1650         if (__HAL_UART_GET_FLAG(huart, UART_FLAG_RXNE))
;;;1651         {
;;;1652           if (pdata8bits == NULL)
;;;1653           {
;;;1654             *pdata16bits = (uint16_t)(huart->Instance->DR & (uint16_t)0x01FF);
;;;1655             pdata16bits++;
;;;1656           }
;;;1657           else
;;;1658           {
;;;1659             if ((huart->Init.WordLength == UART_WORDLENGTH_9B) || ((huart->Init.WordLength == UART_WORDLENGTH_8B) && (huart->Init.Parity == UART_PARITY_NONE)))
;;;1660             {
;;;1661               *pdata8bits = (uint8_t)(huart->Instance->DR & (uint8_t)0x00FF);
;;;1662             }
;;;1663             else
;;;1664             {
;;;1665               *pdata8bits = (uint8_t)(huart->Instance->DR & (uint8_t)0x007F);
;;;1666             }
;;;1667   
;;;1668             pdata8bits++;
;;;1669           }
;;;1670           /* Increment number of received elements */
;;;1671           *RxLen += 1U;
;;;1672           huart->RxXferCount--;
;;;1673         }
;;;1674   
;;;1675         /* Check for the Timeout */
;;;1676         if (Timeout != HAL_MAX_DELAY)
;;;1677         {
;;;1678           if (((HAL_GetTick() - tickstart) > Timeout) || (Timeout == 0U))
;;;1679           {
;;;1680             huart->RxState = HAL_UART_STATE_READY;
;;;1681   
;;;1682             return HAL_TIMEOUT;
;;;1683           }
;;;1684         }
;;;1685       }
;;;1686   
;;;1687       /* Set number of received elements in output parameter : RxLen */
;;;1688       *RxLen = huart->RxXferSize - huart->RxXferCount;
;;;1689       /* At end of Rx process, restore huart->RxState to Ready */
;;;1690       huart->RxState = HAL_UART_STATE_READY;
;;;1691   
;;;1692       return HAL_OK;
;;;1693     }
;;;1694     else
;;;1695     {
;;;1696       return HAL_BUSY;
;;;1697     }
;;;1698   }
000022  e8bd8ff8          POP      {r3-r11,pc}
                  |L10.38|
000026  2000              MOVS     r0,#0                 ;1603
000028  6460              STR      r0,[r4,#0x44]         ;1603
00002a  2022              MOVS     r0,#0x22              ;1604
00002c  f8840042          STRB     r0,[r4,#0x42]         ;1604
000030  2001              MOVS     r0,#1                 ;1605
000032  6320              STR      r0,[r4,#0x30]         ;1605
000034  2000              MOVS     r0,#0                 ;1606
000036  6360              STR      r0,[r4,#0x34]         ;1606
000038  f7fffffe          BL       HAL_GetTick
00003c  4683              MOV      r11,r0                ;1609
00003e  f8a4802c          STRH     r8,[r4,#0x2c]         ;1611
000042  f8a4802e          STRH     r8,[r4,#0x2e]         ;1612
000046  68a0              LDR      r0,[r4,#8]            ;1615
000048  f5b05f80          CMP      r0,#0x1000            ;1615
00004c  d104              BNE      |L10.88|
00004e  6920              LDR      r0,[r4,#0x10]         ;1615
000050  b910              CBNZ     r0,|L10.88|
000052  2600              MOVS     r6,#0                 ;1617
000054  46b9              MOV      r9,r7                 ;1618
000056  e002              B        |L10.94|
                  |L10.88|
000058  463e              MOV      r6,r7                 ;1622
00005a  f04f0900          MOV      r9,#0                 ;1623
                  |L10.94|
00005e  2000              MOVS     r0,#0                 ;1627
000060  8028              STRH     r0,[r5,#0]            ;1627
000062  e053              B        |L10.268|
                  |L10.100|
000064  6820              LDR      r0,[r4,#0]            ;1633
000066  6800              LDR      r0,[r0,#0]            ;1633
000068  f0000010          AND      r0,r0,#0x10           ;1633
00006c  2810              CMP      r0,#0x10              ;1633
00006e  d113              BNE      |L10.152|
000070  bf00              NOP                            ;1636
000072  2000              MOVS     r0,#0                 ;1636
000074  9000              STR      r0,[sp,#0]            ;1636
000076  6820              LDR      r0,[r4,#0]            ;1636
000078  6800              LDR      r0,[r0,#0]            ;1636
00007a  9000              STR      r0,[sp,#0]            ;1636
00007c  6820              LDR      r0,[r4,#0]            ;1636
00007e  6840              LDR      r0,[r0,#4]            ;1636
000080  9000              STR      r0,[sp,#0]            ;1636
000082  bf00              NOP                            ;1636
000084  bf00              NOP                            ;1636
000086  8828              LDRH     r0,[r5,#0]            ;1640
000088  b130              CBZ      r0,|L10.152|
00008a  2002              MOVS     r0,#2                 ;1642
00008c  6360              STR      r0,[r4,#0x34]         ;1642
00008e  2020              MOVS     r0,#0x20              ;1643
000090  f8840042          STRB     r0,[r4,#0x42]         ;1643
000094  2000              MOVS     r0,#0                 ;1645
000096  e7c4              B        |L10.34|
                  |L10.152|
000098  6820              LDR      r0,[r4,#0]            ;1650
00009a  6800              LDR      r0,[r0,#0]            ;1650
00009c  f0000020          AND      r0,r0,#0x20           ;1650
0000a0  2820              CMP      r0,#0x20              ;1650
0000a2  d121              BNE      |L10.232|
0000a4  b946              CBNZ     r6,|L10.184|
0000a6  6820              LDR      r0,[r4,#0]            ;1654
0000a8  6840              LDR      r0,[r0,#4]            ;1654
0000aa  f3c00008          UBFX     r0,r0,#0,#9           ;1654
0000ae  f8a90000          STRH     r0,[r9,#0]            ;1654
0000b2  f1090902          ADD      r9,r9,#2              ;1655
0000b6  e011              B        |L10.220|
                  |L10.184|
0000b8  68a0              LDR      r0,[r4,#8]            ;1659
0000ba  f5b05f80          CMP      r0,#0x1000            ;1659
0000be  d003              BEQ      |L10.200|
0000c0  68a0              LDR      r0,[r4,#8]            ;1659
0000c2  b928              CBNZ     r0,|L10.208|
0000c4  6920              LDR      r0,[r4,#0x10]         ;1659
0000c6  b918              CBNZ     r0,|L10.208|
                  |L10.200|
0000c8  6820              LDR      r0,[r4,#0]            ;1661
0000ca  6840              LDR      r0,[r0,#4]            ;1661
0000cc  7030              STRB     r0,[r6,#0]            ;1661
0000ce  e004              B        |L10.218|
                  |L10.208|
0000d0  6820              LDR      r0,[r4,#0]            ;1665
0000d2  6840              LDR      r0,[r0,#4]            ;1665
0000d4  f000007f          AND      r0,r0,#0x7f           ;1665
0000d8  7030              STRB     r0,[r6,#0]            ;1665
                  |L10.218|
0000da  1c76              ADDS     r6,r6,#1              ;1668
                  |L10.220|
0000dc  8828              LDRH     r0,[r5,#0]            ;1671
0000de  1c40              ADDS     r0,r0,#1              ;1671
0000e0  8028              STRH     r0,[r5,#0]            ;1671
0000e2  8de0              LDRH     r0,[r4,#0x2e]         ;1672
0000e4  1e40              SUBS     r0,r0,#1              ;1672
0000e6  85e0              STRH     r0,[r4,#0x2e]         ;1672
                  |L10.232|
0000e8  f10a0001          ADD      r0,r10,#1             ;1676
0000ec  b170              CBZ      r0,|L10.268|
0000ee  f7fffffe          BL       HAL_GetTick
0000f2  eba0000b          SUB      r0,r0,r11             ;1678
0000f6  4550              CMP      r0,r10                ;1678
0000f8  d802              BHI      |L10.256|
0000fa  f1ba0f00          CMP      r10,#0                ;1678
0000fe  d105              BNE      |L10.268|
                  |L10.256|
000100  2020              MOVS     r0,#0x20              ;1680
000102  f8840042          STRB     r0,[r4,#0x42]         ;1680
000106  2003              MOVS     r0,#3                 ;1682
000108  e78b              B        |L10.34|
                  |L10.266|
00010a  e00b              B        |L10.292|
                  |L10.268|
00010c  8de0              LDRH     r0,[r4,#0x2e]         ;1630
00010e  2800              CMP      r0,#0                 ;1630
000110  d1a8              BNE      |L10.100|
000112  8da0              LDRH     r0,[r4,#0x2c]         ;1688
000114  8de1              LDRH     r1,[r4,#0x2e]         ;1688
000116  1a40              SUBS     r0,r0,r1              ;1688
000118  8028              STRH     r0,[r5,#0]            ;1688
00011a  2020              MOVS     r0,#0x20              ;1690
00011c  f8840042          STRB     r0,[r4,#0x42]         ;1690
000120  2000              MOVS     r0,#0                 ;1692
000122  e77e              B        |L10.34|
                  |L10.292|
000124  2002              MOVS     r0,#2                 ;1696
000126  e77c              B        |L10.34|
;;;1699   
                          ENDP


                          AREA ||i.HAL_UARTEx_ReceiveToIdle_DMA||, CODE, READONLY, ALIGN=1

                  HAL_UARTEx_ReceiveToIdle_DMA PROC
;;;1772     */
;;;1773   HAL_StatusTypeDef HAL_UARTEx_ReceiveToIdle_DMA(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size)
000000  b5f8              PUSH     {r3-r7,lr}
;;;1774   {
000002  4604              MOV      r4,r0
000004  460e              MOV      r6,r1
000006  4617              MOV      r7,r2
;;;1775     HAL_StatusTypeDef status;
;;;1776   
;;;1777     /* Check that a Rx process is not already ongoing */
;;;1778     if (huart->RxState == HAL_UART_STATE_READY)
000008  f8940042          LDRB     r0,[r4,#0x42]
00000c  2820              CMP      r0,#0x20
00000e  d12e              BNE      |L11.110|
;;;1779     {
;;;1780       if ((pData == NULL) || (Size == 0U))
000010  b106              CBZ      r6,|L11.20|
000012  b90f              CBNZ     r7,|L11.24|
                  |L11.20|
;;;1781       {
;;;1782         return HAL_ERROR;
000014  2001              MOVS     r0,#1
                  |L11.22|
;;;1783       }
;;;1784   
;;;1785       /* Set Reception type to reception till IDLE Event*/
;;;1786       huart->ReceptionType = HAL_UART_RECEPTION_TOIDLE;
;;;1787       huart->RxEventType = HAL_UART_RXEVENT_TC;
;;;1788   
;;;1789       status =  UART_Start_Receive_DMA(huart, pData, Size);
;;;1790   
;;;1791       /* Check Rx process has been successfully started */
;;;1792       if (status == HAL_OK)
;;;1793       {
;;;1794         if (huart->ReceptionType == HAL_UART_RECEPTION_TOIDLE)
;;;1795         {
;;;1796           __HAL_UART_CLEAR_IDLEFLAG(huart);
;;;1797           ATOMIC_SET_BIT(huart->Instance->CR1, USART_CR1_IDLEIE);
;;;1798         }
;;;1799         else
;;;1800         {
;;;1801           /* In case of errors already pending when reception is started,
;;;1802              Interrupts may have already been raised and lead to reception abortion.
;;;1803              (Overrun error for instance).
;;;1804              In such case Reception Type has been reset to HAL_UART_RECEPTION_STANDARD. */
;;;1805           status = HAL_ERROR;
;;;1806         }
;;;1807       }
;;;1808   
;;;1809       return status;
;;;1810     }
;;;1811     else
;;;1812     {
;;;1813       return HAL_BUSY;
;;;1814     }
;;;1815   }
000016  bdf8              POP      {r3-r7,pc}
                  |L11.24|
000018  2001              MOVS     r0,#1                 ;1786
00001a  6320              STR      r0,[r4,#0x30]         ;1786
00001c  2000              MOVS     r0,#0                 ;1787
00001e  6360              STR      r0,[r4,#0x34]         ;1787
000020  463a              MOV      r2,r7                 ;1789
000022  4631              MOV      r1,r6                 ;1789
000024  4620              MOV      r0,r4                 ;1789
000026  f7fffffe          BL       UART_Start_Receive_DMA
00002a  4605              MOV      r5,r0                 ;1789
00002c  b9ed              CBNZ     r5,|L11.106|
00002e  6b20              LDR      r0,[r4,#0x30]         ;1794
000030  2801              CMP      r0,#1                 ;1794
000032  d119              BNE      |L11.104|
000034  bf00              NOP                            ;1796
000036  2000              MOVS     r0,#0                 ;1796
000038  9000              STR      r0,[sp,#0]            ;1796
00003a  6820              LDR      r0,[r4,#0]            ;1796
00003c  6800              LDR      r0,[r0,#0]            ;1796
00003e  9000              STR      r0,[sp,#0]            ;1796
000040  6820              LDR      r0,[r4,#0]            ;1796
000042  6840              LDR      r0,[r0,#4]            ;1796
000044  9000              STR      r0,[sp,#0]            ;1796
000046  bf00              NOP                            ;1796
000048  bf00              NOP                            ;1796
00004a  bf00              NOP                            ;1797
00004c  bf00              NOP                            ;1797
                  |L11.78|
00004e  6821              LDR      r1,[r4,#0]            ;1797
000050  310c              ADDS     r1,r1,#0xc            ;1797
000052  e8511f00          LDREX    r1,[r1,#0]            ;1797
000056  f0410010          ORR      r0,r1,#0x10           ;1797
00005a  6821              LDR      r1,[r4,#0]            ;1797
00005c  310c              ADDS     r1,r1,#0xc            ;1797
00005e  e8410200          STREX    r2,r0,[r1,#0]         ;1797
000062  2a00              CMP      r2,#0                 ;1797
000064  d1f3              BNE      |L11.78|
000066  e000              B        |L11.106|
                  |L11.104|
000068  2501              MOVS     r5,#1                 ;1805
                  |L11.106|
00006a  4628              MOV      r0,r5                 ;1809
00006c  e7d3              B        |L11.22|
                  |L11.110|
00006e  2002              MOVS     r0,#2                 ;1813
000070  e7d1              B        |L11.22|
;;;1816   
                          ENDP


                          AREA ||i.HAL_UARTEx_ReceiveToIdle_IT||, CODE, READONLY, ALIGN=1

                  HAL_UARTEx_ReceiveToIdle_IT PROC
;;;1712     */
;;;1713   HAL_StatusTypeDef HAL_UARTEx_ReceiveToIdle_IT(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size)
000000  b5f8              PUSH     {r3-r7,lr}
;;;1714   {
000002  4604              MOV      r4,r0
000004  460e              MOV      r6,r1
000006  4617              MOV      r7,r2
;;;1715     HAL_StatusTypeDef status;
;;;1716   
;;;1717     /* Check that a Rx process is not already ongoing */
;;;1718     if (huart->RxState == HAL_UART_STATE_READY)
000008  f8940042          LDRB     r0,[r4,#0x42]
00000c  2820              CMP      r0,#0x20
00000e  d12e              BNE      |L12.110|
;;;1719     {
;;;1720       if ((pData == NULL) || (Size == 0U))
000010  b106              CBZ      r6,|L12.20|
000012  b90f              CBNZ     r7,|L12.24|
                  |L12.20|
;;;1721       {
;;;1722         return HAL_ERROR;
000014  2001              MOVS     r0,#1
                  |L12.22|
;;;1723       }
;;;1724   
;;;1725       /* Set Reception type to reception till IDLE Event*/
;;;1726       huart->ReceptionType = HAL_UART_RECEPTION_TOIDLE;
;;;1727       huart->RxEventType = HAL_UART_RXEVENT_TC;
;;;1728   
;;;1729       status =  UART_Start_Receive_IT(huart, pData, Size);
;;;1730   
;;;1731       /* Check Rx process has been successfully started */
;;;1732       if (status == HAL_OK)
;;;1733       {
;;;1734         if (huart->ReceptionType == HAL_UART_RECEPTION_TOIDLE)
;;;1735         {
;;;1736           __HAL_UART_CLEAR_IDLEFLAG(huart);
;;;1737           ATOMIC_SET_BIT(huart->Instance->CR1, USART_CR1_IDLEIE);
;;;1738         }
;;;1739         else
;;;1740         {
;;;1741           /* In case of errors already pending when reception is started,
;;;1742              Interrupts may have already been raised and lead to reception abortion.
;;;1743              (Overrun error for instance).
;;;1744              In such case Reception Type has been reset to HAL_UART_RECEPTION_STANDARD. */
;;;1745           status = HAL_ERROR;
;;;1746         }
;;;1747       }
;;;1748   
;;;1749       return status;
;;;1750     }
;;;1751     else
;;;1752     {
;;;1753       return HAL_BUSY;
;;;1754     }
;;;1755   }
000016  bdf8              POP      {r3-r7,pc}
                  |L12.24|
000018  2001              MOVS     r0,#1                 ;1726
00001a  6320              STR      r0,[r4,#0x30]         ;1726
00001c  2000              MOVS     r0,#0                 ;1727
00001e  6360              STR      r0,[r4,#0x34]         ;1727
000020  463a              MOV      r2,r7                 ;1729
000022  4631              MOV      r1,r6                 ;1729
000024  4620              MOV      r0,r4                 ;1729
000026  f7fffffe          BL       UART_Start_Receive_IT
00002a  4605              MOV      r5,r0                 ;1729
00002c  b9ed              CBNZ     r5,|L12.106|
00002e  6b20              LDR      r0,[r4,#0x30]         ;1734
000030  2801              CMP      r0,#1                 ;1734
000032  d119              BNE      |L12.104|
000034  bf00              NOP                            ;1736
000036  2000              MOVS     r0,#0                 ;1736
000038  9000              STR      r0,[sp,#0]            ;1736
00003a  6820              LDR      r0,[r4,#0]            ;1736
00003c  6800              LDR      r0,[r0,#0]            ;1736
00003e  9000              STR      r0,[sp,#0]            ;1736
000040  6820              LDR      r0,[r4,#0]            ;1736
000042  6840              LDR      r0,[r0,#4]            ;1736
000044  9000              STR      r0,[sp,#0]            ;1736
000046  bf00              NOP                            ;1736
000048  bf00              NOP                            ;1736
00004a  bf00              NOP                            ;1737
00004c  bf00              NOP                            ;1737
                  |L12.78|
00004e  6821              LDR      r1,[r4,#0]            ;1737
000050  310c              ADDS     r1,r1,#0xc            ;1737
000052  e8511f00          LDREX    r1,[r1,#0]            ;1737
000056  f0410010          ORR      r0,r1,#0x10           ;1737
00005a  6821              LDR      r1,[r4,#0]            ;1737
00005c  310c              ADDS     r1,r1,#0xc            ;1737
00005e  e8410200          STREX    r2,r0,[r1,#0]         ;1737
000062  2a00              CMP      r2,#0                 ;1737
000064  d1f3              BNE      |L12.78|
000066  e000              B        |L12.106|
                  |L12.104|
000068  2501              MOVS     r5,#1                 ;1745
                  |L12.106|
00006a  4628              MOV      r0,r5                 ;1749
00006c  e7d3              B        |L12.22|
                  |L12.110|
00006e  2002              MOVS     r0,#2                 ;1753
000070  e7d1              B        |L12.22|
;;;1756   
                          ENDP


                          AREA ||i.HAL_UARTEx_RxEventCallback||, CODE, READONLY, ALIGN=1

                  HAL_UARTEx_RxEventCallback PROC
;;;2712     */
;;;2713   __weak void HAL_UARTEx_RxEventCallback(UART_HandleTypeDef *huart, uint16_t Size)
000000  4770              BX       lr
;;;2714   {
;;;2715     /* Prevent unused argument(s) compilation warning */
;;;2716     UNUSED(huart);
;;;2717     UNUSED(Size);
;;;2718   
;;;2719     /* NOTE : This function should not be modified, when the callback is needed,
;;;2720               the HAL_UARTEx_RxEventCallback can be implemented in the user file.
;;;2721      */
;;;2722   }
;;;2723   
                          ENDP


                          AREA ||i.HAL_UART_Abort||, CODE, READONLY, ALIGN=1

                  HAL_UART_Abort PROC
;;;1858     */
;;;1859   HAL_StatusTypeDef HAL_UART_Abort(UART_HandleTypeDef *huart)
000000  b510              PUSH     {r4,lr}
;;;1860   {
000002  4604              MOV      r4,r0
;;;1861     /* Disable TXEIE, TCIE, RXNE, PE and ERR (Frame error, noise error, overrun error) interrupts */
;;;1862     ATOMIC_CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE | USART_CR1_TXEIE | USART_CR1_TCIE));
000004  bf00              NOP      
000006  bf00              NOP      
                  |L14.8|
000008  6821              LDR      r1,[r4,#0]
00000a  310c              ADDS     r1,r1,#0xc
00000c  e8511f00          LDREX    r1,[r1,#0]
000010  f42170f0          BIC      r0,r1,#0x1e0
000014  6821              LDR      r1,[r4,#0]
000016  310c              ADDS     r1,r1,#0xc
000018  e8410200          STREX    r2,r0,[r1,#0]
00001c  2a00              CMP      r2,#0
00001e  d1f3              BNE      |L14.8|
000020  bf00              NOP      
;;;1863     ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
000022  bf00              NOP      
000024  bf00              NOP      
                  |L14.38|
000026  6821              LDR      r1,[r4,#0]
000028  3114              ADDS     r1,r1,#0x14
00002a  e8511f00          LDREX    r1,[r1,#0]
00002e  f0210001          BIC      r0,r1,#1
000032  6821              LDR      r1,[r4,#0]
000034  3114              ADDS     r1,r1,#0x14
000036  e8410200          STREX    r2,r0,[r1,#0]
00003a  2a00              CMP      r2,#0
00003c  d1f3              BNE      |L14.38|
00003e  bf00              NOP      
;;;1864   
;;;1865     /* If Reception till IDLE event was ongoing, disable IDLEIE interrupt */
;;;1866     if (huart->ReceptionType == HAL_UART_RECEPTION_TOIDLE)
000040  6b20              LDR      r0,[r4,#0x30]
000042  2801              CMP      r0,#1
000044  d10e              BNE      |L14.100|
;;;1867     {
;;;1868       ATOMIC_CLEAR_BIT(huart->Instance->CR1, (USART_CR1_IDLEIE));
000046  bf00              NOP      
000048  bf00              NOP      
                  |L14.74|
00004a  6821              LDR      r1,[r4,#0]
00004c  310c              ADDS     r1,r1,#0xc
00004e  e8511f00          LDREX    r1,[r1,#0]
000052  f0210010          BIC      r0,r1,#0x10
000056  6821              LDR      r1,[r4,#0]
000058  310c              ADDS     r1,r1,#0xc
00005a  e8410200          STREX    r2,r0,[r1,#0]
00005e  2a00              CMP      r2,#0
000060  d1f3              BNE      |L14.74|
000062  bf00              NOP      
                  |L14.100|
;;;1869     }
;;;1870   
;;;1871     /* Disable the UART DMA Tx request if enabled */
;;;1872     if (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAT))
000064  6820              LDR      r0,[r4,#0]
000066  6940              LDR      r0,[r0,#0x14]
000068  f0000080          AND      r0,r0,#0x80
00006c  2880              CMP      r0,#0x80
00006e  d120              BNE      |L14.178|
;;;1873     {
;;;1874       ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAT);
000070  bf00              NOP      
000072  bf00              NOP      
                  |L14.116|
000074  6821              LDR      r1,[r4,#0]
000076  3114              ADDS     r1,r1,#0x14
000078  e8511f00          LDREX    r1,[r1,#0]
00007c  f0210080          BIC      r0,r1,#0x80
000080  6821              LDR      r1,[r4,#0]
000082  3114              ADDS     r1,r1,#0x14
000084  e8410200          STREX    r2,r0,[r1,#0]
000088  2a00              CMP      r2,#0
00008a  d1f3              BNE      |L14.116|
00008c  bf00              NOP      
;;;1875   
;;;1876       /* Abort the UART DMA Tx stream: use blocking DMA Abort API (no callback) */
;;;1877       if (huart->hdmatx != NULL)
00008e  6ba0              LDR      r0,[r4,#0x38]
000090  b178              CBZ      r0,|L14.178|
;;;1878       {
;;;1879         /* Set the UART DMA Abort callback to Null.
;;;1880            No call back execution at end of DMA abort procedure */
;;;1881         huart->hdmatx->XferAbortCallback = NULL;
000092  2000              MOVS     r0,#0
000094  6ba1              LDR      r1,[r4,#0x38]
000096  6508              STR      r0,[r1,#0x50]
;;;1882   
;;;1883         if (HAL_DMA_Abort(huart->hdmatx) != HAL_OK)
000098  6ba0              LDR      r0,[r4,#0x38]
00009a  f7fffffe          BL       HAL_DMA_Abort
00009e  b140              CBZ      r0,|L14.178|
;;;1884         {
;;;1885           if (HAL_DMA_GetError(huart->hdmatx) == HAL_DMA_ERROR_TIMEOUT)
0000a0  6ba0              LDR      r0,[r4,#0x38]
0000a2  f7fffffe          BL       HAL_DMA_GetError
0000a6  2820              CMP      r0,#0x20
0000a8  d103              BNE      |L14.178|
;;;1886           {
;;;1887             /* Set error code to DMA */
;;;1888             huart->ErrorCode = HAL_UART_ERROR_DMA;
0000aa  2010              MOVS     r0,#0x10
0000ac  6460              STR      r0,[r4,#0x44]
;;;1889   
;;;1890             return HAL_TIMEOUT;
0000ae  2003              MOVS     r0,#3
                  |L14.176|
;;;1891           }
;;;1892         }
;;;1893       }
;;;1894     }
;;;1895   
;;;1896     /* Disable the UART DMA Rx request if enabled */
;;;1897     if (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR))
;;;1898     {
;;;1899       ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAR);
;;;1900   
;;;1901       /* Abort the UART DMA Rx stream: use blocking DMA Abort API (no callback) */
;;;1902       if (huart->hdmarx != NULL)
;;;1903       {
;;;1904         /* Set the UART DMA Abort callback to Null.
;;;1905            No call back execution at end of DMA abort procedure */
;;;1906         huart->hdmarx->XferAbortCallback = NULL;
;;;1907   
;;;1908         if (HAL_DMA_Abort(huart->hdmarx) != HAL_OK)
;;;1909         {
;;;1910           if (HAL_DMA_GetError(huart->hdmarx) == HAL_DMA_ERROR_TIMEOUT)
;;;1911           {
;;;1912             /* Set error code to DMA */
;;;1913             huart->ErrorCode = HAL_UART_ERROR_DMA;
;;;1914   
;;;1915             return HAL_TIMEOUT;
;;;1916           }
;;;1917         }
;;;1918       }
;;;1919     }
;;;1920   
;;;1921     /* Reset Tx and Rx transfer counters */
;;;1922     huart->TxXferCount = 0x00U;
;;;1923     huart->RxXferCount = 0x00U;
;;;1924   
;;;1925     /* Reset ErrorCode */
;;;1926     huart->ErrorCode = HAL_UART_ERROR_NONE;
;;;1927   
;;;1928     /* Restore huart->RxState and huart->gState to Ready */
;;;1929     huart->RxState = HAL_UART_STATE_READY;
;;;1930     huart->gState = HAL_UART_STATE_READY;
;;;1931     huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
;;;1932   
;;;1933     return HAL_OK;
;;;1934   }
0000b0  bd10              POP      {r4,pc}
                  |L14.178|
0000b2  6820              LDR      r0,[r4,#0]            ;1897
0000b4  6940              LDR      r0,[r0,#0x14]         ;1897
0000b6  f0000040          AND      r0,r0,#0x40           ;1897
0000ba  2840              CMP      r0,#0x40              ;1897
0000bc  d120              BNE      |L14.256|
0000be  bf00              NOP                            ;1899
0000c0  bf00              NOP                            ;1899
                  |L14.194|
0000c2  6821              LDR      r1,[r4,#0]            ;1899
0000c4  3114              ADDS     r1,r1,#0x14           ;1899
0000c6  e8511f00          LDREX    r1,[r1,#0]            ;1899
0000ca  f0210040          BIC      r0,r1,#0x40           ;1899
0000ce  6821              LDR      r1,[r4,#0]            ;1899
0000d0  3114              ADDS     r1,r1,#0x14           ;1899
0000d2  e8410200          STREX    r2,r0,[r1,#0]         ;1899
0000d6  2a00              CMP      r2,#0                 ;1899
0000d8  d1f3              BNE      |L14.194|
0000da  bf00              NOP                            ;1899
0000dc  6be0              LDR      r0,[r4,#0x3c]         ;1902
0000de  b178              CBZ      r0,|L14.256|
0000e0  2000              MOVS     r0,#0                 ;1906
0000e2  6be1              LDR      r1,[r4,#0x3c]         ;1906
0000e4  6508              STR      r0,[r1,#0x50]         ;1906
0000e6  6be0              LDR      r0,[r4,#0x3c]         ;1908
0000e8  f7fffffe          BL       HAL_DMA_Abort
0000ec  b140              CBZ      r0,|L14.256|
0000ee  6be0              LDR      r0,[r4,#0x3c]         ;1910
0000f0  f7fffffe          BL       HAL_DMA_GetError
0000f4  2820              CMP      r0,#0x20              ;1910
0000f6  d103              BNE      |L14.256|
0000f8  2010              MOVS     r0,#0x10              ;1913
0000fa  6460              STR      r0,[r4,#0x44]         ;1913
0000fc  2003              MOVS     r0,#3                 ;1915
0000fe  e7d7              B        |L14.176|
                  |L14.256|
000100  2000              MOVS     r0,#0                 ;1922
000102  84e0              STRH     r0,[r4,#0x26]         ;1922
000104  85e0              STRH     r0,[r4,#0x2e]         ;1923
000106  6460              STR      r0,[r4,#0x44]         ;1926
000108  2020              MOVS     r0,#0x20              ;1929
00010a  f8840042          STRB     r0,[r4,#0x42]         ;1929
00010e  f8840041          STRB     r0,[r4,#0x41]         ;1930
000112  2000              MOVS     r0,#0                 ;1931
000114  6320              STR      r0,[r4,#0x30]         ;1931
000116  bf00              NOP                            ;1933
000118  e7ca              B        |L14.176|
;;;1935   
                          ENDP


                          AREA ||i.HAL_UART_AbortCpltCallback||, CODE, READONLY, ALIGN=1

                  HAL_UART_AbortCpltCallback PROC
;;;2665     */
;;;2666   __weak void HAL_UART_AbortCpltCallback(UART_HandleTypeDef *huart)
000000  4770              BX       lr
;;;2667   {
;;;2668     /* Prevent unused argument(s) compilation warning */
;;;2669     UNUSED(huart);
;;;2670   
;;;2671     /* NOTE : This function should not be modified, when the callback is needed,
;;;2672               the HAL_UART_AbortCpltCallback can be implemented in the user file.
;;;2673      */
;;;2674   }
;;;2675   
                          ENDP


                          AREA ||i.HAL_UART_AbortReceive||, CODE, READONLY, ALIGN=1

                  HAL_UART_AbortReceive PROC
;;;1998     */
;;;1999   HAL_StatusTypeDef HAL_UART_AbortReceive(UART_HandleTypeDef *huart)
000000  b510              PUSH     {r4,lr}
;;;2000   {
000002  4604              MOV      r4,r0
;;;2001     /* Disable RXNE, PE and ERR (Frame error, noise error, overrun error) interrupts */
;;;2002     ATOMIC_CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE));
000004  bf00              NOP      
000006  bf00              NOP      
                  |L16.8|
000008  6821              LDR      r1,[r4,#0]
00000a  310c              ADDS     r1,r1,#0xc
00000c  e8511f00          LDREX    r1,[r1,#0]
000010  f4217090          BIC      r0,r1,#0x120
000014  6821              LDR      r1,[r4,#0]
000016  310c              ADDS     r1,r1,#0xc
000018  e8410200          STREX    r2,r0,[r1,#0]
00001c  2a00              CMP      r2,#0
00001e  d1f3              BNE      |L16.8|
000020  bf00              NOP      
;;;2003     ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
000022  bf00              NOP      
000024  bf00              NOP      
                  |L16.38|
000026  6821              LDR      r1,[r4,#0]
000028  3114              ADDS     r1,r1,#0x14
00002a  e8511f00          LDREX    r1,[r1,#0]
00002e  f0210001          BIC      r0,r1,#1
000032  6821              LDR      r1,[r4,#0]
000034  3114              ADDS     r1,r1,#0x14
000036  e8410200          STREX    r2,r0,[r1,#0]
00003a  2a00              CMP      r2,#0
00003c  d1f3              BNE      |L16.38|
00003e  bf00              NOP      
;;;2004   
;;;2005     /* If Reception till IDLE event was ongoing, disable IDLEIE interrupt */
;;;2006     if (huart->ReceptionType == HAL_UART_RECEPTION_TOIDLE)
000040  6b20              LDR      r0,[r4,#0x30]
000042  2801              CMP      r0,#1
000044  d10e              BNE      |L16.100|
;;;2007     {
;;;2008       ATOMIC_CLEAR_BIT(huart->Instance->CR1, (USART_CR1_IDLEIE));
000046  bf00              NOP      
000048  bf00              NOP      
                  |L16.74|
00004a  6821              LDR      r1,[r4,#0]
00004c  310c              ADDS     r1,r1,#0xc
00004e  e8511f00          LDREX    r1,[r1,#0]
000052  f0210010          BIC      r0,r1,#0x10
000056  6821              LDR      r1,[r4,#0]
000058  310c              ADDS     r1,r1,#0xc
00005a  e8410200          STREX    r2,r0,[r1,#0]
00005e  2a00              CMP      r2,#0
000060  d1f3              BNE      |L16.74|
000062  bf00              NOP      
                  |L16.100|
;;;2009     }
;;;2010   
;;;2011     /* Disable the UART DMA Rx request if enabled */
;;;2012     if (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR))
000064  6820              LDR      r0,[r4,#0]
000066  6940              LDR      r0,[r0,#0x14]
000068  f0000040          AND      r0,r0,#0x40
00006c  2840              CMP      r0,#0x40
00006e  d120              BNE      |L16.178|
;;;2013     {
;;;2014       ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAR);
000070  bf00              NOP      
000072  bf00              NOP      
                  |L16.116|
000074  6821              LDR      r1,[r4,#0]
000076  3114              ADDS     r1,r1,#0x14
000078  e8511f00          LDREX    r1,[r1,#0]
00007c  f0210040          BIC      r0,r1,#0x40
000080  6821              LDR      r1,[r4,#0]
000082  3114              ADDS     r1,r1,#0x14
000084  e8410200          STREX    r2,r0,[r1,#0]
000088  2a00              CMP      r2,#0
00008a  d1f3              BNE      |L16.116|
00008c  bf00              NOP      
;;;2015   
;;;2016       /* Abort the UART DMA Rx stream : use blocking DMA Abort API (no callback) */
;;;2017       if (huart->hdmarx != NULL)
00008e  6be0              LDR      r0,[r4,#0x3c]
000090  b178              CBZ      r0,|L16.178|
;;;2018       {
;;;2019         /* Set the UART DMA Abort callback to Null.
;;;2020            No call back execution at end of DMA abort procedure */
;;;2021         huart->hdmarx->XferAbortCallback = NULL;
000092  2000              MOVS     r0,#0
000094  6be1              LDR      r1,[r4,#0x3c]
000096  6508              STR      r0,[r1,#0x50]
;;;2022   
;;;2023         if (HAL_DMA_Abort(huart->hdmarx) != HAL_OK)
000098  6be0              LDR      r0,[r4,#0x3c]
00009a  f7fffffe          BL       HAL_DMA_Abort
00009e  b140              CBZ      r0,|L16.178|
;;;2024         {
;;;2025           if (HAL_DMA_GetError(huart->hdmarx) == HAL_DMA_ERROR_TIMEOUT)
0000a0  6be0              LDR      r0,[r4,#0x3c]
0000a2  f7fffffe          BL       HAL_DMA_GetError
0000a6  2820              CMP      r0,#0x20
0000a8  d103              BNE      |L16.178|
;;;2026           {
;;;2027             /* Set error code to DMA */
;;;2028             huart->ErrorCode = HAL_UART_ERROR_DMA;
0000aa  2010              MOVS     r0,#0x10
0000ac  6460              STR      r0,[r4,#0x44]
;;;2029   
;;;2030             return HAL_TIMEOUT;
0000ae  2003              MOVS     r0,#3
                  |L16.176|
;;;2031           }
;;;2032         }
;;;2033       }
;;;2034     }
;;;2035   
;;;2036     /* Reset Rx transfer counter */
;;;2037     huart->RxXferCount = 0x00U;
;;;2038   
;;;2039     /* Restore huart->RxState to Ready */
;;;2040     huart->RxState = HAL_UART_STATE_READY;
;;;2041     huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
;;;2042   
;;;2043     return HAL_OK;
;;;2044   }
0000b0  bd10              POP      {r4,pc}
                  |L16.178|
0000b2  2000              MOVS     r0,#0                 ;2037
0000b4  85e0              STRH     r0,[r4,#0x2e]         ;2037
0000b6  2020              MOVS     r0,#0x20              ;2040
0000b8  f8840042          STRB     r0,[r4,#0x42]         ;2040
0000bc  2000              MOVS     r0,#0                 ;2041
0000be  6320              STR      r0,[r4,#0x30]         ;2041
0000c0  bf00              NOP                            ;2043
0000c2  e7f5              B        |L16.176|
;;;2045   
                          ENDP


                          AREA ||i.HAL_UART_AbortReceiveCpltCallback||, CODE, READONLY, ALIGN=1

                  HAL_UART_AbortReceiveCpltCallback PROC
;;;2695     */
;;;2696   __weak void HAL_UART_AbortReceiveCpltCallback(UART_HandleTypeDef *huart)
000000  4770              BX       lr
;;;2697   {
;;;2698     /* Prevent unused argument(s) compilation warning */
;;;2699     UNUSED(huart);
;;;2700   
;;;2701     /* NOTE : This function should not be modified, when the callback is needed,
;;;2702               the HAL_UART_AbortReceiveCpltCallback can be implemented in the user file.
;;;2703      */
;;;2704   }
;;;2705   
                          ENDP


                          AREA ||i.HAL_UART_AbortReceive_IT||, CODE, READONLY, ALIGN=2

                  HAL_UART_AbortReceive_IT PROC
;;;2271     */
;;;2272   HAL_StatusTypeDef HAL_UART_AbortReceive_IT(UART_HandleTypeDef *huart)
000000  b510              PUSH     {r4,lr}
;;;2273   {
000002  4604              MOV      r4,r0
;;;2274     /* Disable RXNE, PE and ERR (Frame error, noise error, overrun error) interrupts */
;;;2275     ATOMIC_CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE));
000004  bf00              NOP      
000006  bf00              NOP      
                  |L18.8|
000008  6821              LDR      r1,[r4,#0]
00000a  310c              ADDS     r1,r1,#0xc
00000c  e8511f00          LDREX    r1,[r1,#0]
000010  f4217090          BIC      r0,r1,#0x120
000014  6821              LDR      r1,[r4,#0]
000016  310c              ADDS     r1,r1,#0xc
000018  e8410200          STREX    r2,r0,[r1,#0]
00001c  2a00              CMP      r2,#0
00001e  d1f3              BNE      |L18.8|
000020  bf00              NOP      
;;;2276     ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
000022  bf00              NOP      
000024  bf00              NOP      
                  |L18.38|
000026  6821              LDR      r1,[r4,#0]
000028  3114              ADDS     r1,r1,#0x14
00002a  e8511f00          LDREX    r1,[r1,#0]
00002e  f0210001          BIC      r0,r1,#1
000032  6821              LDR      r1,[r4,#0]
000034  3114              ADDS     r1,r1,#0x14
000036  e8410200          STREX    r2,r0,[r1,#0]
00003a  2a00              CMP      r2,#0
00003c  d1f3              BNE      |L18.38|
00003e  bf00              NOP      
;;;2277   
;;;2278     /* If Reception till IDLE event was ongoing, disable IDLEIE interrupt */
;;;2279     if (huart->ReceptionType == HAL_UART_RECEPTION_TOIDLE)
000040  6b20              LDR      r0,[r4,#0x30]
000042  2801              CMP      r0,#1
000044  d10e              BNE      |L18.100|
;;;2280     {
;;;2281       ATOMIC_CLEAR_BIT(huart->Instance->CR1, (USART_CR1_IDLEIE));
000046  bf00              NOP      
000048  bf00              NOP      
                  |L18.74|
00004a  6821              LDR      r1,[r4,#0]
00004c  310c              ADDS     r1,r1,#0xc
00004e  e8511f00          LDREX    r1,[r1,#0]
000052  f0210010          BIC      r0,r1,#0x10
000056  6821              LDR      r1,[r4,#0]
000058  310c              ADDS     r1,r1,#0xc
00005a  e8410200          STREX    r2,r0,[r1,#0]
00005e  2a00              CMP      r2,#0
000060  d1f3              BNE      |L18.74|
000062  bf00              NOP      
                  |L18.100|
;;;2282     }
;;;2283   
;;;2284     /* Disable the UART DMA Rx request if enabled */
;;;2285     if (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR))
000064  6820              LDR      r0,[r4,#0]
000066  6940              LDR      r0,[r0,#0x14]
000068  f0000040          AND      r0,r0,#0x40
00006c  2840              CMP      r0,#0x40
00006e  d126              BNE      |L18.190|
;;;2286     {
;;;2287       ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAR);
000070  bf00              NOP      
000072  bf00              NOP      
                  |L18.116|
000074  6821              LDR      r1,[r4,#0]
000076  3114              ADDS     r1,r1,#0x14
000078  e8511f00          LDREX    r1,[r1,#0]
00007c  f0210040          BIC      r0,r1,#0x40
000080  6821              LDR      r1,[r4,#0]
000082  3114              ADDS     r1,r1,#0x14
000084  e8410200          STREX    r2,r0,[r1,#0]
000088  2a00              CMP      r2,#0
00008a  d1f3              BNE      |L18.116|
00008c  bf00              NOP      
;;;2288   
;;;2289       /* Abort the UART DMA Rx stream : use blocking DMA Abort API (no callback) */
;;;2290       if (huart->hdmarx != NULL)
00008e  6be0              LDR      r0,[r4,#0x3c]
000090  b150              CBZ      r0,|L18.168|
;;;2291       {
;;;2292         /* Set the UART DMA Abort callback :
;;;2293            will lead to call HAL_UART_AbortCpltCallback() at end of DMA abort procedure */
;;;2294         huart->hdmarx->XferAbortCallback = UART_DMARxOnlyAbortCallback;
000092  4811              LDR      r0,|L18.216|
000094  6be1              LDR      r1,[r4,#0x3c]
000096  6508              STR      r0,[r1,#0x50]
;;;2295   
;;;2296         /* Abort DMA RX */
;;;2297         if (HAL_DMA_Abort_IT(huart->hdmarx) != HAL_OK)
000098  6be0              LDR      r0,[r4,#0x3c]
00009a  f7fffffe          BL       HAL_DMA_Abort_IT
00009e  b1c0              CBZ      r0,|L18.210|
;;;2298         {
;;;2299           /* Call Directly huart->hdmarx->XferAbortCallback function in case of error */
;;;2300           huart->hdmarx->XferAbortCallback(huart->hdmarx);
0000a0  6be0              LDR      r0,[r4,#0x3c]
0000a2  6d01              LDR      r1,[r0,#0x50]
0000a4  4788              BLX      r1
0000a6  e014              B        |L18.210|
                  |L18.168|
;;;2301         }
;;;2302       }
;;;2303       else
;;;2304       {
;;;2305         /* Reset Rx transfer counter */
;;;2306         huart->RxXferCount = 0x00U;
0000a8  2000              MOVS     r0,#0
0000aa  85e0              STRH     r0,[r4,#0x2e]
;;;2307   
;;;2308         /* Restore huart->RxState to Ready */
;;;2309         huart->RxState = HAL_UART_STATE_READY;
0000ac  2020              MOVS     r0,#0x20
0000ae  f8840042          STRB     r0,[r4,#0x42]
;;;2310         huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
0000b2  2000              MOVS     r0,#0
0000b4  6320              STR      r0,[r4,#0x30]
;;;2311   
;;;2312         /* As no DMA to be aborted, call directly user Abort complete callback */
;;;2313   #if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
;;;2314         /* Call registered Abort Receive Complete Callback */
;;;2315         huart->AbortReceiveCpltCallback(huart);
;;;2316   #else
;;;2317         /* Call legacy weak Abort Receive Complete Callback */
;;;2318         HAL_UART_AbortReceiveCpltCallback(huart);
0000b6  4620              MOV      r0,r4
0000b8  f7fffffe          BL       HAL_UART_AbortReceiveCpltCallback
0000bc  e009              B        |L18.210|
                  |L18.190|
;;;2319   #endif /* USE_HAL_UART_REGISTER_CALLBACKS */
;;;2320       }
;;;2321     }
;;;2322     else
;;;2323     {
;;;2324       /* Reset Rx transfer counter */
;;;2325       huart->RxXferCount = 0x00U;
0000be  2000              MOVS     r0,#0
0000c0  85e0              STRH     r0,[r4,#0x2e]
;;;2326   
;;;2327       /* Restore huart->RxState to Ready */
;;;2328       huart->RxState = HAL_UART_STATE_READY;
0000c2  2020              MOVS     r0,#0x20
0000c4  f8840042          STRB     r0,[r4,#0x42]
;;;2329       huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
0000c8  2000              MOVS     r0,#0
0000ca  6320              STR      r0,[r4,#0x30]
;;;2330   
;;;2331       /* As no DMA to be aborted, call directly user Abort complete callback */
;;;2332   #if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
;;;2333       /* Call registered Abort Receive Complete Callback */
;;;2334       huart->AbortReceiveCpltCallback(huart);
;;;2335   #else
;;;2336       /* Call legacy weak Abort Receive Complete Callback */
;;;2337       HAL_UART_AbortReceiveCpltCallback(huart);
0000cc  4620              MOV      r0,r4
0000ce  f7fffffe          BL       HAL_UART_AbortReceiveCpltCallback
                  |L18.210|
;;;2338   #endif /* USE_HAL_UART_REGISTER_CALLBACKS */
;;;2339     }
;;;2340   
;;;2341     return HAL_OK;
0000d2  2000              MOVS     r0,#0
;;;2342   }
0000d4  bd10              POP      {r4,pc}
;;;2343   
                          ENDP

0000d6  0000              DCW      0x0000
                  |L18.216|
                          DCD      UART_DMARxOnlyAbortCallback

                          AREA ||i.HAL_UART_AbortTransmit||, CODE, READONLY, ALIGN=1

                  HAL_UART_AbortTransmit PROC
;;;1947     */
;;;1948   HAL_StatusTypeDef HAL_UART_AbortTransmit(UART_HandleTypeDef *huart)
000000  b510              PUSH     {r4,lr}
;;;1949   {
000002  4604              MOV      r4,r0
;;;1950     /* Disable TXEIE and TCIE interrupts */
;;;1951     ATOMIC_CLEAR_BIT(huart->Instance->CR1, (USART_CR1_TXEIE | USART_CR1_TCIE));
000004  bf00              NOP      
000006  bf00              NOP      
                  |L19.8|
000008  6821              LDR      r1,[r4,#0]
00000a  310c              ADDS     r1,r1,#0xc
00000c  e8511f00          LDREX    r1,[r1,#0]
000010  f02100c0          BIC      r0,r1,#0xc0
000014  6821              LDR      r1,[r4,#0]
000016  310c              ADDS     r1,r1,#0xc
000018  e8410200          STREX    r2,r0,[r1,#0]
00001c  2a00              CMP      r2,#0
00001e  d1f3              BNE      |L19.8|
000020  bf00              NOP      
;;;1952   
;;;1953     /* Disable the UART DMA Tx request if enabled */
;;;1954     if (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAT))
000022  6820              LDR      r0,[r4,#0]
000024  6940              LDR      r0,[r0,#0x14]
000026  f0000080          AND      r0,r0,#0x80
00002a  2880              CMP      r0,#0x80
00002c  d120              BNE      |L19.112|
;;;1955     {
;;;1956       ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAT);
00002e  bf00              NOP      
000030  bf00              NOP      
                  |L19.50|
000032  6821              LDR      r1,[r4,#0]
000034  3114              ADDS     r1,r1,#0x14
000036  e8511f00          LDREX    r1,[r1,#0]
00003a  f0210080          BIC      r0,r1,#0x80
00003e  6821              LDR      r1,[r4,#0]
000040  3114              ADDS     r1,r1,#0x14
000042  e8410200          STREX    r2,r0,[r1,#0]
000046  2a00              CMP      r2,#0
000048  d1f3              BNE      |L19.50|
00004a  bf00              NOP      
;;;1957   
;;;1958       /* Abort the UART DMA Tx stream : use blocking DMA Abort API (no callback) */
;;;1959       if (huart->hdmatx != NULL)
00004c  6ba0              LDR      r0,[r4,#0x38]
00004e  b178              CBZ      r0,|L19.112|
;;;1960       {
;;;1961         /* Set the UART DMA Abort callback to Null.
;;;1962            No call back execution at end of DMA abort procedure */
;;;1963         huart->hdmatx->XferAbortCallback = NULL;
000050  2000              MOVS     r0,#0
000052  6ba1              LDR      r1,[r4,#0x38]
000054  6508              STR      r0,[r1,#0x50]
;;;1964   
;;;1965         if (HAL_DMA_Abort(huart->hdmatx) != HAL_OK)
000056  6ba0              LDR      r0,[r4,#0x38]
000058  f7fffffe          BL       HAL_DMA_Abort
00005c  b140              CBZ      r0,|L19.112|
;;;1966         {
;;;1967           if (HAL_DMA_GetError(huart->hdmatx) == HAL_DMA_ERROR_TIMEOUT)
00005e  6ba0              LDR      r0,[r4,#0x38]
000060  f7fffffe          BL       HAL_DMA_GetError
000064  2820              CMP      r0,#0x20
000066  d103              BNE      |L19.112|
;;;1968           {
;;;1969             /* Set error code to DMA */
;;;1970             huart->ErrorCode = HAL_UART_ERROR_DMA;
000068  2010              MOVS     r0,#0x10
00006a  6460              STR      r0,[r4,#0x44]
;;;1971   
;;;1972             return HAL_TIMEOUT;
00006c  2003              MOVS     r0,#3
                  |L19.110|
;;;1973           }
;;;1974         }
;;;1975       }
;;;1976     }
;;;1977   
;;;1978     /* Reset Tx transfer counter */
;;;1979     huart->TxXferCount = 0x00U;
;;;1980   
;;;1981     /* Restore huart->gState to Ready */
;;;1982     huart->gState = HAL_UART_STATE_READY;
;;;1983   
;;;1984     return HAL_OK;
;;;1985   }
00006e  bd10              POP      {r4,pc}
                  |L19.112|
000070  2000              MOVS     r0,#0                 ;1979
000072  84e0              STRH     r0,[r4,#0x26]         ;1979
000074  2020              MOVS     r0,#0x20              ;1982
000076  f8840041          STRB     r0,[r4,#0x41]         ;1982
00007a  2000              MOVS     r0,#0                 ;1984
00007c  e7f7              B        |L19.110|
;;;1986   
                          ENDP


                          AREA ||i.HAL_UART_AbortTransmitCpltCallback||, CODE, READONLY, ALIGN=1

                  HAL_UART_AbortTransmitCpltCallback PROC
;;;2680     */
;;;2681   __weak void HAL_UART_AbortTransmitCpltCallback(UART_HandleTypeDef *huart)
000000  4770              BX       lr
;;;2682   {
;;;2683     /* Prevent unused argument(s) compilation warning */
;;;2684     UNUSED(huart);
;;;2685   
;;;2686     /* NOTE : This function should not be modified, when the callback is needed,
;;;2687               the HAL_UART_AbortTransmitCpltCallback can be implemented in the user file.
;;;2688      */
;;;2689   }
;;;2690   
                          ENDP


                          AREA ||i.HAL_UART_AbortTransmit_IT||, CODE, READONLY, ALIGN=2

                  HAL_UART_AbortTransmit_IT PROC
;;;2194     */
;;;2195   HAL_StatusTypeDef HAL_UART_AbortTransmit_IT(UART_HandleTypeDef *huart)
000000  b510              PUSH     {r4,lr}
;;;2196   {
000002  4604              MOV      r4,r0
;;;2197     /* Disable TXEIE and TCIE interrupts */
;;;2198     ATOMIC_CLEAR_BIT(huart->Instance->CR1, (USART_CR1_TXEIE | USART_CR1_TCIE));
000004  bf00              NOP      
000006  bf00              NOP      
                  |L21.8|
000008  6821              LDR      r1,[r4,#0]
00000a  310c              ADDS     r1,r1,#0xc
00000c  e8511f00          LDREX    r1,[r1,#0]
000010  f02100c0          BIC      r0,r1,#0xc0
000014  6821              LDR      r1,[r4,#0]
000016  310c              ADDS     r1,r1,#0xc
000018  e8410200          STREX    r2,r0,[r1,#0]
00001c  2a00              CMP      r2,#0
00001e  d1f3              BNE      |L21.8|
000020  bf00              NOP      
;;;2199   
;;;2200     /* Disable the UART DMA Tx request if enabled */
;;;2201     if (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAT))
000022  6820              LDR      r0,[r4,#0]
000024  6940              LDR      r0,[r0,#0x14]
000026  f0000080          AND      r0,r0,#0x80
00002a  2880              CMP      r0,#0x80
00002c  d124              BNE      |L21.120|
;;;2202     {
;;;2203       ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAT);
00002e  bf00              NOP      
000030  bf00              NOP      
                  |L21.50|
000032  6821              LDR      r1,[r4,#0]
000034  3114              ADDS     r1,r1,#0x14
000036  e8511f00          LDREX    r1,[r1,#0]
00003a  f0210080          BIC      r0,r1,#0x80
00003e  6821              LDR      r1,[r4,#0]
000040  3114              ADDS     r1,r1,#0x14
000042  e8410200          STREX    r2,r0,[r1,#0]
000046  2a00              CMP      r2,#0
000048  d1f3              BNE      |L21.50|
00004a  bf00              NOP      
;;;2204   
;;;2205       /* Abort the UART DMA Tx stream : use blocking DMA Abort API (no callback) */
;;;2206       if (huart->hdmatx != NULL)
00004c  6ba0              LDR      r0,[r4,#0x38]
00004e  b150              CBZ      r0,|L21.102|
;;;2207       {
;;;2208         /* Set the UART DMA Abort callback :
;;;2209            will lead to call HAL_UART_AbortCpltCallback() at end of DMA abort procedure */
;;;2210         huart->hdmatx->XferAbortCallback = UART_DMATxOnlyAbortCallback;
000050  480e              LDR      r0,|L21.140|
000052  6ba1              LDR      r1,[r4,#0x38]
000054  6508              STR      r0,[r1,#0x50]
;;;2211   
;;;2212         /* Abort DMA TX */
;;;2213         if (HAL_DMA_Abort_IT(huart->hdmatx) != HAL_OK)
000056  6ba0              LDR      r0,[r4,#0x38]
000058  f7fffffe          BL       HAL_DMA_Abort_IT
00005c  b1a0              CBZ      r0,|L21.136|
;;;2214         {
;;;2215           /* Call Directly huart->hdmatx->XferAbortCallback function in case of error */
;;;2216           huart->hdmatx->XferAbortCallback(huart->hdmatx);
00005e  6ba0              LDR      r0,[r4,#0x38]
000060  6d01              LDR      r1,[r0,#0x50]
000062  4788              BLX      r1
000064  e010              B        |L21.136|
                  |L21.102|
;;;2217         }
;;;2218       }
;;;2219       else
;;;2220       {
;;;2221         /* Reset Tx transfer counter */
;;;2222         huart->TxXferCount = 0x00U;
000066  2000              MOVS     r0,#0
000068  84e0              STRH     r0,[r4,#0x26]
;;;2223   
;;;2224         /* Restore huart->gState to Ready */
;;;2225         huart->gState = HAL_UART_STATE_READY;
00006a  2020              MOVS     r0,#0x20
00006c  f8840041          STRB     r0,[r4,#0x41]
;;;2226   
;;;2227         /* As no DMA to be aborted, call directly user Abort complete callback */
;;;2228   #if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
;;;2229         /* Call registered Abort Transmit Complete Callback */
;;;2230         huart->AbortTransmitCpltCallback(huart);
;;;2231   #else
;;;2232         /* Call legacy weak Abort Transmit Complete Callback */
;;;2233         HAL_UART_AbortTransmitCpltCallback(huart);
000070  4620              MOV      r0,r4
000072  f7fffffe          BL       HAL_UART_AbortTransmitCpltCallback
000076  e007              B        |L21.136|
                  |L21.120|
;;;2234   #endif /* USE_HAL_UART_REGISTER_CALLBACKS */
;;;2235       }
;;;2236     }
;;;2237     else
;;;2238     {
;;;2239       /* Reset Tx transfer counter */
;;;2240       huart->TxXferCount = 0x00U;
000078  2000              MOVS     r0,#0
00007a  84e0              STRH     r0,[r4,#0x26]
;;;2241   
;;;2242       /* Restore huart->gState to Ready */
;;;2243       huart->gState = HAL_UART_STATE_READY;
00007c  2020              MOVS     r0,#0x20
00007e  f8840041          STRB     r0,[r4,#0x41]
;;;2244   
;;;2245       /* As no DMA to be aborted, call directly user Abort complete callback */
;;;2246   #if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
;;;2247       /* Call registered Abort Transmit Complete Callback */
;;;2248       huart->AbortTransmitCpltCallback(huart);
;;;2249   #else
;;;2250       /* Call legacy weak Abort Transmit Complete Callback */
;;;2251       HAL_UART_AbortTransmitCpltCallback(huart);
000082  4620              MOV      r0,r4
000084  f7fffffe          BL       HAL_UART_AbortTransmitCpltCallback
                  |L21.136|
;;;2252   #endif /* USE_HAL_UART_REGISTER_CALLBACKS */
;;;2253     }
;;;2254   
;;;2255     return HAL_OK;
000088  2000              MOVS     r0,#0
;;;2256   }
00008a  bd10              POP      {r4,pc}
;;;2257   
                          ENDP

                  |L21.140|
                          DCD      UART_DMATxOnlyAbortCallback

                          AREA ||i.HAL_UART_Abort_IT||, CODE, READONLY, ALIGN=2

                  HAL_UART_Abort_IT PROC
;;;2059     */
;;;2060   HAL_StatusTypeDef HAL_UART_Abort_IT(UART_HandleTypeDef *huart)
000000  b570              PUSH     {r4-r6,lr}
;;;2061   {
000002  4604              MOV      r4,r0
;;;2062     uint32_t AbortCplt = 0x01U;
000004  2501              MOVS     r5,#1
;;;2063   
;;;2064     /* Disable TXEIE, TCIE, RXNE, PE and ERR (Frame error, noise error, overrun error) interrupts */
;;;2065     ATOMIC_CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE | USART_CR1_TXEIE | USART_CR1_TCIE));
000006  bf00              NOP      
000008  bf00              NOP      
                  |L22.10|
00000a  6821              LDR      r1,[r4,#0]
00000c  310c              ADDS     r1,r1,#0xc
00000e  e8511f00          LDREX    r1,[r1,#0]
000012  f42170f0          BIC      r0,r1,#0x1e0
000016  6821              LDR      r1,[r4,#0]
000018  310c              ADDS     r1,r1,#0xc
00001a  e8410200          STREX    r2,r0,[r1,#0]
00001e  2a00              CMP      r2,#0
000020  d1f3              BNE      |L22.10|
000022  bf00              NOP      
;;;2066     ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
000024  bf00              NOP      
000026  bf00              NOP      
                  |L22.40|
000028  6821              LDR      r1,[r4,#0]
00002a  3114              ADDS     r1,r1,#0x14
00002c  e8511f00          LDREX    r1,[r1,#0]
000030  f0210001          BIC      r0,r1,#1
000034  6821              LDR      r1,[r4,#0]
000036  3114              ADDS     r1,r1,#0x14
000038  e8410200          STREX    r2,r0,[r1,#0]
00003c  2a00              CMP      r2,#0
00003e  d1f3              BNE      |L22.40|
000040  bf00              NOP      
;;;2067   
;;;2068     /* If Reception till IDLE event was ongoing, disable IDLEIE interrupt */
;;;2069     if (huart->ReceptionType == HAL_UART_RECEPTION_TOIDLE)
000042  6b20              LDR      r0,[r4,#0x30]
000044  2801              CMP      r0,#1
000046  d10e              BNE      |L22.102|
;;;2070     {
;;;2071       ATOMIC_CLEAR_BIT(huart->Instance->CR1, (USART_CR1_IDLEIE));
000048  bf00              NOP      
00004a  bf00              NOP      
                  |L22.76|
00004c  6821              LDR      r1,[r4,#0]
00004e  310c              ADDS     r1,r1,#0xc
000050  e8511f00          LDREX    r1,[r1,#0]
000054  f0210010          BIC      r0,r1,#0x10
000058  6821              LDR      r1,[r4,#0]
00005a  310c              ADDS     r1,r1,#0xc
00005c  e8410200          STREX    r2,r0,[r1,#0]
000060  2a00              CMP      r2,#0
000062  d1f3              BNE      |L22.76|
000064  bf00              NOP      
                  |L22.102|
;;;2072     }
;;;2073   
;;;2074     /* If DMA Tx and/or DMA Rx Handles are associated to UART Handle, DMA Abort complete callbacks should be initialised
;;;2075        before any call to DMA Abort functions */
;;;2076     /* DMA Tx Handle is valid */
;;;2077     if (huart->hdmatx != NULL)
000066  6ba0              LDR      r0,[r4,#0x38]
000068  b160              CBZ      r0,|L22.132|
;;;2078     {
;;;2079       /* Set DMA Abort Complete callback if UART DMA Tx request if enabled.
;;;2080          Otherwise, set it to NULL */
;;;2081       if (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAT))
00006a  6820              LDR      r0,[r4,#0]
00006c  6940              LDR      r0,[r0,#0x14]
00006e  f0000080          AND      r0,r0,#0x80
000072  2880              CMP      r0,#0x80
000074  d103              BNE      |L22.126|
;;;2082       {
;;;2083         huart->hdmatx->XferAbortCallback = UART_DMATxAbortCallback;
000076  4834              LDR      r0,|L22.328|
000078  6ba1              LDR      r1,[r4,#0x38]
00007a  6508              STR      r0,[r1,#0x50]
00007c  e002              B        |L22.132|
                  |L22.126|
;;;2084       }
;;;2085       else
;;;2086       {
;;;2087         huart->hdmatx->XferAbortCallback = NULL;
00007e  2000              MOVS     r0,#0
000080  6ba1              LDR      r1,[r4,#0x38]
000082  6508              STR      r0,[r1,#0x50]
                  |L22.132|
;;;2088       }
;;;2089     }
;;;2090     /* DMA Rx Handle is valid */
;;;2091     if (huart->hdmarx != NULL)
000084  6be0              LDR      r0,[r4,#0x3c]
000086  b160              CBZ      r0,|L22.162|
;;;2092     {
;;;2093       /* Set DMA Abort Complete callback if UART DMA Rx request if enabled.
;;;2094          Otherwise, set it to NULL */
;;;2095       if (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR))
000088  6820              LDR      r0,[r4,#0]
00008a  6940              LDR      r0,[r0,#0x14]
00008c  f0000040          AND      r0,r0,#0x40
000090  2840              CMP      r0,#0x40
000092  d103              BNE      |L22.156|
;;;2096       {
;;;2097         huart->hdmarx->XferAbortCallback = UART_DMARxAbortCallback;
000094  482d              LDR      r0,|L22.332|
000096  6be1              LDR      r1,[r4,#0x3c]
000098  6508              STR      r0,[r1,#0x50]
00009a  e002              B        |L22.162|
                  |L22.156|
;;;2098       }
;;;2099       else
;;;2100       {
;;;2101         huart->hdmarx->XferAbortCallback = NULL;
00009c  2000              MOVS     r0,#0
00009e  6be1              LDR      r1,[r4,#0x3c]
0000a0  6508              STR      r0,[r1,#0x50]
                  |L22.162|
;;;2102       }
;;;2103     }
;;;2104   
;;;2105     /* Disable the UART DMA Tx request if enabled */
;;;2106     if (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAT))
0000a2  6820              LDR      r0,[r4,#0]
0000a4  6940              LDR      r0,[r0,#0x14]
0000a6  f0000080          AND      r0,r0,#0x80
0000aa  2880              CMP      r0,#0x80
0000ac  d119              BNE      |L22.226|
;;;2107     {
;;;2108       /* Disable DMA Tx at UART level */
;;;2109       ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAT);
0000ae  bf00              NOP      
0000b0  bf00              NOP      
                  |L22.178|
0000b2  6821              LDR      r1,[r4,#0]
0000b4  3114              ADDS     r1,r1,#0x14
0000b6  e8511f00          LDREX    r1,[r1,#0]
0000ba  f0210080          BIC      r0,r1,#0x80
0000be  6821              LDR      r1,[r4,#0]
0000c0  3114              ADDS     r1,r1,#0x14
0000c2  e8410200          STREX    r2,r0,[r1,#0]
0000c6  2a00              CMP      r2,#0
0000c8  d1f3              BNE      |L22.178|
0000ca  bf00              NOP      
;;;2110   
;;;2111       /* Abort the UART DMA Tx stream : use non blocking DMA Abort API (callback) */
;;;2112       if (huart->hdmatx != NULL)
0000cc  6ba0              LDR      r0,[r4,#0x38]
0000ce  b140              CBZ      r0,|L22.226|
;;;2113       {
;;;2114         /* UART Tx DMA Abort callback has already been initialised :
;;;2115            will lead to call HAL_UART_AbortCpltCallback() at end of DMA abort procedure */
;;;2116   
;;;2117         /* Abort DMA TX */
;;;2118         if (HAL_DMA_Abort_IT(huart->hdmatx) != HAL_OK)
0000d0  6ba0              LDR      r0,[r4,#0x38]
0000d2  f7fffffe          BL       HAL_DMA_Abort_IT
0000d6  b118              CBZ      r0,|L22.224|
;;;2119         {
;;;2120           huart->hdmatx->XferAbortCallback = NULL;
0000d8  2000              MOVS     r0,#0
0000da  6ba1              LDR      r1,[r4,#0x38]
0000dc  6508              STR      r0,[r1,#0x50]
0000de  e000              B        |L22.226|
                  |L22.224|
;;;2121         }
;;;2122         else
;;;2123         {
;;;2124           AbortCplt = 0x00U;
0000e0  2500              MOVS     r5,#0
                  |L22.226|
;;;2125         }
;;;2126       }
;;;2127     }
;;;2128   
;;;2129     /* Disable the UART DMA Rx request if enabled */
;;;2130     if (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR))
0000e2  6820              LDR      r0,[r4,#0]
0000e4  6940              LDR      r0,[r0,#0x14]
0000e6  f0000040          AND      r0,r0,#0x40
0000ea  2840              CMP      r0,#0x40
0000ec  d11a              BNE      |L22.292|
;;;2131     {
;;;2132       ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAR);
0000ee  bf00              NOP      
0000f0  bf00              NOP      
                  |L22.242|
0000f2  6821              LDR      r1,[r4,#0]
0000f4  3114              ADDS     r1,r1,#0x14
0000f6  e8511f00          LDREX    r1,[r1,#0]
0000fa  f0210040          BIC      r0,r1,#0x40
0000fe  6821              LDR      r1,[r4,#0]
000100  3114              ADDS     r1,r1,#0x14
000102  e8410200          STREX    r2,r0,[r1,#0]
000106  2a00              CMP      r2,#0
000108  d1f3              BNE      |L22.242|
00010a  bf00              NOP      
;;;2133   
;;;2134       /* Abort the UART DMA Rx stream : use non blocking DMA Abort API (callback) */
;;;2135       if (huart->hdmarx != NULL)
00010c  6be0              LDR      r0,[r4,#0x3c]
00010e  b148              CBZ      r0,|L22.292|
;;;2136       {
;;;2137         /* UART Rx DMA Abort callback has already been initialised :
;;;2138            will lead to call HAL_UART_AbortCpltCallback() at end of DMA abort procedure */
;;;2139   
;;;2140         /* Abort DMA RX */
;;;2141         if (HAL_DMA_Abort_IT(huart->hdmarx) != HAL_OK)
000110  6be0              LDR      r0,[r4,#0x3c]
000112  f7fffffe          BL       HAL_DMA_Abort_IT
000116  b120              CBZ      r0,|L22.290|
;;;2142         {
;;;2143           huart->hdmarx->XferAbortCallback = NULL;
000118  2000              MOVS     r0,#0
00011a  6be1              LDR      r1,[r4,#0x3c]
00011c  6508              STR      r0,[r1,#0x50]
;;;2144           AbortCplt = 0x01U;
00011e  2501              MOVS     r5,#1
000120  e000              B        |L22.292|
                  |L22.290|
;;;2145         }
;;;2146         else
;;;2147         {
;;;2148           AbortCplt = 0x00U;
000122  2500              MOVS     r5,#0
                  |L22.292|
;;;2149         }
;;;2150       }
;;;2151     }
;;;2152   
;;;2153     /* if no DMA abort complete callback execution is required => call user Abort Complete callback */
;;;2154     if (AbortCplt == 0x01U)
000124  2d01              CMP      r5,#1
000126  d10d              BNE      |L22.324|
;;;2155     {
;;;2156       /* Reset Tx and Rx transfer counters */
;;;2157       huart->TxXferCount = 0x00U;
000128  2000              MOVS     r0,#0
00012a  84e0              STRH     r0,[r4,#0x26]
;;;2158       huart->RxXferCount = 0x00U;
00012c  85e0              STRH     r0,[r4,#0x2e]
;;;2159   
;;;2160       /* Reset ErrorCode */
;;;2161       huart->ErrorCode = HAL_UART_ERROR_NONE;
00012e  6460              STR      r0,[r4,#0x44]
;;;2162   
;;;2163       /* Restore huart->gState and huart->RxState to Ready */
;;;2164       huart->gState  = HAL_UART_STATE_READY;
000130  2020              MOVS     r0,#0x20
000132  f8840041          STRB     r0,[r4,#0x41]
;;;2165       huart->RxState = HAL_UART_STATE_READY;
000136  f8840042          STRB     r0,[r4,#0x42]
;;;2166       huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
00013a  2000              MOVS     r0,#0
00013c  6320              STR      r0,[r4,#0x30]
;;;2167   
;;;2168       /* As no DMA to be aborted, call directly user Abort complete callback */
;;;2169   #if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
;;;2170       /* Call registered Abort complete callback */
;;;2171       huart->AbortCpltCallback(huart);
;;;2172   #else
;;;2173       /* Call legacy weak Abort complete callback */
;;;2174       HAL_UART_AbortCpltCallback(huart);
00013e  4620              MOV      r0,r4
000140  f7fffffe          BL       HAL_UART_AbortCpltCallback
                  |L22.324|
;;;2175   #endif /* USE_HAL_UART_REGISTER_CALLBACKS */
;;;2176     }
;;;2177   
;;;2178     return HAL_OK;
000144  2000              MOVS     r0,#0
;;;2179   }
000146  bd70              POP      {r4-r6,pc}
;;;2180   
                          ENDP

                  |L22.328|
                          DCD      UART_DMATxAbortCallback
                  |L22.332|
                          DCD      UART_DMARxAbortCallback

                          AREA ||i.HAL_UART_DMAPause||, CODE, READONLY, ALIGN=1

                  HAL_UART_DMAPause PROC
;;;1467     */
;;;1468   HAL_StatusTypeDef HAL_UART_DMAPause(UART_HandleTypeDef *huart)
000000  b510              PUSH     {r4,lr}
;;;1469   {
000002  4601              MOV      r1,r0
;;;1470     uint32_t dmarequest = 0x00U;
000004  2200              MOVS     r2,#0
;;;1471   
;;;1472     dmarequest = HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAT);
000006  6808              LDR      r0,[r1,#0]
000008  6940              LDR      r0,[r0,#0x14]
00000a  f3c012c0          UBFX     r2,r0,#7,#1
;;;1473     if ((huart->gState == HAL_UART_STATE_BUSY_TX) && dmarequest)
00000e  f8910041          LDRB     r0,[r1,#0x41]
000012  2821              CMP      r0,#0x21
000014  d10f              BNE      |L23.54|
000016  b172              CBZ      r2,|L23.54|
;;;1474     {
;;;1475       /* Disable the UART DMA Tx request */
;;;1476       ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAT);
000018  bf00              NOP      
00001a  bf00              NOP      
                  |L23.28|
00001c  680b              LDR      r3,[r1,#0]
00001e  3314              ADDS     r3,r3,#0x14
000020  e8533f00          LDREX    r3,[r3,#0]
000024  f0230080          BIC      r0,r3,#0x80
000028  680b              LDR      r3,[r1,#0]
00002a  3314              ADDS     r3,r3,#0x14
00002c  e8430400          STREX    r4,r0,[r3,#0]
000030  2c00              CMP      r4,#0
000032  d1f3              BNE      |L23.28|
000034  bf00              NOP      
                  |L23.54|
;;;1477     }
;;;1478   
;;;1479     dmarequest = HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR);
000036  6808              LDR      r0,[r1,#0]
000038  6940              LDR      r0,[r0,#0x14]
00003a  f3c01280          UBFX     r2,r0,#6,#1
;;;1480     if ((huart->RxState == HAL_UART_STATE_BUSY_RX) && dmarequest)
00003e  f8910042          LDRB     r0,[r1,#0x42]
000042  2822              CMP      r0,#0x22
000044  d12d              BNE      |L23.162|
000046  b362              CBZ      r2,|L23.162|
;;;1481     {
;;;1482       /* Disable RXNE, PE and ERR (Frame error, noise error, overrun error) interrupts */
;;;1483       ATOMIC_CLEAR_BIT(huart->Instance->CR1, USART_CR1_PEIE);
000048  bf00              NOP      
00004a  bf00              NOP      
                  |L23.76|
00004c  680b              LDR      r3,[r1,#0]
00004e  330c              ADDS     r3,r3,#0xc
000050  e8533f00          LDREX    r3,[r3,#0]
000054  f4237080          BIC      r0,r3,#0x100
000058  680b              LDR      r3,[r1,#0]
00005a  330c              ADDS     r3,r3,#0xc
00005c  e8430400          STREX    r4,r0,[r3,#0]
000060  2c00              CMP      r4,#0
000062  d1f3              BNE      |L23.76|
000064  bf00              NOP      
;;;1484       ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
000066  bf00              NOP      
000068  bf00              NOP      
                  |L23.106|
00006a  680b              LDR      r3,[r1,#0]
00006c  3314              ADDS     r3,r3,#0x14
00006e  e8533f00          LDREX    r3,[r3,#0]
000072  f0230001          BIC      r0,r3,#1
000076  680b              LDR      r3,[r1,#0]
000078  3314              ADDS     r3,r3,#0x14
00007a  e8430400          STREX    r4,r0,[r3,#0]
00007e  2c00              CMP      r4,#0
000080  d1f3              BNE      |L23.106|
000082  bf00              NOP      
;;;1485   
;;;1486       /* Disable the UART DMA Rx request */
;;;1487       ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAR);
000084  bf00              NOP      
000086  bf00              NOP      
                  |L23.136|
000088  680b              LDR      r3,[r1,#0]
00008a  3314              ADDS     r3,r3,#0x14
00008c  e8533f00          LDREX    r3,[r3,#0]
000090  f0230040          BIC      r0,r3,#0x40
000094  680b              LDR      r3,[r1,#0]
000096  3314              ADDS     r3,r3,#0x14
000098  e8430400          STREX    r4,r0,[r3,#0]
00009c  2c00              CMP      r4,#0
00009e  d1f3              BNE      |L23.136|
0000a0  bf00              NOP      
                  |L23.162|
;;;1488     }
;;;1489   
;;;1490     return HAL_OK;
0000a2  2000              MOVS     r0,#0
;;;1491   }
0000a4  bd10              POP      {r4,pc}
;;;1492   
                          ENDP


                          AREA ||i.HAL_UART_DMAResume||, CODE, READONLY, ALIGN=1

                  HAL_UART_DMAResume PROC
;;;1498     */
;;;1499   HAL_StatusTypeDef HAL_UART_DMAResume(UART_HandleTypeDef *huart)
000000  b508              PUSH     {r3,lr}
;;;1500   {
000002  4601              MOV      r1,r0
;;;1501   
;;;1502     if (huart->gState == HAL_UART_STATE_BUSY_TX)
000004  f8910041          LDRB     r0,[r1,#0x41]
000008  2821              CMP      r0,#0x21
00000a  d10e              BNE      |L24.42|
;;;1503     {
;;;1504       /* Enable the UART DMA Tx request */
;;;1505       ATOMIC_SET_BIT(huart->Instance->CR3, USART_CR3_DMAT);
00000c  bf00              NOP      
00000e  bf00              NOP      
                  |L24.16|
000010  680a              LDR      r2,[r1,#0]
000012  3214              ADDS     r2,r2,#0x14
000014  e8522f00          LDREX    r2,[r2,#0]
000018  f0420080          ORR      r0,r2,#0x80
00001c  680a              LDR      r2,[r1,#0]
00001e  3214              ADDS     r2,r2,#0x14
000020  e8420300          STREX    r3,r0,[r2,#0]
000024  2b00              CMP      r3,#0
000026  d1f3              BNE      |L24.16|
000028  bf00              NOP      
                  |L24.42|
;;;1506     }
;;;1507   
;;;1508     if (huart->RxState == HAL_UART_STATE_BUSY_RX)
00002a  f8910042          LDRB     r0,[r1,#0x42]
00002e  2822              CMP      r0,#0x22
000030  d139              BNE      |L24.166|
;;;1509     {
;;;1510       /* Clear the Overrun flag before resuming the Rx transfer*/
;;;1511       __HAL_UART_CLEAR_OREFLAG(huart);
000032  bf00              NOP      
000034  2000              MOVS     r0,#0
000036  9000              STR      r0,[sp,#0]
000038  6808              LDR      r0,[r1,#0]
00003a  6800              LDR      r0,[r0,#0]
00003c  9000              STR      r0,[sp,#0]
00003e  6808              LDR      r0,[r1,#0]
000040  6840              LDR      r0,[r0,#4]
000042  9000              STR      r0,[sp,#0]
000044  bf00              NOP      
000046  bf00              NOP      
;;;1512   
;;;1513       /* Re-enable PE and ERR (Frame error, noise error, overrun error) interrupts */
;;;1514       if (huart->Init.Parity != UART_PARITY_NONE)
000048  6908              LDR      r0,[r1,#0x10]
00004a  b170              CBZ      r0,|L24.106|
;;;1515       {
;;;1516         ATOMIC_SET_BIT(huart->Instance->CR1, USART_CR1_PEIE);
00004c  bf00              NOP      
00004e  bf00              NOP      
                  |L24.80|
000050  680a              LDR      r2,[r1,#0]
000052  320c              ADDS     r2,r2,#0xc
000054  e8522f00          LDREX    r2,[r2,#0]
000058  f4427080          ORR      r0,r2,#0x100
00005c  680a              LDR      r2,[r1,#0]
00005e  320c              ADDS     r2,r2,#0xc
000060  e8420300          STREX    r3,r0,[r2,#0]
000064  2b00              CMP      r3,#0
000066  d1f3              BNE      |L24.80|
000068  bf00              NOP      
                  |L24.106|
;;;1517       }
;;;1518       ATOMIC_SET_BIT(huart->Instance->CR3, USART_CR3_EIE);
00006a  bf00              NOP      
00006c  bf00              NOP      
                  |L24.110|
00006e  680a              LDR      r2,[r1,#0]
000070  3214              ADDS     r2,r2,#0x14
000072  e8522f00          LDREX    r2,[r2,#0]
000076  f0420001          ORR      r0,r2,#1
00007a  680a              LDR      r2,[r1,#0]
00007c  3214              ADDS     r2,r2,#0x14
00007e  e8420300          STREX    r3,r0,[r2,#0]
000082  2b00              CMP      r3,#0
000084  d1f3              BNE      |L24.110|
000086  bf00              NOP      
;;;1519   
;;;1520       /* Enable the UART DMA Rx request */
;;;1521       ATOMIC_SET_BIT(huart->Instance->CR3, USART_CR3_DMAR);
000088  bf00              NOP      
00008a  bf00              NOP      
                  |L24.140|
00008c  680a              LDR      r2,[r1,#0]
00008e  3214              ADDS     r2,r2,#0x14
000090  e8522f00          LDREX    r2,[r2,#0]
000094  f0420040          ORR      r0,r2,#0x40
000098  680a              LDR      r2,[r1,#0]
00009a  3214              ADDS     r2,r2,#0x14
00009c  e8420300          STREX    r3,r0,[r2,#0]
0000a0  2b00              CMP      r3,#0
0000a2  d1f3              BNE      |L24.140|
0000a4  bf00              NOP      
                  |L24.166|
;;;1522     }
;;;1523   
;;;1524     return HAL_OK;
0000a6  2000              MOVS     r0,#0
;;;1525   }
0000a8  bd08              POP      {r3,pc}
;;;1526   
                          ENDP


                          AREA ||i.HAL_UART_DMAStop||, CODE, READONLY, ALIGN=1

                  HAL_UART_DMAStop PROC
;;;1532     */
;;;1533   HAL_StatusTypeDef HAL_UART_DMAStop(UART_HandleTypeDef *huart)
000000  b570              PUSH     {r4-r6,lr}
;;;1534   {
000002  4604              MOV      r4,r0
;;;1535     uint32_t dmarequest = 0x00U;
000004  2500              MOVS     r5,#0
;;;1536     /* The Lock is not implemented on this API to allow the user application
;;;1537        to call the HAL UART API under callbacks HAL_UART_TxCpltCallback() / HAL_UART_RxCpltCallback():
;;;1538        when calling HAL_DMA_Abort() API the DMA TX/RX Transfer complete interrupt is generated
;;;1539        and the correspond call back is executed HAL_UART_TxCpltCallback() / HAL_UART_RxCpltCallback()
;;;1540        */
;;;1541   
;;;1542     /* Stop UART DMA Tx request if ongoing */
;;;1543     dmarequest = HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAT);
000006  6820              LDR      r0,[r4,#0]
000008  6940              LDR      r0,[r0,#0x14]
00000a  f3c015c0          UBFX     r5,r0,#7,#1
;;;1544     if ((huart->gState == HAL_UART_STATE_BUSY_TX) && dmarequest)
00000e  f8940041          LDRB     r0,[r4,#0x41]
000012  2821              CMP      r0,#0x21
000014  d117              BNE      |L25.70|
000016  b1b5              CBZ      r5,|L25.70|
;;;1545     {
;;;1546       ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAT);
000018  bf00              NOP      
00001a  bf00              NOP      
                  |L25.28|
00001c  6821              LDR      r1,[r4,#0]
00001e  3114              ADDS     r1,r1,#0x14
000020  e8511f00          LDREX    r1,[r1,#0]
000024  f0210080          BIC      r0,r1,#0x80
000028  6821              LDR      r1,[r4,#0]
00002a  3114              ADDS     r1,r1,#0x14
00002c  e8410200          STREX    r2,r0,[r1,#0]
000030  2a00              CMP      r2,#0
000032  d1f3              BNE      |L25.28|
000034  bf00              NOP      
;;;1547   
;;;1548       /* Abort the UART DMA Tx stream */
;;;1549       if (huart->hdmatx != NULL)
000036  6ba0              LDR      r0,[r4,#0x38]
000038  b110              CBZ      r0,|L25.64|
;;;1550       {
;;;1551         HAL_DMA_Abort(huart->hdmatx);
00003a  6ba0              LDR      r0,[r4,#0x38]
00003c  f7fffffe          BL       HAL_DMA_Abort
                  |L25.64|
;;;1552       }
;;;1553       UART_EndTxTransfer(huart);
000040  4620              MOV      r0,r4
000042  f7fffffe          BL       UART_EndTxTransfer
                  |L25.70|
;;;1554     }
;;;1555   
;;;1556     /* Stop UART DMA Rx request if ongoing */
;;;1557     dmarequest = HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR);
000046  6820              LDR      r0,[r4,#0]
000048  6940              LDR      r0,[r0,#0x14]
00004a  f3c01580          UBFX     r5,r0,#6,#1
;;;1558     if ((huart->RxState == HAL_UART_STATE_BUSY_RX) && dmarequest)
00004e  f8940042          LDRB     r0,[r4,#0x42]
000052  2822              CMP      r0,#0x22
000054  d117              BNE      |L25.134|
000056  b1b5              CBZ      r5,|L25.134|
;;;1559     {
;;;1560       ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAR);
000058  bf00              NOP      
00005a  bf00              NOP      
                  |L25.92|
00005c  6821              LDR      r1,[r4,#0]
00005e  3114              ADDS     r1,r1,#0x14
000060  e8511f00          LDREX    r1,[r1,#0]
000064  f0210040          BIC      r0,r1,#0x40
000068  6821              LDR      r1,[r4,#0]
00006a  3114              ADDS     r1,r1,#0x14
00006c  e8410200          STREX    r2,r0,[r1,#0]
000070  2a00              CMP      r2,#0
000072  d1f3              BNE      |L25.92|
000074  bf00              NOP      
;;;1561   
;;;1562       /* Abort the UART DMA Rx stream */
;;;1563       if (huart->hdmarx != NULL)
000076  6be0              LDR      r0,[r4,#0x3c]
000078  b110              CBZ      r0,|L25.128|
;;;1564       {
;;;1565         HAL_DMA_Abort(huart->hdmarx);
00007a  6be0              LDR      r0,[r4,#0x3c]
00007c  f7fffffe          BL       HAL_DMA_Abort
                  |L25.128|
;;;1566       }
;;;1567       UART_EndRxTransfer(huart);
000080  4620              MOV      r0,r4
000082  f7fffffe          BL       UART_EndRxTransfer
                  |L25.134|
;;;1568     }
;;;1569   
;;;1570     return HAL_OK;
000086  2000              MOVS     r0,#0
;;;1571   }
000088  bd70              POP      {r4-r6,pc}
;;;1572   
                          ENDP


                          AREA ||i.HAL_UART_DeInit||, CODE, READONLY, ALIGN=1

                  HAL_UART_DeInit PROC
;;;668      */
;;;669    HAL_StatusTypeDef HAL_UART_DeInit(UART_HandleTypeDef *huart)
000000  b510              PUSH     {r4,lr}
;;;670    {
000002  4604              MOV      r4,r0
;;;671      /* Check the UART handle allocation */
;;;672      if (huart == NULL)
000004  b90c              CBNZ     r4,|L26.10|
;;;673      {
;;;674        return HAL_ERROR;
000006  2001              MOVS     r0,#1
                  |L26.8|
;;;675      }
;;;676    
;;;677      /* Check the parameters */
;;;678      assert_param(IS_UART_INSTANCE(huart->Instance));
;;;679    
;;;680      huart->gState = HAL_UART_STATE_BUSY;
;;;681    
;;;682      /* Disable the Peripheral */
;;;683      __HAL_UART_DISABLE(huart);
;;;684    
;;;685    #if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
;;;686      if (huart->MspDeInitCallback == NULL)
;;;687      {
;;;688        huart->MspDeInitCallback = HAL_UART_MspDeInit;
;;;689      }
;;;690      /* DeInit the low level hardware */
;;;691      huart->MspDeInitCallback(huart);
;;;692    #else
;;;693      /* DeInit the low level hardware */
;;;694      HAL_UART_MspDeInit(huart);
;;;695    #endif /* (USE_HAL_UART_REGISTER_CALLBACKS) */
;;;696    
;;;697      huart->ErrorCode = HAL_UART_ERROR_NONE;
;;;698      huart->gState = HAL_UART_STATE_RESET;
;;;699      huart->RxState = HAL_UART_STATE_RESET;
;;;700      huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
;;;701      huart->RxEventType = HAL_UART_RXEVENT_TC;
;;;702    
;;;703      /* Process Unlock */
;;;704      __HAL_UNLOCK(huart);
;;;705    
;;;706      return HAL_OK;
;;;707    }
000008  bd10              POP      {r4,pc}
                  |L26.10|
00000a  2024              MOVS     r0,#0x24              ;680
00000c  f8840041          STRB     r0,[r4,#0x41]         ;680
000010  6820              LDR      r0,[r4,#0]            ;683
000012  68c0              LDR      r0,[r0,#0xc]          ;683
000014  f4205000          BIC      r0,r0,#0x2000         ;683
000018  6821              LDR      r1,[r4,#0]            ;683
00001a  60c8              STR      r0,[r1,#0xc]          ;683
00001c  4620              MOV      r0,r4                 ;694
00001e  f7fffffe          BL       HAL_UART_MspDeInit
000022  2000              MOVS     r0,#0                 ;697
000024  6460              STR      r0,[r4,#0x44]         ;697
000026  f8840041          STRB     r0,[r4,#0x41]         ;698
00002a  f8840042          STRB     r0,[r4,#0x42]         ;699
00002e  6320              STR      r0,[r4,#0x30]         ;700
000030  6360              STR      r0,[r4,#0x34]         ;701
000032  bf00              NOP                            ;704
000034  f8840040          STRB     r0,[r4,#0x40]         ;704
000038  bf00              NOP                            ;704
00003a  bf00              NOP                            ;706
00003c  e7e4              B        |L26.8|
;;;708    
                          ENDP


                          AREA ||i.HAL_UART_ErrorCallback||, CODE, READONLY, ALIGN=1

                  HAL_UART_ErrorCallback PROC
;;;2651     */
;;;2652   __weak void HAL_UART_ErrorCallback(UART_HandleTypeDef *huart)
000000  4770              BX       lr
;;;2653   {
;;;2654     /* Prevent unused argument(s) compilation warning */
;;;2655     UNUSED(huart);
;;;2656     /* NOTE: This function should not be modified, when the callback is needed,
;;;2657              the HAL_UART_ErrorCallback could be implemented in the user file
;;;2658      */
;;;2659   }
;;;2660   
                          ENDP


                          AREA ||i.HAL_UART_GetError||, CODE, READONLY, ALIGN=1

                  HAL_UART_GetError PROC
;;;2942     */
;;;2943   uint32_t HAL_UART_GetError(const UART_HandleTypeDef *huart)
000000  4601              MOV      r1,r0
;;;2944   {
;;;2945     return huart->ErrorCode;
000002  6c48              LDR      r0,[r1,#0x44]
;;;2946   }
000004  4770              BX       lr
;;;2947   
                          ENDP


                          AREA ||i.HAL_UART_GetState||, CODE, READONLY, ALIGN=1

                  HAL_UART_GetState PROC
;;;2927     */
;;;2928   HAL_UART_StateTypeDef HAL_UART_GetState(const UART_HandleTypeDef *huart)
000000  4601              MOV      r1,r0
;;;2929   {
;;;2930     uint32_t temp1 = 0x00U, temp2 = 0x00U;
000002  2200              MOVS     r2,#0
000004  2300              MOVS     r3,#0
;;;2931     temp1 = huart->gState;
000006  f8912041          LDRB     r2,[r1,#0x41]
;;;2932     temp2 = huart->RxState;
00000a  f8913042          LDRB     r3,[r1,#0x42]
;;;2933   
;;;2934     return (HAL_UART_StateTypeDef)(temp1 | temp2);
00000e  ea420003          ORR      r0,r2,r3
;;;2935   }
000012  4770              BX       lr
;;;2936   
                          ENDP


                          AREA ||i.HAL_UART_IRQHandler||, CODE, READONLY, ALIGN=2

                  HAL_UART_IRQHandler PROC
;;;2349     */
;;;2350   void HAL_UART_IRQHandler(UART_HandleTypeDef *huart)
000000  e92d4ff8          PUSH     {r3-r11,lr}
;;;2351   {
000004  4604              MOV      r4,r0
;;;2352     uint32_t isrflags   = READ_REG(huart->Instance->SR);
000006  6820              LDR      r0,[r4,#0]
000008  6805              LDR      r5,[r0,#0]
;;;2353     uint32_t cr1its     = READ_REG(huart->Instance->CR1);
00000a  6820              LDR      r0,[r4,#0]
00000c  68c6              LDR      r6,[r0,#0xc]
;;;2354     uint32_t cr3its     = READ_REG(huart->Instance->CR3);
00000e  6820              LDR      r0,[r4,#0]
000010  6947              LDR      r7,[r0,#0x14]
;;;2355     uint32_t errorflags = 0x00U;
000012  f04f0900          MOV      r9,#0
;;;2356     uint32_t dmarequest = 0x00U;
000016  46ca              MOV      r10,r9
;;;2357   
;;;2358     /* If no error occurs */
;;;2359     errorflags = (isrflags & (uint32_t)(USART_SR_PE | USART_SR_FE | USART_SR_ORE | USART_SR_NE));
000018  f005090f          AND      r9,r5,#0xf
;;;2360     if (errorflags == RESET)
00001c  f1b90f00          CMP      r9,#0
000020  d10a              BNE      |L30.56|
;;;2361     {
;;;2362       /* UART in mode Receiver -------------------------------------------------*/
;;;2363       if (((isrflags & USART_SR_RXNE) != RESET) && ((cr1its & USART_CR1_RXNEIE) != RESET))
000022  f0050020          AND      r0,r5,#0x20
000026  b138              CBZ      r0,|L30.56|
000028  f0060020          AND      r0,r6,#0x20
00002c  b120              CBZ      r0,|L30.56|
;;;2364       {
;;;2365         UART_Receive_IT(huart);
00002e  4620              MOV      r0,r4
000030  f7fffffe          BL       UART_Receive_IT
                  |L30.52|
;;;2366         return;
;;;2367       }
;;;2368     }
;;;2369   
;;;2370     /* If some errors occur */
;;;2371     if ((errorflags != RESET) && (((cr3its & USART_CR3_EIE) != RESET)
;;;2372                                   || ((cr1its & (USART_CR1_RXNEIE | USART_CR1_PEIE)) != RESET)))
;;;2373     {
;;;2374       /* UART parity error interrupt occurred ----------------------------------*/
;;;2375       if (((isrflags & USART_SR_PE) != RESET) && ((cr1its & USART_CR1_PEIE) != RESET))
;;;2376       {
;;;2377         huart->ErrorCode |= HAL_UART_ERROR_PE;
;;;2378       }
;;;2379   
;;;2380       /* UART noise error interrupt occurred -----------------------------------*/
;;;2381       if (((isrflags & USART_SR_NE) != RESET) && ((cr3its & USART_CR3_EIE) != RESET))
;;;2382       {
;;;2383         huart->ErrorCode |= HAL_UART_ERROR_NE;
;;;2384       }
;;;2385   
;;;2386       /* UART frame error interrupt occurred -----------------------------------*/
;;;2387       if (((isrflags & USART_SR_FE) != RESET) && ((cr3its & USART_CR3_EIE) != RESET))
;;;2388       {
;;;2389         huart->ErrorCode |= HAL_UART_ERROR_FE;
;;;2390       }
;;;2391   
;;;2392       /* UART Over-Run interrupt occurred --------------------------------------*/
;;;2393       if (((isrflags & USART_SR_ORE) != RESET) && (((cr1its & USART_CR1_RXNEIE) != RESET)
;;;2394                                                    || ((cr3its & USART_CR3_EIE) != RESET)))
;;;2395       {
;;;2396         huart->ErrorCode |= HAL_UART_ERROR_ORE;
;;;2397       }
;;;2398   
;;;2399       /* Call UART Error Call back function if need be --------------------------*/
;;;2400       if (huart->ErrorCode != HAL_UART_ERROR_NONE)
;;;2401       {
;;;2402         /* UART in mode Receiver -----------------------------------------------*/
;;;2403         if (((isrflags & USART_SR_RXNE) != RESET) && ((cr1its & USART_CR1_RXNEIE) != RESET))
;;;2404         {
;;;2405           UART_Receive_IT(huart);
;;;2406         }
;;;2407   
;;;2408         /* If Overrun error occurs, or if any error occurs in DMA mode reception,
;;;2409            consider error as blocking */
;;;2410         dmarequest = HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR);
;;;2411         if (((huart->ErrorCode & HAL_UART_ERROR_ORE) != RESET) || dmarequest)
;;;2412         {
;;;2413           /* Blocking error : transfer is aborted
;;;2414              Set the UART state ready to be able to start again the process,
;;;2415              Disable Rx Interrupts, and disable Rx DMA request, if ongoing */
;;;2416           UART_EndRxTransfer(huart);
;;;2417   
;;;2418           /* Disable the UART DMA Rx request if enabled */
;;;2419           if (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR))
;;;2420           {
;;;2421             ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAR);
;;;2422   
;;;2423             /* Abort the UART DMA Rx stream */
;;;2424             if (huart->hdmarx != NULL)
;;;2425             {
;;;2426               /* Set the UART DMA Abort callback :
;;;2427                  will lead to call HAL_UART_ErrorCallback() at end of DMA abort procedure */
;;;2428               huart->hdmarx->XferAbortCallback = UART_DMAAbortOnError;
;;;2429               if (HAL_DMA_Abort_IT(huart->hdmarx) != HAL_OK)
;;;2430               {
;;;2431                 /* Call Directly XferAbortCallback function in case of error */
;;;2432                 huart->hdmarx->XferAbortCallback(huart->hdmarx);
;;;2433               }
;;;2434             }
;;;2435             else
;;;2436             {
;;;2437               /* Call user error callback */
;;;2438   #if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
;;;2439               /*Call registered error callback*/
;;;2440               huart->ErrorCallback(huart);
;;;2441   #else
;;;2442               /*Call legacy weak error callback*/
;;;2443               HAL_UART_ErrorCallback(huart);
;;;2444   #endif /* USE_HAL_UART_REGISTER_CALLBACKS */
;;;2445             }
;;;2446           }
;;;2447           else
;;;2448           {
;;;2449             /* Call user error callback */
;;;2450   #if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
;;;2451             /*Call registered error callback*/
;;;2452             huart->ErrorCallback(huart);
;;;2453   #else
;;;2454             /*Call legacy weak error callback*/
;;;2455             HAL_UART_ErrorCallback(huart);
;;;2456   #endif /* USE_HAL_UART_REGISTER_CALLBACKS */
;;;2457           }
;;;2458         }
;;;2459         else
;;;2460         {
;;;2461           /* Non Blocking error : transfer could go on.
;;;2462              Error is notified to user through user error callback */
;;;2463   #if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
;;;2464           /*Call registered error callback*/
;;;2465           huart->ErrorCallback(huart);
;;;2466   #else
;;;2467           /*Call legacy weak error callback*/
;;;2468           HAL_UART_ErrorCallback(huart);
;;;2469   #endif /* USE_HAL_UART_REGISTER_CALLBACKS */
;;;2470   
;;;2471           huart->ErrorCode = HAL_UART_ERROR_NONE;
;;;2472         }
;;;2473       }
;;;2474       return;
;;;2475     } /* End if some error occurs */
;;;2476   
;;;2477     /* Check current reception Mode :
;;;2478        If Reception till IDLE event has been selected : */
;;;2479     if ((huart->ReceptionType == HAL_UART_RECEPTION_TOIDLE)
;;;2480         && ((isrflags & USART_SR_IDLE) != 0U)
;;;2481         && ((cr1its & USART_SR_IDLE) != 0U))
;;;2482     {
;;;2483       __HAL_UART_CLEAR_IDLEFLAG(huart);
;;;2484   
;;;2485       /* Check if DMA mode is enabled in UART */
;;;2486       if (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR))
;;;2487       {
;;;2488         /* DMA mode enabled */
;;;2489         /* Check received length : If all expected data are received, do nothing,
;;;2490            (DMA cplt callback will be called).
;;;2491            Otherwise, if at least one data has already been received, IDLE event is to be notified to user */
;;;2492         uint16_t nb_remaining_rx_data = (uint16_t) __HAL_DMA_GET_COUNTER(huart->hdmarx);
;;;2493         if ((nb_remaining_rx_data > 0U)
;;;2494             && (nb_remaining_rx_data < huart->RxXferSize))
;;;2495         {
;;;2496           /* Reception is not complete */
;;;2497           huart->RxXferCount = nb_remaining_rx_data;
;;;2498   
;;;2499           /* In Normal mode, end DMA xfer and HAL UART Rx process*/
;;;2500           if (huart->hdmarx->Init.Mode != DMA_CIRCULAR)
;;;2501           {
;;;2502             /* Disable PE and ERR (Frame error, noise error, overrun error) interrupts */
;;;2503             ATOMIC_CLEAR_BIT(huart->Instance->CR1, USART_CR1_PEIE);
;;;2504             ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
;;;2505   
;;;2506             /* Disable the DMA transfer for the receiver request by resetting the DMAR bit
;;;2507                in the UART CR3 register */
;;;2508             ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAR);
;;;2509   
;;;2510             /* At end of Rx process, restore huart->RxState to Ready */
;;;2511             huart->RxState = HAL_UART_STATE_READY;
;;;2512             huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
;;;2513   
;;;2514             ATOMIC_CLEAR_BIT(huart->Instance->CR1, USART_CR1_IDLEIE);
;;;2515   
;;;2516             /* Last bytes received, so no need as the abort is immediate */
;;;2517             (void)HAL_DMA_Abort(huart->hdmarx);
;;;2518           }
;;;2519   
;;;2520           /* Initialize type of RxEvent that correspond to RxEvent callback execution;
;;;2521           In this case, Rx Event type is Idle Event */
;;;2522           huart->RxEventType = HAL_UART_RXEVENT_IDLE;
;;;2523   
;;;2524   #if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
;;;2525           /*Call registered Rx Event callback*/
;;;2526           huart->RxEventCallback(huart, (huart->RxXferSize - huart->RxXferCount));
;;;2527   #else
;;;2528           /*Call legacy weak Rx Event callback*/
;;;2529           HAL_UARTEx_RxEventCallback(huart, (huart->RxXferSize - huart->RxXferCount));
;;;2530   #endif /* USE_HAL_UART_REGISTER_CALLBACKS */
;;;2531         }
;;;2532         return;
;;;2533       }
;;;2534       else
;;;2535       {
;;;2536         /* DMA mode not enabled */
;;;2537         /* Check received length : If all expected data are received, do nothing.
;;;2538            Otherwise, if at least one data has already been received, IDLE event is to be notified to user */
;;;2539         uint16_t nb_rx_data = huart->RxXferSize - huart->RxXferCount;
;;;2540         if ((huart->RxXferCount > 0U)
;;;2541             && (nb_rx_data > 0U))
;;;2542         {
;;;2543           /* Disable the UART Parity Error Interrupt and RXNE interrupts */
;;;2544           ATOMIC_CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE));
;;;2545   
;;;2546           /* Disable the UART Error Interrupt: (Frame error, noise error, overrun error) */
;;;2547           ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
;;;2548   
;;;2549           /* Rx process is completed, restore huart->RxState to Ready */
;;;2550           huart->RxState = HAL_UART_STATE_READY;
;;;2551           huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
;;;2552   
;;;2553           ATOMIC_CLEAR_BIT(huart->Instance->CR1, USART_CR1_IDLEIE);
;;;2554   
;;;2555           /* Initialize type of RxEvent that correspond to RxEvent callback execution;
;;;2556              In this case, Rx Event type is Idle Event */
;;;2557           huart->RxEventType = HAL_UART_RXEVENT_IDLE;
;;;2558   
;;;2559   #if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
;;;2560           /*Call registered Rx complete callback*/
;;;2561           huart->RxEventCallback(huart, nb_rx_data);
;;;2562   #else
;;;2563           /*Call legacy weak Rx Event callback*/
;;;2564           HAL_UARTEx_RxEventCallback(huart, nb_rx_data);
;;;2565   #endif /* USE_HAL_UART_REGISTER_CALLBACKS */
;;;2566         }
;;;2567         return;
;;;2568       }
;;;2569     }
;;;2570   
;;;2571     /* UART in mode Transmitter ------------------------------------------------*/
;;;2572     if (((isrflags & USART_SR_TXE) != RESET) && ((cr1its & USART_CR1_TXEIE) != RESET))
;;;2573     {
;;;2574       UART_Transmit_IT(huart);
;;;2575       return;
;;;2576     }
;;;2577   
;;;2578     /* UART in mode Transmitter end --------------------------------------------*/
;;;2579     if (((isrflags & USART_SR_TC) != RESET) && ((cr1its & USART_CR1_TCIE) != RESET))
;;;2580     {
;;;2581       UART_EndTransmit_IT(huart);
;;;2582       return;
;;;2583     }
;;;2584   }
000034  e8bd8ff8          POP      {r3-r11,pc}
                  |L30.56|
000038  f1b90f00          CMP      r9,#0                 ;2371
00003c  d07c              BEQ      |L30.312|
00003e  f0070001          AND      r0,r7,#1              ;2371
000042  b918              CBNZ     r0,|L30.76|
000044  f4067090          AND      r0,r6,#0x120          ;2372
000048  2800              CMP      r0,#0                 ;2372
00004a  d075              BEQ      |L30.312|
                  |L30.76|
00004c  f0050001          AND      r0,r5,#1              ;2375
000050  b130              CBZ      r0,|L30.96|
000052  f4067080          AND      r0,r6,#0x100          ;2375
000056  b118              CBZ      r0,|L30.96|
000058  6c60              LDR      r0,[r4,#0x44]         ;2377
00005a  f0400001          ORR      r0,r0,#1              ;2377
00005e  6460              STR      r0,[r4,#0x44]         ;2377
                  |L30.96|
000060  f0050004          AND      r0,r5,#4              ;2381
000064  b130              CBZ      r0,|L30.116|
000066  f0070001          AND      r0,r7,#1              ;2381
00006a  b118              CBZ      r0,|L30.116|
00006c  6c60              LDR      r0,[r4,#0x44]         ;2383
00006e  f0400002          ORR      r0,r0,#2              ;2383
000072  6460              STR      r0,[r4,#0x44]         ;2383
                  |L30.116|
000074  f0050002          AND      r0,r5,#2              ;2387
000078  b130              CBZ      r0,|L30.136|
00007a  f0070001          AND      r0,r7,#1              ;2387
00007e  b118              CBZ      r0,|L30.136|
000080  6c60              LDR      r0,[r4,#0x44]         ;2389
000082  f0400004          ORR      r0,r0,#4              ;2389
000086  6460              STR      r0,[r4,#0x44]         ;2389
                  |L30.136|
000088  f0050008          AND      r0,r5,#8              ;2393
00008c  b148              CBZ      r0,|L30.162|
00008e  f0060020          AND      r0,r6,#0x20           ;2393
000092  b910              CBNZ     r0,|L30.154|
000094  f0070001          AND      r0,r7,#1              ;2394
000098  b118              CBZ      r0,|L30.162|
                  |L30.154|
00009a  6c60              LDR      r0,[r4,#0x44]         ;2396
00009c  f0400008          ORR      r0,r0,#8              ;2396
0000a0  6460              STR      r0,[r4,#0x44]         ;2396
                  |L30.162|
0000a2  6c60              LDR      r0,[r4,#0x44]         ;2400
0000a4  2800              CMP      r0,#0                 ;2400
0000a6  d046              BEQ      |L30.310|
0000a8  f0050020          AND      r0,r5,#0x20           ;2403
0000ac  b128              CBZ      r0,|L30.186|
0000ae  f0060020          AND      r0,r6,#0x20           ;2403
0000b2  b110              CBZ      r0,|L30.186|
0000b4  4620              MOV      r0,r4                 ;2405
0000b6  f7fffffe          BL       UART_Receive_IT
                  |L30.186|
0000ba  6820              LDR      r0,[r4,#0]            ;2410
0000bc  6940              LDR      r0,[r0,#0x14]         ;2410
0000be  f3c01a80          UBFX     r10,r0,#6,#1          ;2410
0000c2  6c60              LDR      r0,[r4,#0x44]         ;2411
0000c4  f0000008          AND      r0,r0,#8              ;2411
0000c8  b910              CBNZ     r0,|L30.208|
0000ca  f1ba0f00          CMP      r10,#0                ;2411
0000ce  d02d              BEQ      |L30.300|
                  |L30.208|
0000d0  4620              MOV      r0,r4                 ;2416
0000d2  f7fffffe          BL       UART_EndRxTransfer
0000d6  6820              LDR      r0,[r4,#0]            ;2419
0000d8  6940              LDR      r0,[r0,#0x14]         ;2419
0000da  f0000040          AND      r0,r0,#0x40           ;2419
0000de  2840              CMP      r0,#0x40              ;2419
0000e0  d120              BNE      |L30.292|
0000e2  bf00              NOP                            ;2421
0000e4  bf00              NOP                            ;2421
                  |L30.230|
0000e6  6821              LDR      r1,[r4,#0]            ;2421
0000e8  3114              ADDS     r1,r1,#0x14           ;2421
0000ea  e8511f00          LDREX    r1,[r1,#0]            ;2421
0000ee  f0210040          BIC      r0,r1,#0x40           ;2421
0000f2  6821              LDR      r1,[r4,#0]            ;2421
0000f4  3114              ADDS     r1,r1,#0x14           ;2421
0000f6  e8410200          STREX    r2,r0,[r1,#0]         ;2421
0000fa  2a00              CMP      r2,#0                 ;2421
0000fc  d1f3              BNE      |L30.230|
0000fe  bf00              NOP                            ;2421
000100  6be0              LDR      r0,[r4,#0x3c]         ;2424
000102  b150              CBZ      r0,|L30.282|
000104  4877              LDR      r0,|L30.740|
000106  6be1              LDR      r1,[r4,#0x3c]         ;2428
000108  6508              STR      r0,[r1,#0x50]         ;2428
00010a  6be0              LDR      r0,[r4,#0x3c]         ;2429
00010c  f7fffffe          BL       HAL_DMA_Abort_IT
000110  b188              CBZ      r0,|L30.310|
000112  6be0              LDR      r0,[r4,#0x3c]         ;2432
000114  6d01              LDR      r1,[r0,#0x50]         ;2432
000116  4788              BLX      r1                    ;2432
000118  e00d              B        |L30.310|
                  |L30.282|
00011a  4620              MOV      r0,r4                 ;2443
00011c  f7fffffe          BL       HAL_UART_ErrorCallback
000120  e009              B        |L30.310|
000122  e009              B        |L30.312|
                  |L30.292|
000124  4620              MOV      r0,r4                 ;2455
000126  f7fffffe          BL       HAL_UART_ErrorCallback
00012a  e004              B        |L30.310|
                  |L30.300|
00012c  4620              MOV      r0,r4                 ;2468
00012e  f7fffffe          BL       HAL_UART_ErrorCallback
000132  2000              MOVS     r0,#0                 ;2471
000134  6460              STR      r0,[r4,#0x44]         ;2471
                  |L30.310|
000136  e77d              B        |L30.52|
                  |L30.312|
000138  6b20              LDR      r0,[r4,#0x30]         ;2479
00013a  2801              CMP      r0,#1                 ;2479
00013c  d178              BNE      |L30.560|
00013e  f0050010          AND      r0,r5,#0x10           ;2480
000142  2800              CMP      r0,#0                 ;2480
                  |L30.324|
000144  d074              BEQ      |L30.560|
000146  f0060010          AND      r0,r6,#0x10           ;2481
00014a  2800              CMP      r0,#0                 ;2481
00014c  d0fa              BEQ      |L30.324|
00014e  bf00              NOP                            ;2483
000150  2000              MOVS     r0,#0                 ;2483
000152  9000              STR      r0,[sp,#0]            ;2483
000154  6820              LDR      r0,[r4,#0]            ;2483
000156  6800              LDR      r0,[r0,#0]            ;2483
000158  9000              STR      r0,[sp,#0]            ;2483
00015a  6820              LDR      r0,[r4,#0]            ;2483
00015c  6840              LDR      r0,[r0,#4]            ;2483
00015e  9000              STR      r0,[sp,#0]            ;2483
000160  bf00              NOP                            ;2483
000162  bf00              NOP                            ;2483
000164  6820              LDR      r0,[r4,#0]            ;2486
000166  6940              LDR      r0,[r0,#0x14]         ;2486
000168  f0000040          AND      r0,r0,#0x40           ;2486
00016c  2840              CMP      r0,#0x40              ;2486
00016e  d160              BNE      |L30.562|
000170  6be0              LDR      r0,[r4,#0x3c]         ;2492
000172  6800              LDR      r0,[r0,#0]            ;2492
000174  6840              LDR      r0,[r0,#4]            ;2492
000176  fa1ff880          UXTH     r8,r0                 ;2492
00017a  f1b80f00          CMP      r8,#0                 ;2493
00017e  d056              BEQ      |L30.558|
000180  8da0              LDRH     r0,[r4,#0x2c]         ;2494
000182  4540              CMP      r0,r8                 ;2494
000184  dd53              BLE      |L30.558|
000186  f8a4802e          STRH     r8,[r4,#0x2e]         ;2497
00018a  6be0              LDR      r0,[r4,#0x3c]         ;2500
00018c  69c0              LDR      r0,[r0,#0x1c]         ;2500
00018e  f5b07f80          CMP      r0,#0x100             ;2500
000192  d043              BEQ      |L30.540|
000194  bf00              NOP                            ;2503
000196  bf00              NOP                            ;2503
                  |L30.408|
000198  6821              LDR      r1,[r4,#0]            ;2503
00019a  310c              ADDS     r1,r1,#0xc            ;2503
00019c  e8511f00          LDREX    r1,[r1,#0]            ;2503
0001a0  f4217080          BIC      r0,r1,#0x100          ;2503
0001a4  6821              LDR      r1,[r4,#0]            ;2503
0001a6  310c              ADDS     r1,r1,#0xc            ;2503
0001a8  e8410200          STREX    r2,r0,[r1,#0]         ;2503
0001ac  2a00              CMP      r2,#0                 ;2503
0001ae  d1f3              BNE      |L30.408|
0001b0  bf00              NOP                            ;2503
0001b2  bf00              NOP                            ;2504
0001b4  bf00              NOP                            ;2504
                  |L30.438|
0001b6  6821              LDR      r1,[r4,#0]            ;2504
0001b8  3114              ADDS     r1,r1,#0x14           ;2504
0001ba  e8511f00          LDREX    r1,[r1,#0]            ;2504
0001be  f0210001          BIC      r0,r1,#1              ;2504
0001c2  6821              LDR      r1,[r4,#0]            ;2504
0001c4  3114              ADDS     r1,r1,#0x14           ;2504
0001c6  e8410200          STREX    r2,r0,[r1,#0]         ;2504
0001ca  2a00              CMP      r2,#0                 ;2504
0001cc  d1f3              BNE      |L30.438|
0001ce  bf00              NOP                            ;2504
0001d0  bf00              NOP                            ;2508
0001d2  bf00              NOP                            ;2508
                  |L30.468|
0001d4  6821              LDR      r1,[r4,#0]            ;2508
0001d6  3114              ADDS     r1,r1,#0x14           ;2508
0001d8  e8511f00          LDREX    r1,[r1,#0]            ;2508
0001dc  f0210040          BIC      r0,r1,#0x40           ;2508
0001e0  6821              LDR      r1,[r4,#0]            ;2508
0001e2  3114              ADDS     r1,r1,#0x14           ;2508
0001e4  e8410200          STREX    r2,r0,[r1,#0]         ;2508
0001e8  2a00              CMP      r2,#0                 ;2508
0001ea  d1f3              BNE      |L30.468|
0001ec  bf00              NOP                            ;2508
0001ee  2020              MOVS     r0,#0x20              ;2511
0001f0  f8840042          STRB     r0,[r4,#0x42]         ;2511
0001f4  2000              MOVS     r0,#0                 ;2512
0001f6  6320              STR      r0,[r4,#0x30]         ;2512
0001f8  bf00              NOP                            ;2514
0001fa  bf00              NOP                            ;2514
                  |L30.508|
0001fc  6821              LDR      r1,[r4,#0]            ;2514
0001fe  310c              ADDS     r1,r1,#0xc            ;2514
000200  e8511f00          LDREX    r1,[r1,#0]            ;2514
000204  f0210010          BIC      r0,r1,#0x10           ;2514
000208  6821              LDR      r1,[r4,#0]            ;2514
00020a  310c              ADDS     r1,r1,#0xc            ;2514
00020c  e8410200          STREX    r2,r0,[r1,#0]         ;2514
000210  2a00              CMP      r2,#0                 ;2514
000212  d1f3              BNE      |L30.508|
000214  bf00              NOP                            ;2514
000216  6be0              LDR      r0,[r4,#0x3c]         ;2517
000218  f7fffffe          BL       HAL_DMA_Abort
                  |L30.540|
00021c  2002              MOVS     r0,#2                 ;2522
00021e  6360              STR      r0,[r4,#0x34]         ;2522
000220  8da0              LDRH     r0,[r4,#0x2c]         ;2529
000222  8de2              LDRH     r2,[r4,#0x2e]         ;2529
000224  1a80              SUBS     r0,r0,r2              ;2529
000226  b281              UXTH     r1,r0                 ;2529
000228  4620              MOV      r0,r4                 ;2529
00022a  f7fffffe          BL       HAL_UARTEx_RxEventCallback
                  |L30.558|
00022e  e701              B        |L30.52|
                  |L30.560|
000230  e042              B        |L30.696|
                  |L30.562|
000232  8da0              LDRH     r0,[r4,#0x2c]         ;2539
000234  8de1              LDRH     r1,[r4,#0x2e]         ;2539
000236  1a40              SUBS     r0,r0,r1              ;2539
000238  fa1ff880          UXTH     r8,r0                 ;2539
00023c  8de0              LDRH     r0,[r4,#0x2e]         ;2540
00023e  b3d0              CBZ      r0,|L30.694|
000240  f1b80f00          CMP      r8,#0                 ;2541
000244  d037              BEQ      |L30.694|
000246  bf00              NOP                            ;2544
000248  bf00              NOP                            ;2544
                  |L30.586|
00024a  6821              LDR      r1,[r4,#0]            ;2544
00024c  310c              ADDS     r1,r1,#0xc            ;2544
00024e  e8511f00          LDREX    r1,[r1,#0]            ;2544
000252  f4217090          BIC      r0,r1,#0x120          ;2544
000256  6821              LDR      r1,[r4,#0]            ;2544
000258  310c              ADDS     r1,r1,#0xc            ;2544
00025a  e8410200          STREX    r2,r0,[r1,#0]         ;2544
00025e  2a00              CMP      r2,#0                 ;2544
000260  d1f3              BNE      |L30.586|
000262  bf00              NOP                            ;2544
000264  bf00              NOP                            ;2547
000266  bf00              NOP                            ;2547
                  |L30.616|
000268  6821              LDR      r1,[r4,#0]            ;2547
00026a  3114              ADDS     r1,r1,#0x14           ;2547
00026c  e8511f00          LDREX    r1,[r1,#0]            ;2547
000270  f0210001          BIC      r0,r1,#1              ;2547
000274  6821              LDR      r1,[r4,#0]            ;2547
000276  3114              ADDS     r1,r1,#0x14           ;2547
000278  e8410200          STREX    r2,r0,[r1,#0]         ;2547
00027c  2a00              CMP      r2,#0                 ;2547
00027e  d1f3              BNE      |L30.616|
000280  bf00              NOP                            ;2547
000282  2020              MOVS     r0,#0x20              ;2550
000284  f8840042          STRB     r0,[r4,#0x42]         ;2550
000288  2000              MOVS     r0,#0                 ;2551
00028a  6320              STR      r0,[r4,#0x30]         ;2551
00028c  bf00              NOP                            ;2553
00028e  bf00              NOP                            ;2553
                  |L30.656|
000290  6821              LDR      r1,[r4,#0]            ;2553
000292  310c              ADDS     r1,r1,#0xc            ;2553
000294  e8511f00          LDREX    r1,[r1,#0]            ;2553
000298  f0210010          BIC      r0,r1,#0x10           ;2553
00029c  6821              LDR      r1,[r4,#0]            ;2553
00029e  310c              ADDS     r1,r1,#0xc            ;2553
0002a0  e8410200          STREX    r2,r0,[r1,#0]         ;2553
0002a4  2a00              CMP      r2,#0                 ;2553
0002a6  d1f3              BNE      |L30.656|
0002a8  bf00              NOP                            ;2553
0002aa  2002              MOVS     r0,#2                 ;2557
0002ac  6360              STR      r0,[r4,#0x34]         ;2557
0002ae  4641              MOV      r1,r8                 ;2564
0002b0  4620              MOV      r0,r4                 ;2564
0002b2  f7fffffe          BL       HAL_UARTEx_RxEventCallback
                  |L30.694|
0002b6  e6bd              B        |L30.52|
                  |L30.696|
0002b8  f0050080          AND      r0,r5,#0x80           ;2572
0002bc  b130              CBZ      r0,|L30.716|
0002be  f0060080          AND      r0,r6,#0x80           ;2572
0002c2  b118              CBZ      r0,|L30.716|
0002c4  4620              MOV      r0,r4                 ;2574
0002c6  f7fffffe          BL       UART_Transmit_IT
0002ca  e6b3              B        |L30.52|
                  |L30.716|
0002cc  f0050040          AND      r0,r5,#0x40           ;2579
0002d0  b130              CBZ      r0,|L30.736|
0002d2  f0060040          AND      r0,r6,#0x40           ;2579
0002d6  b118              CBZ      r0,|L30.736|
0002d8  4620              MOV      r0,r4                 ;2581
0002da  f7fffffe          BL       UART_EndTransmit_IT
0002de  e6a9              B        |L30.52|
                  |L30.736|
0002e0  bf00              NOP      
0002e2  e6a7              B        |L30.52|
;;;2585   
                          ENDP

                  |L30.740|
                          DCD      UART_DMAAbortOnError

                          AREA ||i.HAL_UART_Init||, CODE, READONLY, ALIGN=1

                  HAL_UART_Init PROC
;;;356      */
;;;357    HAL_StatusTypeDef HAL_UART_Init(UART_HandleTypeDef *huart)
000000  b510              PUSH     {r4,lr}
;;;358    {
000002  4604              MOV      r4,r0
;;;359      /* Check the UART handle allocation */
;;;360      if (huart == NULL)
000004  b90c              CBNZ     r4,|L31.10|
;;;361      {
;;;362        return HAL_ERROR;
000006  2001              MOVS     r0,#1
                  |L31.8|
;;;363      }
;;;364    
;;;365      /* Check the parameters */
;;;366      if (huart->Init.HwFlowCtl != UART_HWCONTROL_NONE)
;;;367      {
;;;368        /* The hardware flow control is available only for USART1, USART2, USART3 and USART6.
;;;369           Except for STM32F446xx devices, that is available for USART1, USART2, USART3, USART6, UART4 and UART5.
;;;370        */
;;;371        assert_param(IS_UART_HWFLOW_INSTANCE(huart->Instance));
;;;372        assert_param(IS_UART_HARDWARE_FLOW_CONTROL(huart->Init.HwFlowCtl));
;;;373      }
;;;374      else
;;;375      {
;;;376        assert_param(IS_UART_INSTANCE(huart->Instance));
;;;377      }
;;;378      assert_param(IS_UART_WORD_LENGTH(huart->Init.WordLength));
;;;379      assert_param(IS_UART_OVERSAMPLING(huart->Init.OverSampling));
;;;380    
;;;381      if (huart->gState == HAL_UART_STATE_RESET)
;;;382      {
;;;383        /* Allocate lock resource and initialize it */
;;;384        huart->Lock = HAL_UNLOCKED;
;;;385    
;;;386    #if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
;;;387        UART_InitCallbacksToDefault(huart);
;;;388    
;;;389        if (huart->MspInitCallback == NULL)
;;;390        {
;;;391          huart->MspInitCallback = HAL_UART_MspInit;
;;;392        }
;;;393    
;;;394        /* Init the low level hardware */
;;;395        huart->MspInitCallback(huart);
;;;396    #else
;;;397        /* Init the low level hardware : GPIO, CLOCK */
;;;398        HAL_UART_MspInit(huart);
;;;399    #endif /* (USE_HAL_UART_REGISTER_CALLBACKS) */
;;;400      }
;;;401    
;;;402      huart->gState = HAL_UART_STATE_BUSY;
;;;403    
;;;404      /* Disable the peripheral */
;;;405      __HAL_UART_DISABLE(huart);
;;;406    
;;;407      /* Set the UART Communication parameters */
;;;408      UART_SetConfig(huart);
;;;409    
;;;410      /* In asynchronous mode, the following bits must be kept cleared:
;;;411         - LINEN and CLKEN bits in the USART_CR2 register,
;;;412         - SCEN, HDSEL and IREN  bits in the USART_CR3 register.*/
;;;413      CLEAR_BIT(huart->Instance->CR2, (USART_CR2_LINEN | USART_CR2_CLKEN));
;;;414      CLEAR_BIT(huart->Instance->CR3, (USART_CR3_SCEN | USART_CR3_HDSEL | USART_CR3_IREN));
;;;415    
;;;416      /* Enable the peripheral */
;;;417      __HAL_UART_ENABLE(huart);
;;;418    
;;;419      /* Initialize the UART state */
;;;420      huart->ErrorCode = HAL_UART_ERROR_NONE;
;;;421      huart->gState = HAL_UART_STATE_READY;
;;;422      huart->RxState = HAL_UART_STATE_READY;
;;;423      huart->RxEventType = HAL_UART_RXEVENT_TC;
;;;424    
;;;425      return HAL_OK;
;;;426    }
000008  bd10              POP      {r4,pc}
                  |L31.10|
00000a  69a0              LDR      r0,[r4,#0x18]         ;366
00000c  b100              CBZ      r0,|L31.16|
00000e  e000              B        |L31.18|
                  |L31.16|
000010  bf00              NOP                            ;376
                  |L31.18|
000012  f8940041          LDRB     r0,[r4,#0x41]         ;381
000016  b928              CBNZ     r0,|L31.36|
000018  2000              MOVS     r0,#0                 ;384
00001a  f8840040          STRB     r0,[r4,#0x40]         ;384
00001e  4620              MOV      r0,r4                 ;398
000020  f7fffffe          BL       HAL_UART_MspInit
                  |L31.36|
000024  2024              MOVS     r0,#0x24              ;402
000026  f8840041          STRB     r0,[r4,#0x41]         ;402
00002a  6820              LDR      r0,[r4,#0]            ;405
00002c  68c0              LDR      r0,[r0,#0xc]          ;405
00002e  f4205000          BIC      r0,r0,#0x2000         ;405
000032  6821              LDR      r1,[r4,#0]            ;405
000034  60c8              STR      r0,[r1,#0xc]          ;405
000036  4620              MOV      r0,r4                 ;408
000038  f7fffffe          BL       UART_SetConfig
00003c  6820              LDR      r0,[r4,#0]            ;413
00003e  6900              LDR      r0,[r0,#0x10]         ;413
000040  f4204090          BIC      r0,r0,#0x4800         ;413
000044  6821              LDR      r1,[r4,#0]            ;413
000046  6108              STR      r0,[r1,#0x10]         ;413
000048  6820              LDR      r0,[r4,#0]            ;414
00004a  6940              LDR      r0,[r0,#0x14]         ;414
00004c  f020002a          BIC      r0,r0,#0x2a           ;414
000050  6821              LDR      r1,[r4,#0]            ;414
000052  6148              STR      r0,[r1,#0x14]         ;414
000054  6820              LDR      r0,[r4,#0]            ;417
000056  68c0              LDR      r0,[r0,#0xc]          ;417
000058  f4405000          ORR      r0,r0,#0x2000         ;417
00005c  6821              LDR      r1,[r4,#0]            ;417
00005e  60c8              STR      r0,[r1,#0xc]          ;417
000060  2000              MOVS     r0,#0                 ;420
000062  6460              STR      r0,[r4,#0x44]         ;420
000064  2020              MOVS     r0,#0x20              ;421
000066  f8840041          STRB     r0,[r4,#0x41]         ;421
00006a  f8840042          STRB     r0,[r4,#0x42]         ;422
00006e  2000              MOVS     r0,#0                 ;423
000070  6360              STR      r0,[r4,#0x34]         ;423
000072  bf00              NOP                            ;425
000074  e7c8              B        |L31.8|
;;;427    
                          ENDP


                          AREA ||i.HAL_UART_MspDeInit||, CODE, READONLY, ALIGN=1

                  HAL_UART_MspDeInit PROC
;;;729      */
;;;730    __weak void HAL_UART_MspDeInit(UART_HandleTypeDef *huart)
000000  4770              BX       lr
;;;731    {
;;;732      /* Prevent unused argument(s) compilation warning */
;;;733      UNUSED(huart);
;;;734      /* NOTE: This function should not be modified, when the callback is needed,
;;;735               the HAL_UART_MspDeInit could be implemented in the user file
;;;736       */
;;;737    }
;;;738    
                          ENDP


                          AREA ||i.HAL_UART_MspInit||, CODE, READONLY, ALIGN=1

                  HAL_UART_MspInit PROC
;;;714      */
;;;715    __weak void HAL_UART_MspInit(UART_HandleTypeDef *huart)
000000  4770              BX       lr
;;;716    {
;;;717      /* Prevent unused argument(s) compilation warning */
;;;718      UNUSED(huart);
;;;719      /* NOTE: This function should not be modified, when the callback is needed,
;;;720               the HAL_UART_MspInit could be implemented in the user file
;;;721       */
;;;722    }
;;;723    
                          ENDP


                          AREA ||i.HAL_UART_Receive||, CODE, READONLY, ALIGN=1

                  HAL_UART_Receive PROC
;;;1220     */
;;;1221   HAL_StatusTypeDef HAL_UART_Receive(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size, uint32_t Timeout)
000000  e92d4ff8          PUSH     {r3-r11,lr}
;;;1222   {
000004  4604              MOV      r4,r0
000006  460e              MOV      r6,r1
000008  4617              MOV      r7,r2
00000a  4699              MOV      r9,r3
;;;1223     uint8_t  *pdata8bits;
;;;1224     uint16_t *pdata16bits;
;;;1225     uint32_t tickstart = 0U;
00000c  f04f0a00          MOV      r10,#0
;;;1226   
;;;1227     /* Check that a Rx process is not already ongoing */
;;;1228     if (huart->RxState == HAL_UART_STATE_READY)
000010  f8940042          LDRB     r0,[r4,#0x42]
000014  2820              CMP      r0,#0x20
000016  d152              BNE      |L34.190|
;;;1229     {
;;;1230       if ((pData == NULL) || (Size == 0U))
000018  b106              CBZ      r6,|L34.28|
00001a  b917              CBNZ     r7,|L34.34|
                  |L34.28|
;;;1231       {
;;;1232         return  HAL_ERROR;
00001c  2001              MOVS     r0,#1
                  |L34.30|
;;;1233       }
;;;1234   
;;;1235       huart->ErrorCode = HAL_UART_ERROR_NONE;
;;;1236       huart->RxState = HAL_UART_STATE_BUSY_RX;
;;;1237       huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
;;;1238   
;;;1239       /* Init tickstart for timeout management */
;;;1240       tickstart = HAL_GetTick();
;;;1241   
;;;1242       huart->RxXferSize = Size;
;;;1243       huart->RxXferCount = Size;
;;;1244   
;;;1245       /* In case of 9bits/No Parity transfer, pRxData needs to be handled as a uint16_t pointer */
;;;1246       if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
;;;1247       {
;;;1248         pdata8bits  = NULL;
;;;1249         pdata16bits = (uint16_t *) pData;
;;;1250       }
;;;1251       else
;;;1252       {
;;;1253         pdata8bits  = pData;
;;;1254         pdata16bits = NULL;
;;;1255       }
;;;1256   
;;;1257       /* Check the remain data to be received */
;;;1258       while (huart->RxXferCount > 0U)
;;;1259       {
;;;1260         if (UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_RXNE, RESET, tickstart, Timeout) != HAL_OK)
;;;1261         {
;;;1262           huart->RxState = HAL_UART_STATE_READY;
;;;1263   
;;;1264           return HAL_TIMEOUT;
;;;1265         }
;;;1266         if (pdata8bits == NULL)
;;;1267         {
;;;1268           *pdata16bits = (uint16_t)(huart->Instance->DR & 0x01FF);
;;;1269           pdata16bits++;
;;;1270         }
;;;1271         else
;;;1272         {
;;;1273           if ((huart->Init.WordLength == UART_WORDLENGTH_9B) || ((huart->Init.WordLength == UART_WORDLENGTH_8B) && (huart->Init.Parity == UART_PARITY_NONE)))
;;;1274           {
;;;1275             *pdata8bits = (uint8_t)(huart->Instance->DR & (uint8_t)0x00FF);
;;;1276           }
;;;1277           else
;;;1278           {
;;;1279             *pdata8bits = (uint8_t)(huart->Instance->DR & (uint8_t)0x007F);
;;;1280           }
;;;1281           pdata8bits++;
;;;1282         }
;;;1283         huart->RxXferCount--;
;;;1284       }
;;;1285   
;;;1286       /* At end of Rx process, restore huart->RxState to Ready */
;;;1287       huart->RxState = HAL_UART_STATE_READY;
;;;1288   
;;;1289       return HAL_OK;
;;;1290     }
;;;1291     else
;;;1292     {
;;;1293       return HAL_BUSY;
;;;1294     }
;;;1295   }
00001e  e8bd8ff8          POP      {r3-r11,pc}
                  |L34.34|
000022  2000              MOVS     r0,#0                 ;1235
000024  6460              STR      r0,[r4,#0x44]         ;1235
000026  2022              MOVS     r0,#0x22              ;1236
000028  f8840042          STRB     r0,[r4,#0x42]         ;1236
00002c  2000              MOVS     r0,#0                 ;1237
00002e  6320              STR      r0,[r4,#0x30]         ;1237
000030  f7fffffe          BL       HAL_GetTick
000034  4682              MOV      r10,r0                ;1240
000036  85a7              STRH     r7,[r4,#0x2c]         ;1242
000038  85e7              STRH     r7,[r4,#0x2e]         ;1243
00003a  68a0              LDR      r0,[r4,#8]            ;1246
00003c  f5b05f80          CMP      r0,#0x1000            ;1246
000040  d104              BNE      |L34.76|
000042  6920              LDR      r0,[r4,#0x10]         ;1246
000044  b910              CBNZ     r0,|L34.76|
000046  2500              MOVS     r5,#0                 ;1248
000048  46b0              MOV      r8,r6                 ;1249
00004a  e002              B        |L34.82|
                  |L34.76|
00004c  4635              MOV      r5,r6                 ;1253
00004e  f04f0800          MOV      r8,#0                 ;1254
                  |L34.82|
000052  e02c              B        |L34.174|
                  |L34.84|
000054  4653              MOV      r3,r10                ;1260
000056  2200              MOVS     r2,#0                 ;1260
000058  2120              MOVS     r1,#0x20              ;1260
00005a  4620              MOV      r0,r4                 ;1260
00005c  f8cd9000          STR      r9,[sp,#0]            ;1260
000060  f7fffffe          BL       UART_WaitOnFlagUntilTimeout
000064  b120              CBZ      r0,|L34.112|
000066  2020              MOVS     r0,#0x20              ;1262
000068  f8840042          STRB     r0,[r4,#0x42]         ;1262
00006c  2003              MOVS     r0,#3                 ;1264
00006e  e7d6              B        |L34.30|
                  |L34.112|
000070  b945              CBNZ     r5,|L34.132|
000072  6820              LDR      r0,[r4,#0]            ;1268
000074  6840              LDR      r0,[r0,#4]            ;1268
000076  f3c00008          UBFX     r0,r0,#0,#9           ;1268
00007a  f8a80000          STRH     r0,[r8,#0]            ;1268
00007e  f1080802          ADD      r8,r8,#2              ;1269
000082  e011              B        |L34.168|
                  |L34.132|
000084  68a0              LDR      r0,[r4,#8]            ;1273
000086  f5b05f80          CMP      r0,#0x1000            ;1273
00008a  d003              BEQ      |L34.148|
00008c  68a0              LDR      r0,[r4,#8]            ;1273
00008e  b928              CBNZ     r0,|L34.156|
000090  6920              LDR      r0,[r4,#0x10]         ;1273
000092  b918              CBNZ     r0,|L34.156|
                  |L34.148|
000094  6820              LDR      r0,[r4,#0]            ;1275
000096  6840              LDR      r0,[r0,#4]            ;1275
000098  7028              STRB     r0,[r5,#0]            ;1275
00009a  e004              B        |L34.166|
                  |L34.156|
00009c  6820              LDR      r0,[r4,#0]            ;1279
00009e  6840              LDR      r0,[r0,#4]            ;1279
0000a0  f000007f          AND      r0,r0,#0x7f           ;1279
0000a4  7028              STRB     r0,[r5,#0]            ;1279
                  |L34.166|
0000a6  1c6d              ADDS     r5,r5,#1              ;1281
                  |L34.168|
0000a8  8de0              LDRH     r0,[r4,#0x2e]         ;1283
0000aa  1e40              SUBS     r0,r0,#1              ;1283
0000ac  85e0              STRH     r0,[r4,#0x2e]         ;1283
                  |L34.174|
0000ae  8de0              LDRH     r0,[r4,#0x2e]         ;1258
0000b0  2800              CMP      r0,#0                 ;1258
0000b2  d1cf              BNE      |L34.84|
0000b4  2020              MOVS     r0,#0x20              ;1287
0000b6  f8840042          STRB     r0,[r4,#0x42]         ;1287
0000ba  2000              MOVS     r0,#0                 ;1289
0000bc  e7af              B        |L34.30|
                  |L34.190|
0000be  2002              MOVS     r0,#2                 ;1293
0000c0  e7ad              B        |L34.30|
;;;1296   
                          ENDP


                          AREA ||i.HAL_UART_Receive_DMA||, CODE, READONLY, ALIGN=1

                  HAL_UART_Receive_DMA PROC
;;;1440     */
;;;1441   HAL_StatusTypeDef HAL_UART_Receive_DMA(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size)
000000  b570              PUSH     {r4-r6,lr}
;;;1442   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
000006  4616              MOV      r6,r2
;;;1443     /* Check that a Rx process is not already ongoing */
;;;1444     if (huart->RxState == HAL_UART_STATE_READY)
000008  f8940042          LDRB     r0,[r4,#0x42]
00000c  2820              CMP      r0,#0x20
00000e  d10b              BNE      |L35.40|
;;;1445     {
;;;1446       if ((pData == NULL) || (Size == 0U))
000010  b105              CBZ      r5,|L35.20|
000012  b90e              CBNZ     r6,|L35.24|
                  |L35.20|
;;;1447       {
;;;1448         return HAL_ERROR;
000014  2001              MOVS     r0,#1
                  |L35.22|
;;;1449       }
;;;1450   
;;;1451       /* Set Reception type to Standard reception */
;;;1452       huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
;;;1453   
;;;1454       return (UART_Start_Receive_DMA(huart, pData, Size));
;;;1455     }
;;;1456     else
;;;1457     {
;;;1458       return HAL_BUSY;
;;;1459     }
;;;1460   }
000016  bd70              POP      {r4-r6,pc}
                  |L35.24|
000018  2000              MOVS     r0,#0                 ;1452
00001a  6320              STR      r0,[r4,#0x30]         ;1452
00001c  4632              MOV      r2,r6                 ;1454
00001e  4629              MOV      r1,r5                 ;1454
000020  4620              MOV      r0,r4                 ;1454
000022  f7fffffe          BL       UART_Start_Receive_DMA
000026  e7f6              B        |L35.22|
                  |L35.40|
000028  2002              MOVS     r0,#2                 ;1458
00002a  e7f4              B        |L35.22|
;;;1461   
                          ENDP


                          AREA ||i.HAL_UART_Receive_IT||, CODE, READONLY, ALIGN=1

                  HAL_UART_Receive_IT PROC
;;;1346     */
;;;1347   HAL_StatusTypeDef HAL_UART_Receive_IT(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size)
000000  b570              PUSH     {r4-r6,lr}
;;;1348   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
000006  4616              MOV      r6,r2
;;;1349     /* Check that a Rx process is not already ongoing */
;;;1350     if (huart->RxState == HAL_UART_STATE_READY)
000008  f8940042          LDRB     r0,[r4,#0x42]
00000c  2820              CMP      r0,#0x20
00000e  d10b              BNE      |L36.40|
;;;1351     {
;;;1352       if ((pData == NULL) || (Size == 0U))
000010  b105              CBZ      r5,|L36.20|
000012  b90e              CBNZ     r6,|L36.24|
                  |L36.20|
;;;1353       {
;;;1354         return HAL_ERROR;
000014  2001              MOVS     r0,#1
                  |L36.22|
;;;1355       }
;;;1356   
;;;1357       /* Set Reception type to Standard reception */
;;;1358       huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
;;;1359   
;;;1360       return (UART_Start_Receive_IT(huart, pData, Size));
;;;1361     }
;;;1362     else
;;;1363     {
;;;1364       return HAL_BUSY;
;;;1365     }
;;;1366   }
000016  bd70              POP      {r4-r6,pc}
                  |L36.24|
000018  2000              MOVS     r0,#0                 ;1358
00001a  6320              STR      r0,[r4,#0x30]         ;1358
00001c  4632              MOV      r2,r6                 ;1360
00001e  4629              MOV      r1,r5                 ;1360
000020  4620              MOV      r0,r4                 ;1360
000022  f7fffffe          BL       UART_Start_Receive_IT
000026  e7f6              B        |L36.22|
                  |L36.40|
000028  2002              MOVS     r0,#2                 ;1364
00002a  e7f4              B        |L36.22|
;;;1367   
                          ENDP


                          AREA ||i.HAL_UART_RxCpltCallback||, CODE, READONLY, ALIGN=1

                  HAL_UART_RxCpltCallback PROC
;;;2621     */
;;;2622   __weak void HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart)
000000  4770              BX       lr
;;;2623   {
;;;2624     /* Prevent unused argument(s) compilation warning */
;;;2625     UNUSED(huart);
;;;2626     /* NOTE: This function should not be modified, when the callback is needed,
;;;2627              the HAL_UART_RxCpltCallback could be implemented in the user file
;;;2628      */
;;;2629   }
;;;2630   
                          ENDP


                          AREA ||i.HAL_UART_RxHalfCpltCallback||, CODE, READONLY, ALIGN=1

                  HAL_UART_RxHalfCpltCallback PROC
;;;2636     */
;;;2637   __weak void HAL_UART_RxHalfCpltCallback(UART_HandleTypeDef *huart)
000000  4770              BX       lr
;;;2638   {
;;;2639     /* Prevent unused argument(s) compilation warning */
;;;2640     UNUSED(huart);
;;;2641     /* NOTE: This function should not be modified, when the callback is needed,
;;;2642              the HAL_UART_RxHalfCpltCallback could be implemented in the user file
;;;2643      */
;;;2644   }
;;;2645   
                          ENDP


                          AREA ||i.HAL_UART_Transmit||, CODE, READONLY, ALIGN=1

                  HAL_UART_Transmit PROC
;;;1134     */
;;;1135   HAL_StatusTypeDef HAL_UART_Transmit(UART_HandleTypeDef *huart, const uint8_t *pData, uint16_t Size, uint32_t Timeout)
000000  e92d4ff8          PUSH     {r3-r11,lr}
;;;1136   {
000004  4604              MOV      r4,r0
000006  460e              MOV      r6,r1
000008  4617              MOV      r7,r2
00000a  4699              MOV      r9,r3
;;;1137     const uint8_t  *pdata8bits;
;;;1138     const uint16_t *pdata16bits;
;;;1139     uint32_t tickstart = 0U;
00000c  f04f0a00          MOV      r10,#0
;;;1140   
;;;1141     /* Check that a Tx process is not already ongoing */
;;;1142     if (huart->gState == HAL_UART_STATE_READY)
000010  f8940041          LDRB     r0,[r4,#0x41]
000014  2820              CMP      r0,#0x20
000016  d150              BNE      |L39.186|
;;;1143     {
;;;1144       if ((pData == NULL) || (Size == 0U))
000018  b106              CBZ      r6,|L39.28|
00001a  b917              CBNZ     r7,|L39.34|
                  |L39.28|
;;;1145       {
;;;1146         return  HAL_ERROR;
00001c  2001              MOVS     r0,#1
                  |L39.30|
;;;1147       }
;;;1148   
;;;1149       huart->ErrorCode = HAL_UART_ERROR_NONE;
;;;1150       huart->gState = HAL_UART_STATE_BUSY_TX;
;;;1151   
;;;1152       /* Init tickstart for timeout management */
;;;1153       tickstart = HAL_GetTick();
;;;1154   
;;;1155       huart->TxXferSize = Size;
;;;1156       huart->TxXferCount = Size;
;;;1157   
;;;1158       /* In case of 9bits/No Parity transfer, pData needs to be handled as a uint16_t pointer */
;;;1159       if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
;;;1160       {
;;;1161         pdata8bits  = NULL;
;;;1162         pdata16bits = (const uint16_t *) pData;
;;;1163       }
;;;1164       else
;;;1165       {
;;;1166         pdata8bits  = pData;
;;;1167         pdata16bits = NULL;
;;;1168       }
;;;1169   
;;;1170       while (huart->TxXferCount > 0U)
;;;1171       {
;;;1172         if (UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_TXE, RESET, tickstart, Timeout) != HAL_OK)
;;;1173         {
;;;1174           huart->gState = HAL_UART_STATE_READY;
;;;1175   
;;;1176           return HAL_TIMEOUT;
;;;1177         }
;;;1178         if (pdata8bits == NULL)
;;;1179         {
;;;1180           huart->Instance->DR = (uint16_t)(*pdata16bits & 0x01FFU);
;;;1181           pdata16bits++;
;;;1182         }
;;;1183         else
;;;1184         {
;;;1185           huart->Instance->DR = (uint8_t)(*pdata8bits & 0xFFU);
;;;1186           pdata8bits++;
;;;1187         }
;;;1188         huart->TxXferCount--;
;;;1189       }
;;;1190   
;;;1191       if (UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_TC, RESET, tickstart, Timeout) != HAL_OK)
;;;1192       {
;;;1193         huart->gState = HAL_UART_STATE_READY;
;;;1194   
;;;1195         return HAL_TIMEOUT;
;;;1196       }
;;;1197   
;;;1198       /* At end of Tx process, restore huart->gState to Ready */
;;;1199       huart->gState = HAL_UART_STATE_READY;
;;;1200   
;;;1201       return HAL_OK;
;;;1202     }
;;;1203     else
;;;1204     {
;;;1205       return HAL_BUSY;
;;;1206     }
;;;1207   }
00001e  e8bd8ff8          POP      {r3-r11,pc}
                  |L39.34|
000022  2000              MOVS     r0,#0                 ;1149
000024  6460              STR      r0,[r4,#0x44]         ;1149
000026  2021              MOVS     r0,#0x21              ;1150
000028  f8840041          STRB     r0,[r4,#0x41]         ;1150
00002c  f7fffffe          BL       HAL_GetTick
000030  4682              MOV      r10,r0                ;1153
000032  84a7              STRH     r7,[r4,#0x24]         ;1155
000034  84e7              STRH     r7,[r4,#0x26]         ;1156
000036  68a0              LDR      r0,[r4,#8]            ;1159
000038  f5b05f80          CMP      r0,#0x1000            ;1159
00003c  d104              BNE      |L39.72|
00003e  6920              LDR      r0,[r4,#0x10]         ;1159
000040  b910              CBNZ     r0,|L39.72|
000042  2500              MOVS     r5,#0                 ;1161
000044  46b0              MOV      r8,r6                 ;1162
000046  e002              B        |L39.78|
                  |L39.72|
000048  4635              MOV      r5,r6                 ;1166
00004a  f04f0800          MOV      r8,#0                 ;1167
                  |L39.78|
00004e  e01e              B        |L39.142|
                  |L39.80|
000050  4653              MOV      r3,r10                ;1172
000052  2200              MOVS     r2,#0                 ;1172
000054  2180              MOVS     r1,#0x80              ;1172
000056  4620              MOV      r0,r4                 ;1172
000058  f8cd9000          STR      r9,[sp,#0]            ;1172
00005c  f7fffffe          BL       UART_WaitOnFlagUntilTimeout
000060  b120              CBZ      r0,|L39.108|
000062  2020              MOVS     r0,#0x20              ;1174
000064  f8840041          STRB     r0,[r4,#0x41]         ;1174
000068  2003              MOVS     r0,#3                 ;1176
00006a  e7d8              B        |L39.30|
                  |L39.108|
00006c  b945              CBNZ     r5,|L39.128|
00006e  f8b80000          LDRH     r0,[r8,#0]            ;1180
000072  f3c00008          UBFX     r0,r0,#0,#9           ;1180
000076  6821              LDR      r1,[r4,#0]            ;1180
000078  6048              STR      r0,[r1,#4]            ;1180
00007a  f1080802          ADD      r8,r8,#2              ;1181
00007e  e003              B        |L39.136|
                  |L39.128|
000080  7828              LDRB     r0,[r5,#0]            ;1185
000082  6821              LDR      r1,[r4,#0]            ;1185
000084  6048              STR      r0,[r1,#4]            ;1185
000086  1c6d              ADDS     r5,r5,#1              ;1186
                  |L39.136|
000088  8ce0              LDRH     r0,[r4,#0x26]         ;1188
00008a  1e40              SUBS     r0,r0,#1              ;1188
00008c  84e0              STRH     r0,[r4,#0x26]         ;1188
                  |L39.142|
00008e  8ce0              LDRH     r0,[r4,#0x26]         ;1170
000090  2800              CMP      r0,#0                 ;1170
000092  d1dd              BNE      |L39.80|
000094  4653              MOV      r3,r10                ;1191
000096  2200              MOVS     r2,#0                 ;1191
000098  2140              MOVS     r1,#0x40              ;1191
00009a  4620              MOV      r0,r4                 ;1191
00009c  f8cd9000          STR      r9,[sp,#0]            ;1191
0000a0  f7fffffe          BL       UART_WaitOnFlagUntilTimeout
0000a4  b120              CBZ      r0,|L39.176|
0000a6  2020              MOVS     r0,#0x20              ;1193
0000a8  f8840041          STRB     r0,[r4,#0x41]         ;1193
0000ac  2003              MOVS     r0,#3                 ;1195
0000ae  e7b6              B        |L39.30|
                  |L39.176|
0000b0  2020              MOVS     r0,#0x20              ;1199
0000b2  f8840041          STRB     r0,[r4,#0x41]         ;1199
0000b6  2000              MOVS     r0,#0                 ;1201
0000b8  e7b1              B        |L39.30|
                  |L39.186|
0000ba  2002              MOVS     r0,#2                 ;1205
0000bc  e7af              B        |L39.30|
;;;1208   
                          ENDP


                          AREA ||i.HAL_UART_Transmit_DMA||, CODE, READONLY, ALIGN=2

                  HAL_UART_Transmit_DMA PROC
;;;1378     */
;;;1379   HAL_StatusTypeDef HAL_UART_Transmit_DMA(UART_HandleTypeDef *huart, const uint8_t *pData, uint16_t Size)
000000  b5f7              PUSH     {r0-r2,r4-r7,lr}
;;;1380   {
000002  4604              MOV      r4,r0
000004  4615              MOV      r5,r2
;;;1381     const uint32_t *tmp;
;;;1382   
;;;1383     /* Check that a Tx process is not already ongoing */
;;;1384     if (huart->gState == HAL_UART_STATE_READY)
000006  f8940041          LDRB     r0,[r4,#0x41]
00000a  2820              CMP      r0,#0x20
00000c  d136              BNE      |L40.124|
;;;1385     {
;;;1386       if ((pData == NULL) || (Size == 0U))
00000e  9801              LDR      r0,[sp,#4]
000010  b100              CBZ      r0,|L40.20|
000012  b90d              CBNZ     r5,|L40.24|
                  |L40.20|
;;;1387       {
;;;1388         return HAL_ERROR;
000014  2001              MOVS     r0,#1
                  |L40.22|
;;;1389       }
;;;1390   
;;;1391       huart->pTxBuffPtr = pData;
;;;1392       huart->TxXferSize = Size;
;;;1393       huart->TxXferCount = Size;
;;;1394   
;;;1395       huart->ErrorCode = HAL_UART_ERROR_NONE;
;;;1396       huart->gState = HAL_UART_STATE_BUSY_TX;
;;;1397   
;;;1398       /* Set the UART DMA transfer complete callback */
;;;1399       huart->hdmatx->XferCpltCallback = UART_DMATransmitCplt;
;;;1400   
;;;1401       /* Set the UART DMA Half transfer complete callback */
;;;1402       huart->hdmatx->XferHalfCpltCallback = UART_DMATxHalfCplt;
;;;1403   
;;;1404       /* Set the DMA error callback */
;;;1405       huart->hdmatx->XferErrorCallback = UART_DMAError;
;;;1406   
;;;1407       /* Set the DMA abort callback */
;;;1408       huart->hdmatx->XferAbortCallback = NULL;
;;;1409   
;;;1410       /* Enable the UART transmit DMA stream */
;;;1411       tmp = (const uint32_t *)&pData;
;;;1412       HAL_DMA_Start_IT(huart->hdmatx, *(const uint32_t *)tmp, (uint32_t)&huart->Instance->DR, Size);
;;;1413   
;;;1414       /* Clear the TC flag in the SR register by writing 0 to it */
;;;1415       __HAL_UART_CLEAR_FLAG(huart, UART_FLAG_TC);
;;;1416   
;;;1417       /* Enable the DMA transfer for transmit request by setting the DMAT bit
;;;1418          in the UART CR3 register */
;;;1419       ATOMIC_SET_BIT(huart->Instance->CR3, USART_CR3_DMAT);
;;;1420   
;;;1421       return HAL_OK;
;;;1422     }
;;;1423     else
;;;1424     {
;;;1425       return HAL_BUSY;
;;;1426     }
;;;1427   }
000016  bdfe              POP      {r1-r7,pc}
                  |L40.24|
000018  9801              LDR      r0,[sp,#4]            ;1391
00001a  6220              STR      r0,[r4,#0x20]         ;1391
00001c  84a5              STRH     r5,[r4,#0x24]         ;1392
00001e  84e5              STRH     r5,[r4,#0x26]         ;1393
000020  2000              MOVS     r0,#0                 ;1395
000022  6460              STR      r0,[r4,#0x44]         ;1395
000024  2021              MOVS     r0,#0x21              ;1396
000026  f8840041          STRB     r0,[r4,#0x41]         ;1396
00002a  4815              LDR      r0,|L40.128|
00002c  6ba1              LDR      r1,[r4,#0x38]         ;1399
00002e  63c8              STR      r0,[r1,#0x3c]         ;1399
000030  4814              LDR      r0,|L40.132|
000032  6ba1              LDR      r1,[r4,#0x38]         ;1402
000034  6408              STR      r0,[r1,#0x40]         ;1402
000036  4814              LDR      r0,|L40.136|
000038  6ba1              LDR      r1,[r4,#0x38]         ;1405
00003a  64c8              STR      r0,[r1,#0x4c]         ;1405
00003c  2000              MOVS     r0,#0                 ;1408
00003e  6ba1              LDR      r1,[r4,#0x38]         ;1408
000040  6508              STR      r0,[r1,#0x50]         ;1408
000042  ae01              ADD      r6,sp,#4              ;1411
000044  6823              LDR      r3,[r4,#0]            ;1412
000046  1d1a              ADDS     r2,r3,#4              ;1412
000048  6831              LDR      r1,[r6,#0]            ;1412
00004a  462b              MOV      r3,r5                 ;1412
00004c  6ba0              LDR      r0,[r4,#0x38]         ;1412
00004e  f7fffffe          BL       HAL_DMA_Start_IT
000052  f06f0040          MVN      r0,#0x40              ;1415
000056  6821              LDR      r1,[r4,#0]            ;1415
000058  6008              STR      r0,[r1,#0]            ;1415
00005a  bf00              NOP                            ;1419
00005c  bf00              NOP                            ;1419
                  |L40.94|
00005e  6821              LDR      r1,[r4,#0]            ;1419
000060  3114              ADDS     r1,r1,#0x14           ;1419
000062  e8511f00          LDREX    r1,[r1,#0]            ;1419
000066  f0410080          ORR      r0,r1,#0x80           ;1419
00006a  6821              LDR      r1,[r4,#0]            ;1419
00006c  3114              ADDS     r1,r1,#0x14           ;1419
00006e  e8410200          STREX    r2,r0,[r1,#0]         ;1419
000072  2a00              CMP      r2,#0                 ;1419
000074  d1f3              BNE      |L40.94|
000076  bf00              NOP                            ;1419
000078  2000              MOVS     r0,#0                 ;1421
00007a  e7cc              B        |L40.22|
                  |L40.124|
00007c  2002              MOVS     r0,#2                 ;1425
00007e  e7ca              B        |L40.22|
;;;1428   
                          ENDP

                  |L40.128|
                          DCD      UART_DMATransmitCplt
                  |L40.132|
                          DCD      UART_DMATxHalfCplt
                  |L40.136|
                          DCD      UART_DMAError

                          AREA ||i.HAL_UART_Transmit_IT||, CODE, READONLY, ALIGN=1

                  HAL_UART_Transmit_IT PROC
;;;1307     */
;;;1308   HAL_StatusTypeDef HAL_UART_Transmit_IT(UART_HandleTypeDef *huart, const uint8_t *pData, uint16_t Size)
000000  b510              PUSH     {r4,lr}
;;;1309   {
000002  4603              MOV      r3,r0
;;;1310     /* Check that a Tx process is not already ongoing */
;;;1311     if (huart->gState == HAL_UART_STATE_READY)
000004  f8930041          LDRB     r0,[r3,#0x41]
000008  2820              CMP      r0,#0x20
00000a  d113              BNE      |L41.52|
;;;1312     {
;;;1313       if ((pData == NULL) || (Size == 0U))
00000c  b101              CBZ      r1,|L41.16|
00000e  b90a              CBNZ     r2,|L41.20|
                  |L41.16|
;;;1314       {
;;;1315         return HAL_ERROR;
000010  2001              MOVS     r0,#1
                  |L41.18|
;;;1316       }
;;;1317   
;;;1318       huart->pTxBuffPtr = pData;
;;;1319       huart->TxXferSize = Size;
;;;1320       huart->TxXferCount = Size;
;;;1321   
;;;1322       huart->ErrorCode = HAL_UART_ERROR_NONE;
;;;1323       huart->gState = HAL_UART_STATE_BUSY_TX;
;;;1324   
;;;1325       /* Enable the UART Transmit data register empty Interrupt */
;;;1326       __HAL_UART_ENABLE_IT(huart, UART_IT_TXE);
;;;1327   
;;;1328       return HAL_OK;
;;;1329     }
;;;1330     else
;;;1331     {
;;;1332       return HAL_BUSY;
;;;1333     }
;;;1334   }
000012  bd10              POP      {r4,pc}
                  |L41.20|
000014  6219              STR      r1,[r3,#0x20]         ;1318
000016  849a              STRH     r2,[r3,#0x24]         ;1319
000018  84da              STRH     r2,[r3,#0x26]         ;1320
00001a  2000              MOVS     r0,#0                 ;1322
00001c  6458              STR      r0,[r3,#0x44]         ;1322
00001e  2021              MOVS     r0,#0x21              ;1323
000020  f8830041          STRB     r0,[r3,#0x41]         ;1323
000024  6818              LDR      r0,[r3,#0]            ;1326
000026  68c0              LDR      r0,[r0,#0xc]          ;1326
000028  f0400080          ORR      r0,r0,#0x80           ;1326
00002c  681c              LDR      r4,[r3,#0]            ;1326
00002e  60e0              STR      r0,[r4,#0xc]          ;1326
000030  2000              MOVS     r0,#0                 ;1328
000032  e7ee              B        |L41.18|
                  |L41.52|
000034  2002              MOVS     r0,#2                 ;1332
000036  e7ec              B        |L41.18|
;;;1335   
                          ENDP


                          AREA ||i.HAL_UART_TxCpltCallback||, CODE, READONLY, ALIGN=1

                  HAL_UART_TxCpltCallback PROC
;;;2591     */
;;;2592   __weak void HAL_UART_TxCpltCallback(UART_HandleTypeDef *huart)
000000  4770              BX       lr
;;;2593   {
;;;2594     /* Prevent unused argument(s) compilation warning */
;;;2595     UNUSED(huart);
;;;2596     /* NOTE: This function should not be modified, when the callback is needed,
;;;2597              the HAL_UART_TxCpltCallback could be implemented in the user file
;;;2598      */
;;;2599   }
;;;2600   
                          ENDP


                          AREA ||i.HAL_UART_TxHalfCpltCallback||, CODE, READONLY, ALIGN=1

                  HAL_UART_TxHalfCpltCallback PROC
;;;2606     */
;;;2607   __weak void HAL_UART_TxHalfCpltCallback(UART_HandleTypeDef *huart)
000000  4770              BX       lr
;;;2608   {
;;;2609     /* Prevent unused argument(s) compilation warning */
;;;2610     UNUSED(huart);
;;;2611     /* NOTE: This function should not be modified, when the callback is needed,
;;;2612              the HAL_UART_TxHalfCpltCallback could be implemented in the user file
;;;2613      */
;;;2614   }
;;;2615   
                          ENDP


                          AREA ||i.UART_DMAAbortOnError||, CODE, READONLY, ALIGN=1

                  UART_DMAAbortOnError PROC
;;;3358     */
;;;3359   static void UART_DMAAbortOnError(DMA_HandleTypeDef *hdma)
000000  b570              PUSH     {r4-r6,lr}
;;;3360   {
000002  4605              MOV      r5,r0
;;;3361     UART_HandleTypeDef *huart = (UART_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;
000004  6bac              LDR      r4,[r5,#0x38]
;;;3362     huart->RxXferCount = 0x00U;
000006  2000              MOVS     r0,#0
000008  85e0              STRH     r0,[r4,#0x2e]
;;;3363     huart->TxXferCount = 0x00U;
00000a  84e0              STRH     r0,[r4,#0x26]
;;;3364   
;;;3365   #if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
;;;3366     /*Call registered error callback*/
;;;3367     huart->ErrorCallback(huart);
;;;3368   #else
;;;3369     /*Call legacy weak error callback*/
;;;3370     HAL_UART_ErrorCallback(huart);
00000c  4620              MOV      r0,r4
00000e  f7fffffe          BL       HAL_UART_ErrorCallback
;;;3371   #endif /* USE_HAL_UART_REGISTER_CALLBACKS */
;;;3372   }
000012  bd70              POP      {r4-r6,pc}
;;;3373   
                          ENDP


                          AREA ||i.UART_DMAError||, CODE, READONLY, ALIGN=1

                  UART_DMAError PROC
;;;3142     */
;;;3143   static void UART_DMAError(DMA_HandleTypeDef *hdma)
000000  b570              PUSH     {r4-r6,lr}
;;;3144   {
000002  4606              MOV      r6,r0
;;;3145     uint32_t dmarequest = 0x00U;
000004  2500              MOVS     r5,#0
;;;3146     UART_HandleTypeDef *huart = (UART_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;
000006  6bb4              LDR      r4,[r6,#0x38]
;;;3147   
;;;3148     /* Stop UART DMA Tx request if ongoing */
;;;3149     dmarequest = HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAT);
000008  6820              LDR      r0,[r4,#0]
00000a  6940              LDR      r0,[r0,#0x14]
00000c  f3c015c0          UBFX     r5,r0,#7,#1
;;;3150     if ((huart->gState == HAL_UART_STATE_BUSY_TX) && dmarequest)
000010  f8940041          LDRB     r0,[r4,#0x41]
000014  2821              CMP      r0,#0x21
000016  d105              BNE      |L45.36|
000018  b125              CBZ      r5,|L45.36|
;;;3151     {
;;;3152       huart->TxXferCount = 0x00U;
00001a  2000              MOVS     r0,#0
00001c  84e0              STRH     r0,[r4,#0x26]
;;;3153       UART_EndTxTransfer(huart);
00001e  4620              MOV      r0,r4
000020  f7fffffe          BL       UART_EndTxTransfer
                  |L45.36|
;;;3154     }
;;;3155   
;;;3156     /* Stop UART DMA Rx request if ongoing */
;;;3157     dmarequest = HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR);
000024  6820              LDR      r0,[r4,#0]
000026  6940              LDR      r0,[r0,#0x14]
000028  f3c01580          UBFX     r5,r0,#6,#1
;;;3158     if ((huart->RxState == HAL_UART_STATE_BUSY_RX) && dmarequest)
00002c  f8940042          LDRB     r0,[r4,#0x42]
000030  2822              CMP      r0,#0x22
000032  d105              BNE      |L45.64|
000034  b125              CBZ      r5,|L45.64|
;;;3159     {
;;;3160       huart->RxXferCount = 0x00U;
000036  2000              MOVS     r0,#0
000038  85e0              STRH     r0,[r4,#0x2e]
;;;3161       UART_EndRxTransfer(huart);
00003a  4620              MOV      r0,r4
00003c  f7fffffe          BL       UART_EndRxTransfer
                  |L45.64|
;;;3162     }
;;;3163   
;;;3164     huart->ErrorCode |= HAL_UART_ERROR_DMA;
000040  6c60              LDR      r0,[r4,#0x44]
000042  f0400010          ORR      r0,r0,#0x10
000046  6460              STR      r0,[r4,#0x44]
;;;3165   #if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
;;;3166     /*Call registered error callback*/
;;;3167     huart->ErrorCallback(huart);
;;;3168   #else
;;;3169     /*Call legacy weak error callback*/
;;;3170     HAL_UART_ErrorCallback(huart);
000048  4620              MOV      r0,r4
00004a  f7fffffe          BL       HAL_UART_ErrorCallback
;;;3171   #endif /* USE_HAL_UART_REGISTER_CALLBACKS */
;;;3172   }
00004e  bd70              POP      {r4-r6,pc}
;;;3173   
                          ENDP


                          AREA ||i.UART_DMAReceiveCplt||, CODE, READONLY, ALIGN=1

                  UART_DMAReceiveCplt PROC
;;;3041     */
;;;3042   static void UART_DMAReceiveCplt(DMA_HandleTypeDef *hdma)
000000  b570              PUSH     {r4-r6,lr}
;;;3043   {
000002  4605              MOV      r5,r0
;;;3044     UART_HandleTypeDef *huart = (UART_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;
000004  6bac              LDR      r4,[r5,#0x38]
;;;3045   
;;;3046     /* DMA Normal mode*/
;;;3047     if ((hdma->Instance->CR & DMA_SxCR_CIRC) == 0U)
000006  6828              LDR      r0,[r5,#0]
000008  6800              LDR      r0,[r0,#0]
00000a  f4007080          AND      r0,r0,#0x100
00000e  2800              CMP      r0,#0
000010  d142              BNE      |L46.152|
;;;3048     {
;;;3049       huart->RxXferCount = 0U;
000012  85e0              STRH     r0,[r4,#0x2e]
;;;3050   
;;;3051       /* Disable RXNE, PE and ERR (Frame error, noise error, overrun error) interrupts */
;;;3052       ATOMIC_CLEAR_BIT(huart->Instance->CR1, USART_CR1_PEIE);
000014  bf00              NOP      
000016  bf00              NOP      
                  |L46.24|
000018  6821              LDR      r1,[r4,#0]
00001a  310c              ADDS     r1,r1,#0xc
00001c  e8511f00          LDREX    r1,[r1,#0]
000020  f4217080          BIC      r0,r1,#0x100
000024  6821              LDR      r1,[r4,#0]
000026  310c              ADDS     r1,r1,#0xc
000028  e8410200          STREX    r2,r0,[r1,#0]
00002c  2a00              CMP      r2,#0
00002e  d1f3              BNE      |L46.24|
000030  bf00              NOP      
;;;3053       ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
000032  bf00              NOP      
000034  bf00              NOP      
                  |L46.54|
000036  6821              LDR      r1,[r4,#0]
000038  3114              ADDS     r1,r1,#0x14
00003a  e8511f00          LDREX    r1,[r1,#0]
00003e  f0210001          BIC      r0,r1,#1
000042  6821              LDR      r1,[r4,#0]
000044  3114              ADDS     r1,r1,#0x14
000046  e8410200          STREX    r2,r0,[r1,#0]
00004a  2a00              CMP      r2,#0
00004c  d1f3              BNE      |L46.54|
00004e  bf00              NOP      
;;;3054   
;;;3055       /* Disable the DMA transfer for the receiver request by setting the DMAR bit
;;;3056          in the UART CR3 register */
;;;3057       ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAR);
000050  bf00              NOP      
000052  bf00              NOP      
                  |L46.84|
000054  6821              LDR      r1,[r4,#0]
000056  3114              ADDS     r1,r1,#0x14
000058  e8511f00          LDREX    r1,[r1,#0]
00005c  f0210040          BIC      r0,r1,#0x40
000060  6821              LDR      r1,[r4,#0]
000062  3114              ADDS     r1,r1,#0x14
000064  e8410200          STREX    r2,r0,[r1,#0]
000068  2a00              CMP      r2,#0
00006a  d1f3              BNE      |L46.84|
00006c  bf00              NOP      
;;;3058   
;;;3059       /* At end of Rx process, restore huart->RxState to Ready */
;;;3060       huart->RxState = HAL_UART_STATE_READY;
00006e  2020              MOVS     r0,#0x20
000070  f8840042          STRB     r0,[r4,#0x42]
;;;3061   
;;;3062       /* If Reception till IDLE event has been selected, Disable IDLE Interrupt */
;;;3063       if (huart->ReceptionType == HAL_UART_RECEPTION_TOIDLE)
000074  6b20              LDR      r0,[r4,#0x30]
000076  2801              CMP      r0,#1
000078  d10e              BNE      |L46.152|
;;;3064       {
;;;3065         ATOMIC_CLEAR_BIT(huart->Instance->CR1, USART_CR1_IDLEIE);
00007a  bf00              NOP      
00007c  bf00              NOP      
                  |L46.126|
00007e  6821              LDR      r1,[r4,#0]
000080  310c              ADDS     r1,r1,#0xc
000082  e8511f00          LDREX    r1,[r1,#0]
000086  f0210010          BIC      r0,r1,#0x10
00008a  6821              LDR      r1,[r4,#0]
00008c  310c              ADDS     r1,r1,#0xc
00008e  e8410200          STREX    r2,r0,[r1,#0]
000092  2a00              CMP      r2,#0
000094  d1f3              BNE      |L46.126|
000096  bf00              NOP      
                  |L46.152|
;;;3066       }
;;;3067     }
;;;3068   
;;;3069     /* Initialize type of RxEvent that correspond to RxEvent callback execution;
;;;3070      In this case, Rx Event type is Transfer Complete */
;;;3071     huart->RxEventType = HAL_UART_RXEVENT_TC;
000098  2000              MOVS     r0,#0
00009a  6360              STR      r0,[r4,#0x34]
;;;3072   
;;;3073     /* Check current reception Mode :
;;;3074        If Reception till IDLE event has been selected : use Rx Event callback */
;;;3075     if (huart->ReceptionType == HAL_UART_RECEPTION_TOIDLE)
00009c  6b20              LDR      r0,[r4,#0x30]
00009e  2801              CMP      r0,#1
0000a0  d104              BNE      |L46.172|
;;;3076     {
;;;3077   #if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
;;;3078       /*Call registered Rx Event callback*/
;;;3079       huart->RxEventCallback(huart, huart->RxXferSize);
;;;3080   #else
;;;3081       /*Call legacy weak Rx Event callback*/
;;;3082       HAL_UARTEx_RxEventCallback(huart, huart->RxXferSize);
0000a2  8da1              LDRH     r1,[r4,#0x2c]
0000a4  4620              MOV      r0,r4
0000a6  f7fffffe          BL       HAL_UARTEx_RxEventCallback
0000aa  e002              B        |L46.178|
                  |L46.172|
;;;3083   #endif /* USE_HAL_UART_REGISTER_CALLBACKS */
;;;3084     }
;;;3085     else
;;;3086     {
;;;3087       /* In other cases : use Rx Complete callback */
;;;3088   #if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
;;;3089       /*Call registered Rx complete callback*/
;;;3090       huart->RxCpltCallback(huart);
;;;3091   #else
;;;3092       /*Call legacy weak Rx complete callback*/
;;;3093       HAL_UART_RxCpltCallback(huart);
0000ac  4620              MOV      r0,r4
0000ae  f7fffffe          BL       HAL_UART_RxCpltCallback
                  |L46.178|
;;;3094   #endif /* USE_HAL_UART_REGISTER_CALLBACKS */
;;;3095     }
;;;3096   }
0000b2  bd70              POP      {r4-r6,pc}
;;;3097   
                          ENDP


                          AREA ||i.UART_DMARxAbortCallback||, CODE, READONLY, ALIGN=1

                  UART_DMARxAbortCallback PROC
;;;3428     */
;;;3429   static void UART_DMARxAbortCallback(DMA_HandleTypeDef *hdma)
000000  b570              PUSH     {r4-r6,lr}
;;;3430   {
000002  4605              MOV      r5,r0
;;;3431     UART_HandleTypeDef *huart = (UART_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;
000004  6bac              LDR      r4,[r5,#0x38]
;;;3432   
;;;3433     huart->hdmarx->XferAbortCallback = NULL;
000006  2000              MOVS     r0,#0
000008  6be1              LDR      r1,[r4,#0x3c]
00000a  6508              STR      r0,[r1,#0x50]
;;;3434   
;;;3435     /* Check if an Abort process is still ongoing */
;;;3436     if (huart->hdmatx != NULL)
00000c  6ba0              LDR      r0,[r4,#0x38]
00000e  b118              CBZ      r0,|L47.24|
;;;3437     {
;;;3438       if (huart->hdmatx->XferAbortCallback != NULL)
000010  6ba0              LDR      r0,[r4,#0x38]
000012  6d00              LDR      r0,[r0,#0x50]
000014  b100              CBZ      r0,|L47.24|
                  |L47.22|
;;;3439       {
;;;3440         return;
;;;3441       }
;;;3442     }
;;;3443   
;;;3444     /* No Abort process still ongoing : All DMA channels are aborted, call user Abort Complete callback */
;;;3445     huart->TxXferCount = 0x00U;
;;;3446     huart->RxXferCount = 0x00U;
;;;3447   
;;;3448     /* Reset ErrorCode */
;;;3449     huart->ErrorCode = HAL_UART_ERROR_NONE;
;;;3450   
;;;3451     /* Restore huart->gState and huart->RxState to Ready */
;;;3452     huart->gState  = HAL_UART_STATE_READY;
;;;3453     huart->RxState = HAL_UART_STATE_READY;
;;;3454     huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
;;;3455   
;;;3456     /* Call user Abort complete callback */
;;;3457   #if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
;;;3458     /* Call registered Abort complete callback */
;;;3459     huart->AbortCpltCallback(huart);
;;;3460   #else
;;;3461     /* Call legacy weak Abort complete callback */
;;;3462     HAL_UART_AbortCpltCallback(huart);
;;;3463   #endif /* USE_HAL_UART_REGISTER_CALLBACKS */
;;;3464   }
000016  bd70              POP      {r4-r6,pc}
                  |L47.24|
000018  2000              MOVS     r0,#0                 ;3445
00001a  84e0              STRH     r0,[r4,#0x26]         ;3445
00001c  85e0              STRH     r0,[r4,#0x2e]         ;3446
00001e  6460              STR      r0,[r4,#0x44]         ;3449
000020  2020              MOVS     r0,#0x20              ;3452
000022  f8840041          STRB     r0,[r4,#0x41]         ;3452
000026  f8840042          STRB     r0,[r4,#0x42]         ;3453
00002a  2000              MOVS     r0,#0                 ;3454
00002c  6320              STR      r0,[r4,#0x30]         ;3454
00002e  4620              MOV      r0,r4                 ;3462
000030  f7fffffe          BL       HAL_UART_AbortCpltCallback
000034  bf00              NOP      
000036  e7ee              B        |L47.22|
;;;3465   
                          ENDP


                          AREA ||i.UART_DMARxHalfCplt||, CODE, READONLY, ALIGN=1

                  UART_DMARxHalfCplt PROC
;;;3103     */
;;;3104   static void UART_DMARxHalfCplt(DMA_HandleTypeDef *hdma)
000000  b570              PUSH     {r4-r6,lr}
;;;3105   {
000002  4605              MOV      r5,r0
;;;3106     UART_HandleTypeDef *huart = (UART_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;
000004  6bac              LDR      r4,[r5,#0x38]
;;;3107   
;;;3108     /* Initialize type of RxEvent that correspond to RxEvent callback execution;
;;;3109        In this case, Rx Event type is Half Transfer */
;;;3110     huart->RxEventType = HAL_UART_RXEVENT_HT;
000006  2001              MOVS     r0,#1
000008  6360              STR      r0,[r4,#0x34]
;;;3111   
;;;3112     /* Check current reception Mode :
;;;3113        If Reception till IDLE event has been selected : use Rx Event callback */
;;;3114     if (huart->ReceptionType == HAL_UART_RECEPTION_TOIDLE)
00000a  6b20              LDR      r0,[r4,#0x30]
00000c  2801              CMP      r0,#1
00000e  d105              BNE      |L48.28|
;;;3115     {
;;;3116   #if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
;;;3117       /*Call registered Rx Event callback*/
;;;3118       huart->RxEventCallback(huart, huart->RxXferSize / 2U);
;;;3119   #else
;;;3120       /*Call legacy weak Rx Event callback*/
;;;3121       HAL_UARTEx_RxEventCallback(huart, huart->RxXferSize / 2U);
000010  8da0              LDRH     r0,[r4,#0x2c]
000012  0841              LSRS     r1,r0,#1
000014  4620              MOV      r0,r4
000016  f7fffffe          BL       HAL_UARTEx_RxEventCallback
00001a  e002              B        |L48.34|
                  |L48.28|
;;;3122   #endif /* USE_HAL_UART_REGISTER_CALLBACKS */
;;;3123     }
;;;3124     else
;;;3125     {
;;;3126       /* In other cases : use Rx Half Complete callback */
;;;3127   #if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
;;;3128       /*Call registered Rx Half complete callback*/
;;;3129       huart->RxHalfCpltCallback(huart);
;;;3130   #else
;;;3131       /*Call legacy weak Rx Half complete callback*/
;;;3132       HAL_UART_RxHalfCpltCallback(huart);
00001c  4620              MOV      r0,r4
00001e  f7fffffe          BL       HAL_UART_RxHalfCpltCallback
                  |L48.34|
;;;3133   #endif /* USE_HAL_UART_REGISTER_CALLBACKS */
;;;3134     }
;;;3135   }
000022  bd70              POP      {r4-r6,pc}
;;;3136   
                          ENDP


                          AREA ||i.UART_DMARxOnlyAbortCallback||, CODE, READONLY, ALIGN=1

                  UART_DMARxOnlyAbortCallback PROC
;;;3502     */
;;;3503   static void UART_DMARxOnlyAbortCallback(DMA_HandleTypeDef *hdma)
000000  b570              PUSH     {r4-r6,lr}
;;;3504   {
000002  4605              MOV      r5,r0
;;;3505     UART_HandleTypeDef *huart = (UART_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;
000004  6bac              LDR      r4,[r5,#0x38]
;;;3506   
;;;3507     huart->RxXferCount = 0x00U;
000006  2000              MOVS     r0,#0
000008  85e0              STRH     r0,[r4,#0x2e]
;;;3508   
;;;3509     /* Restore huart->RxState to Ready */
;;;3510     huart->RxState = HAL_UART_STATE_READY;
00000a  2020              MOVS     r0,#0x20
00000c  f8840042          STRB     r0,[r4,#0x42]
;;;3511     huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
000010  2000              MOVS     r0,#0
000012  6320              STR      r0,[r4,#0x30]
;;;3512   
;;;3513     /* Call user Abort complete callback */
;;;3514   #if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
;;;3515     /* Call registered Abort Receive Complete Callback */
;;;3516     huart->AbortReceiveCpltCallback(huart);
;;;3517   #else
;;;3518     /* Call legacy weak Abort Receive Complete Callback */
;;;3519     HAL_UART_AbortReceiveCpltCallback(huart);
000014  4620              MOV      r0,r4
000016  f7fffffe          BL       HAL_UART_AbortReceiveCpltCallback
;;;3520   #endif /* USE_HAL_UART_REGISTER_CALLBACKS */
;;;3521   }
00001a  bd70              POP      {r4-r6,pc}
;;;3522   
                          ENDP


                          AREA ||i.UART_DMATransmitCplt||, CODE, READONLY, ALIGN=1

                  UART_DMATransmitCplt PROC
;;;2987     */
;;;2988   static void UART_DMATransmitCplt(DMA_HandleTypeDef *hdma)
000000  b570              PUSH     {r4-r6,lr}
;;;2989   {
000002  4605              MOV      r5,r0
;;;2990     UART_HandleTypeDef *huart = (UART_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;
000004  6bac              LDR      r4,[r5,#0x38]
;;;2991     /* DMA Normal mode*/
;;;2992     if ((hdma->Instance->CR & DMA_SxCR_CIRC) == 0U)
000006  6828              LDR      r0,[r5,#0]
000008  6800              LDR      r0,[r0,#0]
00000a  f4007080          AND      r0,r0,#0x100
00000e  b9f8              CBNZ     r0,|L50.80|
;;;2993     {
;;;2994       huart->TxXferCount = 0x00U;
000010  2000              MOVS     r0,#0
000012  84e0              STRH     r0,[r4,#0x26]
;;;2995   
;;;2996       /* Disable the DMA transfer for transmit request by setting the DMAT bit
;;;2997          in the UART CR3 register */
;;;2998       ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAT);
000014  bf00              NOP      
000016  bf00              NOP      
                  |L50.24|
000018  6821              LDR      r1,[r4,#0]
00001a  3114              ADDS     r1,r1,#0x14
00001c  e8511f00          LDREX    r1,[r1,#0]
000020  f0210080          BIC      r0,r1,#0x80
000024  6821              LDR      r1,[r4,#0]
000026  3114              ADDS     r1,r1,#0x14
000028  e8410200          STREX    r2,r0,[r1,#0]
00002c  2a00              CMP      r2,#0
00002e  d1f3              BNE      |L50.24|
000030  bf00              NOP      
;;;2999   
;;;3000       /* Enable the UART Transmit Complete Interrupt */
;;;3001       ATOMIC_SET_BIT(huart->Instance->CR1, USART_CR1_TCIE);
000032  bf00              NOP      
000034  bf00              NOP      
                  |L50.54|
000036  6821              LDR      r1,[r4,#0]
000038  310c              ADDS     r1,r1,#0xc
00003a  e8511f00          LDREX    r1,[r1,#0]
00003e  f0410040          ORR      r0,r1,#0x40
000042  6821              LDR      r1,[r4,#0]
000044  310c              ADDS     r1,r1,#0xc
000046  e8410200          STREX    r2,r0,[r1,#0]
00004a  2a00              CMP      r2,#0
00004c  d1f3              BNE      |L50.54|
00004e  e002              B        |L50.86|
                  |L50.80|
;;;3002   
;;;3003     }
;;;3004     /* DMA Circular mode */
;;;3005     else
;;;3006     {
;;;3007   #if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
;;;3008       /*Call registered Tx complete callback*/
;;;3009       huart->TxCpltCallback(huart);
;;;3010   #else
;;;3011       /*Call legacy weak Tx complete callback*/
;;;3012       HAL_UART_TxCpltCallback(huart);
000050  4620              MOV      r0,r4
000052  f7fffffe          BL       HAL_UART_TxCpltCallback
                  |L50.86|
;;;3013   #endif /* USE_HAL_UART_REGISTER_CALLBACKS */
;;;3014     }
;;;3015   }
000056  bd70              POP      {r4-r6,pc}
;;;3016   
                          ENDP


                          AREA ||i.UART_DMATxAbortCallback||, CODE, READONLY, ALIGN=1

                  UART_DMATxAbortCallback PROC
;;;3382     */
;;;3383   static void UART_DMATxAbortCallback(DMA_HandleTypeDef *hdma)
000000  b570              PUSH     {r4-r6,lr}
;;;3384   {
000002  4605              MOV      r5,r0
;;;3385     UART_HandleTypeDef *huart = (UART_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;
000004  6bac              LDR      r4,[r5,#0x38]
;;;3386   
;;;3387     huart->hdmatx->XferAbortCallback = NULL;
000006  2000              MOVS     r0,#0
000008  6ba1              LDR      r1,[r4,#0x38]
00000a  6508              STR      r0,[r1,#0x50]
;;;3388   
;;;3389     /* Check if an Abort process is still ongoing */
;;;3390     if (huart->hdmarx != NULL)
00000c  6be0              LDR      r0,[r4,#0x3c]
00000e  b118              CBZ      r0,|L51.24|
;;;3391     {
;;;3392       if (huart->hdmarx->XferAbortCallback != NULL)
000010  6be0              LDR      r0,[r4,#0x3c]
000012  6d00              LDR      r0,[r0,#0x50]
000014  b100              CBZ      r0,|L51.24|
                  |L51.22|
;;;3393       {
;;;3394         return;
;;;3395       }
;;;3396     }
;;;3397   
;;;3398     /* No Abort process still ongoing : All DMA channels are aborted, call user Abort Complete callback */
;;;3399     huart->TxXferCount = 0x00U;
;;;3400     huart->RxXferCount = 0x00U;
;;;3401   
;;;3402     /* Reset ErrorCode */
;;;3403     huart->ErrorCode = HAL_UART_ERROR_NONE;
;;;3404   
;;;3405     /* Restore huart->gState and huart->RxState to Ready */
;;;3406     huart->gState  = HAL_UART_STATE_READY;
;;;3407     huart->RxState = HAL_UART_STATE_READY;
;;;3408     huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
;;;3409   
;;;3410     /* Call user Abort complete callback */
;;;3411   #if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
;;;3412     /* Call registered Abort complete callback */
;;;3413     huart->AbortCpltCallback(huart);
;;;3414   #else
;;;3415     /* Call legacy weak Abort complete callback */
;;;3416     HAL_UART_AbortCpltCallback(huart);
;;;3417   #endif /* USE_HAL_UART_REGISTER_CALLBACKS */
;;;3418   }
000016  bd70              POP      {r4-r6,pc}
                  |L51.24|
000018  2000              MOVS     r0,#0                 ;3399
00001a  84e0              STRH     r0,[r4,#0x26]         ;3399
00001c  85e0              STRH     r0,[r4,#0x2e]         ;3400
00001e  6460              STR      r0,[r4,#0x44]         ;3403
000020  2020              MOVS     r0,#0x20              ;3406
000022  f8840041          STRB     r0,[r4,#0x41]         ;3406
000026  f8840042          STRB     r0,[r4,#0x42]         ;3407
00002a  2000              MOVS     r0,#0                 ;3408
00002c  6320              STR      r0,[r4,#0x30]         ;3408
00002e  4620              MOV      r0,r4                 ;3416
000030  f7fffffe          BL       HAL_UART_AbortCpltCallback
000034  bf00              NOP      
000036  e7ee              B        |L51.22|
;;;3419   
                          ENDP


                          AREA ||i.UART_DMATxHalfCplt||, CODE, READONLY, ALIGN=1

                  UART_DMATxHalfCplt PROC
;;;3022     */
;;;3023   static void UART_DMATxHalfCplt(DMA_HandleTypeDef *hdma)
000000  b570              PUSH     {r4-r6,lr}
;;;3024   {
000002  4604              MOV      r4,r0
;;;3025     UART_HandleTypeDef *huart = (UART_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;
000004  6ba5              LDR      r5,[r4,#0x38]
;;;3026   
;;;3027   #if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
;;;3028     /*Call registered Tx complete callback*/
;;;3029     huart->TxHalfCpltCallback(huart);
;;;3030   #else
;;;3031     /*Call legacy weak Tx complete callback*/
;;;3032     HAL_UART_TxHalfCpltCallback(huart);
000006  4628              MOV      r0,r5
000008  f7fffffe          BL       HAL_UART_TxHalfCpltCallback
;;;3033   #endif /* USE_HAL_UART_REGISTER_CALLBACKS */
;;;3034   }
00000c  bd70              POP      {r4-r6,pc}
;;;3035   
                          ENDP


                          AREA ||i.UART_DMATxOnlyAbortCallback||, CODE, READONLY, ALIGN=1

                  UART_DMATxOnlyAbortCallback PROC
;;;3474     */
;;;3475   static void UART_DMATxOnlyAbortCallback(DMA_HandleTypeDef *hdma)
000000  b570              PUSH     {r4-r6,lr}
;;;3476   {
000002  4605              MOV      r5,r0
;;;3477     UART_HandleTypeDef *huart = (UART_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;
000004  6bac              LDR      r4,[r5,#0x38]
;;;3478   
;;;3479     huart->TxXferCount = 0x00U;
000006  2000              MOVS     r0,#0
000008  84e0              STRH     r0,[r4,#0x26]
;;;3480   
;;;3481     /* Restore huart->gState to Ready */
;;;3482     huart->gState = HAL_UART_STATE_READY;
00000a  2020              MOVS     r0,#0x20
00000c  f8840041          STRB     r0,[r4,#0x41]
;;;3483   
;;;3484     /* Call user Abort complete callback */
;;;3485   #if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
;;;3486     /* Call registered Abort Transmit Complete Callback */
;;;3487     huart->AbortTransmitCpltCallback(huart);
;;;3488   #else
;;;3489     /* Call legacy weak Abort Transmit Complete Callback */
;;;3490     HAL_UART_AbortTransmitCpltCallback(huart);
000010  4620              MOV      r0,r4
000012  f7fffffe          BL       HAL_UART_AbortTransmitCpltCallback
;;;3491   #endif /* USE_HAL_UART_REGISTER_CALLBACKS */
;;;3492   }
000016  bd70              POP      {r4-r6,pc}
;;;3493   
                          ENDP


                          AREA ||i.UART_EndRxTransfer||, CODE, READONLY, ALIGN=1

                  UART_EndRxTransfer PROC
;;;3334     */
;;;3335   static void UART_EndRxTransfer(UART_HandleTypeDef *huart)
000000  bf00              NOP      
;;;3336   {
;;;3337     /* Disable RXNE, PE and ERR (Frame error, noise error, overrun error) interrupts */
;;;3338     ATOMIC_CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE));
000002  bf00              NOP      
                  |L54.4|
000004  6802              LDR      r2,[r0,#0]
000006  320c              ADDS     r2,r2,#0xc
000008  e8522f00          LDREX    r2,[r2,#0]
00000c  f4227190          BIC      r1,r2,#0x120
000010  6802              LDR      r2,[r0,#0]
000012  320c              ADDS     r2,r2,#0xc
000014  e8421300          STREX    r3,r1,[r2,#0]
000018  2b00              CMP      r3,#0
00001a  d1f3              BNE      |L54.4|
00001c  bf00              NOP      
;;;3339     ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
00001e  bf00              NOP      
000020  bf00              NOP      
                  |L54.34|
000022  6802              LDR      r2,[r0,#0]
000024  3214              ADDS     r2,r2,#0x14
000026  e8522f00          LDREX    r2,[r2,#0]
00002a  f0220101          BIC      r1,r2,#1
00002e  6802              LDR      r2,[r0,#0]
000030  3214              ADDS     r2,r2,#0x14
000032  e8421300          STREX    r3,r1,[r2,#0]
000036  2b00              CMP      r3,#0
000038  d1f3              BNE      |L54.34|
00003a  bf00              NOP      
;;;3340   
;;;3341     /* In case of reception waiting for IDLE event, disable also the IDLE IE interrupt source */
;;;3342     if (huart->ReceptionType == HAL_UART_RECEPTION_TOIDLE)
00003c  6b01              LDR      r1,[r0,#0x30]
00003e  2901              CMP      r1,#1
000040  d10e              BNE      |L54.96|
;;;3343     {
;;;3344       ATOMIC_CLEAR_BIT(huart->Instance->CR1, USART_CR1_IDLEIE);
000042  bf00              NOP      
000044  bf00              NOP      
                  |L54.70|
000046  6802              LDR      r2,[r0,#0]
000048  320c              ADDS     r2,r2,#0xc
00004a  e8522f00          LDREX    r2,[r2,#0]
00004e  f0220110          BIC      r1,r2,#0x10
000052  6802              LDR      r2,[r0,#0]
000054  320c              ADDS     r2,r2,#0xc
000056  e8421300          STREX    r3,r1,[r2,#0]
00005a  2b00              CMP      r3,#0
00005c  d1f3              BNE      |L54.70|
00005e  bf00              NOP      
                  |L54.96|
;;;3345     }
;;;3346   
;;;3347     /* At end of Rx process, restore huart->RxState to Ready */
;;;3348     huart->RxState = HAL_UART_STATE_READY;
000060  2120              MOVS     r1,#0x20
000062  f8801042          STRB     r1,[r0,#0x42]
;;;3349     huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
000066  2100              MOVS     r1,#0
000068  6301              STR      r1,[r0,#0x30]
;;;3350   }
00006a  4770              BX       lr
;;;3351   
                          ENDP


                          AREA ||i.UART_EndTransmit_IT||, CODE, READONLY, ALIGN=1

                  UART_EndTransmit_IT PROC
;;;3568     */
;;;3569   static HAL_StatusTypeDef UART_EndTransmit_IT(UART_HandleTypeDef *huart)
000000  b510              PUSH     {r4,lr}
;;;3570   {
000002  4604              MOV      r4,r0
;;;3571     /* Disable the UART Transmit Complete Interrupt */
;;;3572     __HAL_UART_DISABLE_IT(huart, UART_IT_TC);
000004  6820              LDR      r0,[r4,#0]
000006  68c0              LDR      r0,[r0,#0xc]
000008  f0200040          BIC      r0,r0,#0x40
00000c  6821              LDR      r1,[r4,#0]
00000e  60c8              STR      r0,[r1,#0xc]
;;;3573   
;;;3574     /* Tx process is ended, restore huart->gState to Ready */
;;;3575     huart->gState = HAL_UART_STATE_READY;
000010  2020              MOVS     r0,#0x20
000012  f8840041          STRB     r0,[r4,#0x41]
;;;3576   
;;;3577   #if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
;;;3578     /*Call registered Tx complete callback*/
;;;3579     huart->TxCpltCallback(huart);
;;;3580   #else
;;;3581     /*Call legacy weak Tx complete callback*/
;;;3582     HAL_UART_TxCpltCallback(huart);
000016  4620              MOV      r0,r4
000018  f7fffffe          BL       HAL_UART_TxCpltCallback
;;;3583   #endif /* USE_HAL_UART_REGISTER_CALLBACKS */
;;;3584   
;;;3585     return HAL_OK;
00001c  2000              MOVS     r0,#0
;;;3586   }
00001e  bd10              POP      {r4,pc}
;;;3587   
                          ENDP


                          AREA ||i.UART_EndTxTransfer||, CODE, READONLY, ALIGN=1

                  UART_EndTxTransfer PROC
;;;3320     */
;;;3321   static void UART_EndTxTransfer(UART_HandleTypeDef *huart)
000000  bf00              NOP      
;;;3322   {
;;;3323     /* Disable TXEIE and TCIE interrupts */
;;;3324     ATOMIC_CLEAR_BIT(huart->Instance->CR1, (USART_CR1_TXEIE | USART_CR1_TCIE));
000002  bf00              NOP      
                  |L56.4|
000004  6802              LDR      r2,[r0,#0]
000006  320c              ADDS     r2,r2,#0xc
000008  e8522f00          LDREX    r2,[r2,#0]
00000c  f02201c0          BIC      r1,r2,#0xc0
000010  6802              LDR      r2,[r0,#0]
000012  320c              ADDS     r2,r2,#0xc
000014  e8421300          STREX    r3,r1,[r2,#0]
000018  2b00              CMP      r3,#0
00001a  d1f3              BNE      |L56.4|
00001c  bf00              NOP      
;;;3325   
;;;3326     /* At end of Tx process, restore huart->gState to Ready */
;;;3327     huart->gState = HAL_UART_STATE_READY;
00001e  2120              MOVS     r1,#0x20
000020  f8801041          STRB     r1,[r0,#0x41]
;;;3328   }
000024  4770              BX       lr
;;;3329   
                          ENDP


                          AREA ||i.UART_Receive_IT||, CODE, READONLY, ALIGN=1

                  UART_Receive_IT PROC
;;;3593     */
;;;3594   static HAL_StatusTypeDef UART_Receive_IT(UART_HandleTypeDef *huart)
000000  b5f8              PUSH     {r3-r7,lr}
;;;3595   {
000002  4604              MOV      r4,r0
;;;3596     uint8_t  *pdata8bits;
;;;3597     uint16_t *pdata16bits;
;;;3598   
;;;3599     /* Check that a Rx process is ongoing */
;;;3600     if (huart->RxState == HAL_UART_STATE_BUSY_RX)
000004  f8940042          LDRB     r0,[r4,#0x42]
000008  2822              CMP      r0,#0x22
00000a  d175              BNE      |L57.248|
;;;3601     {
;;;3602       if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
00000c  68a0              LDR      r0,[r4,#8]
00000e  f5b05f80          CMP      r0,#0x1000
000012  d10c              BNE      |L57.46|
000014  6920              LDR      r0,[r4,#0x10]
000016  b950              CBNZ     r0,|L57.46|
;;;3603       {
;;;3604         pdata8bits  = NULL;
000018  2500              MOVS     r5,#0
;;;3605         pdata16bits = (uint16_t *) huart->pRxBuffPtr;
00001a  6aa6              LDR      r6,[r4,#0x28]
;;;3606         *pdata16bits = (uint16_t)(huart->Instance->DR & (uint16_t)0x01FF);
00001c  6820              LDR      r0,[r4,#0]
00001e  6840              LDR      r0,[r0,#4]
000020  f3c00008          UBFX     r0,r0,#0,#9
000024  8030              STRH     r0,[r6,#0]
;;;3607         huart->pRxBuffPtr += 2U;
000026  6aa0              LDR      r0,[r4,#0x28]
000028  1c80              ADDS     r0,r0,#2
00002a  62a0              STR      r0,[r4,#0x28]
00002c  e015              B        |L57.90|
                  |L57.46|
;;;3608       }
;;;3609       else
;;;3610       {
;;;3611         pdata8bits = (uint8_t *) huart->pRxBuffPtr;
00002e  6aa5              LDR      r5,[r4,#0x28]
;;;3612         pdata16bits  = NULL;
000030  2600              MOVS     r6,#0
;;;3613   
;;;3614         if ((huart->Init.WordLength == UART_WORDLENGTH_9B) || ((huart->Init.WordLength == UART_WORDLENGTH_8B) && (huart->Init.Parity == UART_PARITY_NONE)))
000032  68a0              LDR      r0,[r4,#8]
000034  f5b05f80          CMP      r0,#0x1000
000038  d003              BEQ      |L57.66|
00003a  68a0              LDR      r0,[r4,#8]
00003c  b928              CBNZ     r0,|L57.74|
00003e  6920              LDR      r0,[r4,#0x10]
000040  b918              CBNZ     r0,|L57.74|
                  |L57.66|
;;;3615         {
;;;3616           *pdata8bits = (uint8_t)(huart->Instance->DR & (uint8_t)0x00FF);
000042  6820              LDR      r0,[r4,#0]
000044  6840              LDR      r0,[r0,#4]
000046  7028              STRB     r0,[r5,#0]
000048  e004              B        |L57.84|
                  |L57.74|
;;;3617         }
;;;3618         else
;;;3619         {
;;;3620           *pdata8bits = (uint8_t)(huart->Instance->DR & (uint8_t)0x007F);
00004a  6820              LDR      r0,[r4,#0]
00004c  6840              LDR      r0,[r0,#4]
00004e  f000007f          AND      r0,r0,#0x7f
000052  7028              STRB     r0,[r5,#0]
                  |L57.84|
;;;3621         }
;;;3622         huart->pRxBuffPtr += 1U;
000054  6aa0              LDR      r0,[r4,#0x28]
000056  1c40              ADDS     r0,r0,#1
000058  62a0              STR      r0,[r4,#0x28]
                  |L57.90|
;;;3623       }
;;;3624   
;;;3625       if (--huart->RxXferCount == 0U)
00005a  8de0              LDRH     r0,[r4,#0x2e]
00005c  1e40              SUBS     r0,r0,#1
00005e  b280              UXTH     r0,r0
000060  85e0              STRH     r0,[r4,#0x2e]
000062  2800              CMP      r0,#0
000064  d146              BNE      |L57.244|
;;;3626       {
;;;3627         /* Disable the UART Data Register not empty Interrupt */
;;;3628         __HAL_UART_DISABLE_IT(huart, UART_IT_RXNE);
000066  6820              LDR      r0,[r4,#0]
000068  68c0              LDR      r0,[r0,#0xc]
00006a  f0200020          BIC      r0,r0,#0x20
00006e  6821              LDR      r1,[r4,#0]
000070  60c8              STR      r0,[r1,#0xc]
;;;3629   
;;;3630         /* Disable the UART Parity Error Interrupt */
;;;3631         __HAL_UART_DISABLE_IT(huart, UART_IT_PE);
000072  6820              LDR      r0,[r4,#0]
000074  68c0              LDR      r0,[r0,#0xc]
000076  f4207080          BIC      r0,r0,#0x100
00007a  6821              LDR      r1,[r4,#0]
00007c  60c8              STR      r0,[r1,#0xc]
;;;3632   
;;;3633         /* Disable the UART Error Interrupt: (Frame error, noise error, overrun error) */
;;;3634         __HAL_UART_DISABLE_IT(huart, UART_IT_ERR);
00007e  6820              LDR      r0,[r4,#0]
000080  6940              LDR      r0,[r0,#0x14]
000082  f0200001          BIC      r0,r0,#1
000086  6821              LDR      r1,[r4,#0]
000088  6148              STR      r0,[r1,#0x14]
;;;3635   
;;;3636         /* Rx process is completed, restore huart->RxState to Ready */
;;;3637         huart->RxState = HAL_UART_STATE_READY;
00008a  2020              MOVS     r0,#0x20
00008c  f8840042          STRB     r0,[r4,#0x42]
;;;3638   
;;;3639         /* Initialize type of RxEvent to Transfer Complete */
;;;3640         huart->RxEventType = HAL_UART_RXEVENT_TC;
000090  2000              MOVS     r0,#0
000092  6360              STR      r0,[r4,#0x34]
;;;3641   
;;;3642         /* Check current reception Mode :
;;;3643            If Reception till IDLE event has been selected : */
;;;3644         if (huart->ReceptionType == HAL_UART_RECEPTION_TOIDLE)
000094  6b20              LDR      r0,[r4,#0x30]
000096  2801              CMP      r0,#1
000098  d126              BNE      |L57.232|
;;;3645         {
;;;3646           /* Set reception type to Standard */
;;;3647           huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
00009a  2000              MOVS     r0,#0
00009c  6320              STR      r0,[r4,#0x30]
;;;3648   
;;;3649           /* Disable IDLE interrupt */
;;;3650           ATOMIC_CLEAR_BIT(huart->Instance->CR1, USART_CR1_IDLEIE);
00009e  bf00              NOP      
0000a0  bf00              NOP      
                  |L57.162|
0000a2  6821              LDR      r1,[r4,#0]
0000a4  310c              ADDS     r1,r1,#0xc
0000a6  e8511f00          LDREX    r1,[r1,#0]
0000aa  f0210010          BIC      r0,r1,#0x10
0000ae  6821              LDR      r1,[r4,#0]
0000b0  310c              ADDS     r1,r1,#0xc
0000b2  e8410200          STREX    r2,r0,[r1,#0]
0000b6  2a00              CMP      r2,#0
0000b8  d1f3              BNE      |L57.162|
0000ba  bf00              NOP      
;;;3651   
;;;3652           /* Check if IDLE flag is set */
;;;3653           if (__HAL_UART_GET_FLAG(huart, UART_FLAG_IDLE))
0000bc  6820              LDR      r0,[r4,#0]
0000be  6800              LDR      r0,[r0,#0]
0000c0  f0000010          AND      r0,r0,#0x10
0000c4  2810              CMP      r0,#0x10
0000c6  d10a              BNE      |L57.222|
;;;3654           {
;;;3655             /* Clear IDLE flag in ISR */
;;;3656             __HAL_UART_CLEAR_IDLEFLAG(huart);
0000c8  bf00              NOP      
0000ca  2000              MOVS     r0,#0
0000cc  9000              STR      r0,[sp,#0]
0000ce  6820              LDR      r0,[r4,#0]
0000d0  6800              LDR      r0,[r0,#0]
0000d2  9000              STR      r0,[sp,#0]
0000d4  6820              LDR      r0,[r4,#0]
0000d6  6840              LDR      r0,[r0,#4]
0000d8  9000              STR      r0,[sp,#0]
0000da  bf00              NOP      
0000dc  bf00              NOP      
                  |L57.222|
;;;3657           }
;;;3658   
;;;3659   #if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
;;;3660           /*Call registered Rx Event callback*/
;;;3661           huart->RxEventCallback(huart, huart->RxXferSize);
;;;3662   #else
;;;3663           /*Call legacy weak Rx Event callback*/
;;;3664           HAL_UARTEx_RxEventCallback(huart, huart->RxXferSize);
0000de  8da1              LDRH     r1,[r4,#0x2c]
0000e0  4620              MOV      r0,r4
0000e2  f7fffffe          BL       HAL_UARTEx_RxEventCallback
0000e6  e002              B        |L57.238|
                  |L57.232|
;;;3665   #endif /* USE_HAL_UART_REGISTER_CALLBACKS */
;;;3666         }
;;;3667         else
;;;3668         {
;;;3669           /* Standard reception API called */
;;;3670   #if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
;;;3671           /*Call registered Rx complete callback*/
;;;3672           huart->RxCpltCallback(huart);
;;;3673   #else
;;;3674           /*Call legacy weak Rx complete callback*/
;;;3675           HAL_UART_RxCpltCallback(huart);
0000e8  4620              MOV      r0,r4
0000ea  f7fffffe          BL       HAL_UART_RxCpltCallback
                  |L57.238|
;;;3676   #endif /* USE_HAL_UART_REGISTER_CALLBACKS */
;;;3677         }
;;;3678   
;;;3679         return HAL_OK;
0000ee  2000              MOVS     r0,#0
                  |L57.240|
;;;3680       }
;;;3681       return HAL_OK;
;;;3682     }
;;;3683     else
;;;3684     {
;;;3685       return HAL_BUSY;
;;;3686     }
;;;3687   }
0000f0  bdf8              POP      {r3-r7,pc}
0000f2  e001              B        |L57.248|
                  |L57.244|
0000f4  2000              MOVS     r0,#0                 ;3681
0000f6  e7fb              B        |L57.240|
                  |L57.248|
0000f8  2002              MOVS     r0,#2                 ;3685
0000fa  e7f9              B        |L57.240|
;;;3688   
                          ENDP


                          AREA ||i.UART_SetConfig||, CODE, READONLY, ALIGN=2

                  UART_SetConfig PROC
;;;3694     */
;;;3695   static void UART_SetConfig(UART_HandleTypeDef *huart)
000000  e92d4ff8          PUSH     {r3-r11,lr}
;;;3696   {
000004  4604              MOV      r4,r0
;;;3697     uint32_t tmpreg;
;;;3698     uint32_t pclk;
;;;3699   
;;;3700     /* Check the parameters */
;;;3701     assert_param(IS_UART_BAUDRATE(huart->Init.BaudRate));
;;;3702     assert_param(IS_UART_STOPBITS(huart->Init.StopBits));
;;;3703     assert_param(IS_UART_PARITY(huart->Init.Parity));
;;;3704     assert_param(IS_UART_MODE(huart->Init.Mode));
;;;3705   
;;;3706     /*-------------------------- USART CR2 Configuration -----------------------*/
;;;3707     /* Configure the UART Stop Bits: Set STOP[13:12] bits
;;;3708        according to huart->Init.StopBits value */
;;;3709     MODIFY_REG(huart->Instance->CR2, USART_CR2_STOP, huart->Init.StopBits);
000006  6820              LDR      r0,[r4,#0]
000008  6900              LDR      r0,[r0,#0x10]
00000a  f4205040          BIC      r0,r0,#0x3000
00000e  68e1              LDR      r1,[r4,#0xc]
000010  4308              ORRS     r0,r0,r1
000012  6821              LDR      r1,[r4,#0]
000014  6108              STR      r0,[r1,#0x10]
;;;3710   
;;;3711     /*-------------------------- USART CR1 Configuration -----------------------*/
;;;3712     /* Configure the UART Word Length, Parity and mode:
;;;3713        Set the M bits according to huart->Init.WordLength value
;;;3714        Set PCE and PS bits according to huart->Init.Parity value
;;;3715        Set TE and RE bits according to huart->Init.Mode value
;;;3716        Set OVER8 bit according to huart->Init.OverSampling value */
;;;3717   
;;;3718     tmpreg = (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling;
000016  6921              LDR      r1,[r4,#0x10]
000018  68a0              LDR      r0,[r4,#8]
00001a  4308              ORRS     r0,r0,r1
00001c  6961              LDR      r1,[r4,#0x14]
00001e  4308              ORRS     r0,r0,r1
000020  69e1              LDR      r1,[r4,#0x1c]
000022  4308              ORRS     r0,r0,r1
000024  9000              STR      r0,[sp,#0]
;;;3719     MODIFY_REG(huart->Instance->CR1,
000026  6820              LDR      r0,[r4,#0]
000028  68c0              LDR      r0,[r0,#0xc]
00002a  f249610c          MOV      r1,#0x960c
00002e  4388              BICS     r0,r0,r1
000030  9900              LDR      r1,[sp,#0]
000032  4308              ORRS     r0,r0,r1
000034  6821              LDR      r1,[r4,#0]
000036  60c8              STR      r0,[r1,#0xc]
;;;3720                (uint32_t)(USART_CR1_M | USART_CR1_PCE | USART_CR1_PS | USART_CR1_TE | USART_CR1_RE | USART_CR1_OVER8),
;;;3721                tmpreg);
;;;3722   
;;;3723     /*-------------------------- USART CR3 Configuration -----------------------*/
;;;3724     /* Configure the UART HFC: Set CTSE and RTSE bits according to huart->Init.HwFlowCtl value */
;;;3725     MODIFY_REG(huart->Instance->CR3, (USART_CR3_RTSE | USART_CR3_CTSE), huart->Init.HwFlowCtl);
000038  6820              LDR      r0,[r4,#0]
00003a  6940              LDR      r0,[r0,#0x14]
00003c  f4207040          BIC      r0,r0,#0x300
000040  69a1              LDR      r1,[r4,#0x18]
000042  4308              ORRS     r0,r0,r1
000044  6821              LDR      r1,[r4,#0]
000046  6148              STR      r0,[r1,#0x14]
;;;3726   
;;;3727   
;;;3728   #if defined(USART6) && defined(UART9) && defined(UART10)
;;;3729       if ((huart->Instance == USART1) || (huart->Instance == USART6) || (huart->Instance == UART9) || (huart->Instance == UART10))
;;;3730       {
;;;3731         pclk = HAL_RCC_GetPCLK2Freq();
;;;3732       }
;;;3733   #elif defined(USART6)
;;;3734       if ((huart->Instance == USART1) || (huart->Instance == USART6))
000048  4976              LDR      r1,|L58.548|
00004a  6820              LDR      r0,[r4,#0]
00004c  4288              CMP      r0,r1
00004e  d003              BEQ      |L58.88|
000050  4975              LDR      r1,|L58.552|
000052  6820              LDR      r0,[r4,#0]
000054  4288              CMP      r0,r1
000056  d103              BNE      |L58.96|
                  |L58.88|
;;;3735       {
;;;3736         pclk = HAL_RCC_GetPCLK2Freq();
000058  f7fffffe          BL       HAL_RCC_GetPCLK2Freq
00005c  4681              MOV      r9,r0
00005e  e002              B        |L58.102|
                  |L58.96|
;;;3737       }
;;;3738   #else
;;;3739       if (huart->Instance == USART1)
;;;3740       {
;;;3741         pclk = HAL_RCC_GetPCLK2Freq();
;;;3742       }
;;;3743   #endif /* USART6 */
;;;3744       else
;;;3745       {
;;;3746         pclk = HAL_RCC_GetPCLK1Freq();
000060  f7fffffe          BL       HAL_RCC_GetPCLK1Freq
000064  4681              MOV      r9,r0
                  |L58.102|
;;;3747       }
;;;3748     /*-------------------------- USART BRR Configuration ---------------------*/
;;;3749     if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
000066  69e0              LDR      r0,[r4,#0x1c]
000068  f5b04f00          CMP      r0,#0x8000
00006c  d16c              BNE      |L58.328|
;;;3750     {
;;;3751       huart->Instance->BRR = UART_BRR_SAMPLING8(pclk, huart->Init.BaudRate);
00006e  2002              MOVS     r0,#2
000070  6861              LDR      r1,[r4,#4]
000072  fba05001          UMULL    r5,r0,r0,r1
000076  4603              MOV      r3,r0
000078  2019              MOVS     r0,#0x19
00007a  fba97000          UMULL    r7,r0,r9,r0
00007e  4601              MOV      r1,r0
000080  462a              MOV      r2,r5
000082  4638              MOV      r0,r7
000084  f7fffffe          BL       __aeabi_uldivmod
000088  2164              MOVS     r1,#0x64
00008a  fbb0f0f1          UDIV     r0,r0,r1
00008e  ea4f1a00          LSL      r10,r0,#4
000092  2002              MOVS     r0,#2
000094  6861              LDR      r1,[r4,#4]
000096  fba05101          UMULL    r5,r1,r0,r1
00009a  460b              MOV      r3,r1
00009c  2019              MOVS     r0,#0x19
00009e  fba97100          UMULL    r7,r1,r9,r0
0000a2  462a              MOV      r2,r5
0000a4  4638              MOV      r0,r7
0000a6  f7fffffe          BL       __aeabi_uldivmod
0000aa  4683              MOV      r11,r0
0000ac  2002              MOVS     r0,#2
0000ae  6861              LDR      r1,[r4,#4]
0000b0  fba05001          UMULL    r5,r0,r0,r1
0000b4  4603              MOV      r3,r0
0000b6  2019              MOVS     r0,#0x19
0000b8  fba97100          UMULL    r7,r1,r9,r0
0000bc  462a              MOV      r2,r5
0000be  4638              MOV      r0,r7
0000c0  f7fffffe          BL       __aeabi_uldivmod
0000c4  2164              MOVS     r1,#0x64
0000c6  fbb0f0f1          UDIV     r0,r0,r1
0000ca  eb0001c0          ADD      r1,r0,r0,LSL #3
0000ce  eb011000          ADD      r0,r1,r0,LSL #4
0000d2  ebab0080          SUB      r0,r11,r0,LSL #2
0000d6  2132              MOVS     r1,#0x32
0000d8  eb0100c0          ADD      r0,r1,r0,LSL #3
0000dc  2164              MOVS     r1,#0x64
0000de  fbb0f0f1          UDIV     r0,r0,r1
0000e2  f00000f8          AND      r0,r0,#0xf8
0000e6  eb0a0a40          ADD      r10,r10,r0,LSL #1
0000ea  2002              MOVS     r0,#2
0000ec  6861              LDR      r1,[r4,#4]
0000ee  fba05001          UMULL    r5,r0,r0,r1
0000f2  4603              MOV      r3,r0
0000f4  2019              MOVS     r0,#0x19
0000f6  fba97000          UMULL    r7,r0,r9,r0
0000fa  4601              MOV      r1,r0
0000fc  462a              MOV      r2,r5
0000fe  4638              MOV      r0,r7
000100  f7fffffe          BL       __aeabi_uldivmod
000104  4683              MOV      r11,r0
000106  2002              MOVS     r0,#2
000108  6861              LDR      r1,[r4,#4]
00010a  fba05001          UMULL    r5,r0,r0,r1
00010e  4603              MOV      r3,r0
000110  2019              MOVS     r0,#0x19
000112  fba97100          UMULL    r7,r1,r9,r0
000116  462a              MOV      r2,r5
000118  4638              MOV      r0,r7
00011a  f7fffffe          BL       __aeabi_uldivmod
00011e  2164              MOVS     r1,#0x64
000120  fbb0f0f1          UDIV     r0,r0,r1
000124  eb0001c0          ADD      r1,r0,r0,LSL #3
000128  eb011000          ADD      r0,r1,r0,LSL #4
00012c  ebab0080          SUB      r0,r11,r0,LSL #2
000130  2132              MOVS     r1,#0x32
000132  eb0100c0          ADD      r0,r1,r0,LSL #3
000136  2164              MOVS     r1,#0x64
000138  fbb0f0f1          UDIV     r0,r0,r1
00013c  f0000007          AND      r0,r0,#7
000140  4450              ADD      r0,r0,r10
000142  6821              LDR      r1,[r4,#0]
000144  6088              STR      r0,[r1,#8]
000146  e06a              B        |L58.542|
                  |L58.328|
;;;3752     }
;;;3753     else
;;;3754     {
;;;3755       huart->Instance->BRR = UART_BRR_SAMPLING16(pclk, huart->Init.BaudRate);
000148  2004              MOVS     r0,#4
00014a  6861              LDR      r1,[r4,#4]
00014c  fba05001          UMULL    r5,r0,r0,r1
000150  4603              MOV      r3,r0
000152  2019              MOVS     r0,#0x19
000154  fba97000          UMULL    r7,r0,r9,r0
000158  4601              MOV      r1,r0
00015a  462a              MOV      r2,r5
00015c  4638              MOV      r0,r7
00015e  f7fffffe          BL       __aeabi_uldivmod
000162  4682              MOV      r10,r0
000164  2004              MOVS     r0,#4
000166  6861              LDR      r1,[r4,#4]
000168  fba05001          UMULL    r5,r0,r0,r1
00016c  4603              MOV      r3,r0
00016e  2019              MOVS     r0,#0x19
000170  fba97000          UMULL    r7,r0,r9,r0
000174  4601              MOV      r1,r0
000176  462a              MOV      r2,r5
000178  4638              MOV      r0,r7
00017a  f7fffffe          BL       __aeabi_uldivmod
00017e  2164              MOVS     r1,#0x64
000180  fbb0f0f1          UDIV     r0,r0,r1
000184  eb0001c0          ADD      r1,r0,r0,LSL #3
000188  eb011000          ADD      r0,r1,r0,LSL #4
00018c  ebaa0080          SUB      r0,r10,r0,LSL #2
000190  2132              MOVS     r1,#0x32
000192  eb011000          ADD      r0,r1,r0,LSL #4
000196  2164              MOVS     r1,#0x64
000198  fbb0f0f1          UDIV     r0,r0,r1
00019c  f0000af0          AND      r10,r0,#0xf0
0001a0  2004              MOVS     r0,#4
0001a2  6861              LDR      r1,[r4,#4]
0001a4  fba07001          UMULL    r7,r0,r0,r1
0001a8  4603              MOV      r3,r0
0001aa  2019              MOVS     r0,#0x19
0001ac  fba95100          UMULL    r5,r1,r9,r0
0001b0  463a              MOV      r2,r7
0001b2  4628              MOV      r0,r5
0001b4  f7fffffe          BL       __aeabi_uldivmod
0001b8  2164              MOVS     r1,#0x64
0001ba  fbb0f0f1          UDIV     r0,r0,r1
0001be  eb0a1a00          ADD      r10,r10,r0,LSL #4
0001c2  2004              MOVS     r0,#4
0001c4  6861              LDR      r1,[r4,#4]
0001c6  fba05101          UMULL    r5,r1,r0,r1
0001ca  460b              MOV      r3,r1
0001cc  2019              MOVS     r0,#0x19
0001ce  fba97100          UMULL    r7,r1,r9,r0
0001d2  462a              MOV      r2,r5
0001d4  4638              MOV      r0,r7
0001d6  f7fffffe          BL       __aeabi_uldivmod
0001da  4683              MOV      r11,r0
0001dc  2004              MOVS     r0,#4
0001de  6861              LDR      r1,[r4,#4]
0001e0  fba05001          UMULL    r5,r0,r0,r1
0001e4  4603              MOV      r3,r0
0001e6  2019              MOVS     r0,#0x19
0001e8  fba97000          UMULL    r7,r0,r9,r0
0001ec  4601              MOV      r1,r0
0001ee  462a              MOV      r2,r5
0001f0  4638              MOV      r0,r7
0001f2  f7fffffe          BL       __aeabi_uldivmod
0001f6  2164              MOVS     r1,#0x64
0001f8  fbb0f0f1          UDIV     r0,r0,r1
0001fc  eb0001c0          ADD      r1,r0,r0,LSL #3
000200  eb011000          ADD      r0,r1,r0,LSL #4
000204  ebab0080          SUB      r0,r11,r0,LSL #2
000208  2132              MOVS     r1,#0x32
00020a  eb011000          ADD      r0,r1,r0,LSL #4
00020e  2164              MOVS     r1,#0x64
000210  fbb0f0f1          UDIV     r0,r0,r1
000214  f000000f          AND      r0,r0,#0xf
000218  4450              ADD      r0,r0,r10
00021a  6821              LDR      r1,[r4,#0]
00021c  6088              STR      r0,[r1,#8]
                  |L58.542|
;;;3756     }
;;;3757   }
00021e  e8bd8ff8          POP      {r3-r11,pc}
;;;3758   
                          ENDP

000222  0000              DCW      0x0000
                  |L58.548|
                          DCD      0x40011000
                  |L58.552|
                          DCD      0x40011400

                          AREA ||i.UART_Start_Receive_DMA||, CODE, READONLY, ALIGN=2

                  UART_Start_Receive_DMA PROC
;;;3270     */
;;;3271   HAL_StatusTypeDef UART_Start_Receive_DMA(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size)
000000  b577              PUSH     {r0-r2,r4-r6,lr}
;;;3272   {
000002  b081              SUB      sp,sp,#4
000004  4604              MOV      r4,r0
000006  4615              MOV      r5,r2
;;;3273     uint32_t *tmp;
;;;3274   
;;;3275     huart->pRxBuffPtr = pData;
000008  9802              LDR      r0,[sp,#8]
00000a  62a0              STR      r0,[r4,#0x28]
;;;3276     huart->RxXferSize = Size;
00000c  85a5              STRH     r5,[r4,#0x2c]
;;;3277   
;;;3278     huart->ErrorCode = HAL_UART_ERROR_NONE;
00000e  2000              MOVS     r0,#0
000010  6460              STR      r0,[r4,#0x44]
;;;3279     huart->RxState = HAL_UART_STATE_BUSY_RX;
000012  2022              MOVS     r0,#0x22
000014  f8840042          STRB     r0,[r4,#0x42]
;;;3280   
;;;3281     /* Set the UART DMA transfer complete callback */
;;;3282     huart->hdmarx->XferCpltCallback = UART_DMAReceiveCplt;
000018  4828              LDR      r0,|L59.188|
00001a  6be1              LDR      r1,[r4,#0x3c]
00001c  63c8              STR      r0,[r1,#0x3c]
;;;3283   
;;;3284     /* Set the UART DMA Half transfer complete callback */
;;;3285     huart->hdmarx->XferHalfCpltCallback = UART_DMARxHalfCplt;
00001e  4828              LDR      r0,|L59.192|
000020  6be1              LDR      r1,[r4,#0x3c]
000022  6408              STR      r0,[r1,#0x40]
;;;3286   
;;;3287     /* Set the DMA error callback */
;;;3288     huart->hdmarx->XferErrorCallback = UART_DMAError;
000024  4827              LDR      r0,|L59.196|
000026  6be1              LDR      r1,[r4,#0x3c]
000028  64c8              STR      r0,[r1,#0x4c]
;;;3289   
;;;3290     /* Set the DMA abort callback */
;;;3291     huart->hdmarx->XferAbortCallback = NULL;
00002a  2000              MOVS     r0,#0
00002c  6be1              LDR      r1,[r4,#0x3c]
00002e  6508              STR      r0,[r1,#0x50]
;;;3292   
;;;3293     /* Enable the DMA stream */
;;;3294     tmp = (uint32_t *)&pData;
000030  ae02              ADD      r6,sp,#8
;;;3295     HAL_DMA_Start_IT(huart->hdmarx, (uint32_t)&huart->Instance->DR, *(uint32_t *)tmp, Size);
000032  6832              LDR      r2,[r6,#0]
000034  6823              LDR      r3,[r4,#0]
000036  1d19              ADDS     r1,r3,#4
000038  462b              MOV      r3,r5
00003a  6be0              LDR      r0,[r4,#0x3c]
00003c  f7fffffe          BL       HAL_DMA_Start_IT
;;;3296   
;;;3297     /* Clear the Overrun flag just before enabling the DMA Rx request: can be mandatory for the second transfer */
;;;3298     __HAL_UART_CLEAR_OREFLAG(huart);
000040  bf00              NOP      
000042  2000              MOVS     r0,#0
000044  9000              STR      r0,[sp,#0]
000046  6820              LDR      r0,[r4,#0]
000048  6800              LDR      r0,[r0,#0]
00004a  9000              STR      r0,[sp,#0]
00004c  6820              LDR      r0,[r4,#0]
00004e  6840              LDR      r0,[r0,#4]
000050  9000              STR      r0,[sp,#0]
000052  bf00              NOP      
000054  bf00              NOP      
;;;3299   
;;;3300     if (huart->Init.Parity != UART_PARITY_NONE)
000056  6920              LDR      r0,[r4,#0x10]
000058  b170              CBZ      r0,|L59.120|
;;;3301     {
;;;3302       /* Enable the UART Parity Error Interrupt */
;;;3303       ATOMIC_SET_BIT(huart->Instance->CR1, USART_CR1_PEIE);
00005a  bf00              NOP      
00005c  bf00              NOP      
                  |L59.94|
00005e  6821              LDR      r1,[r4,#0]
000060  310c              ADDS     r1,r1,#0xc
000062  e8511f00          LDREX    r1,[r1,#0]
000066  f4417080          ORR      r0,r1,#0x100
00006a  6821              LDR      r1,[r4,#0]
00006c  310c              ADDS     r1,r1,#0xc
00006e  e8410200          STREX    r2,r0,[r1,#0]
000072  2a00              CMP      r2,#0
000074  d1f3              BNE      |L59.94|
000076  bf00              NOP      
                  |L59.120|
;;;3304     }
;;;3305   
;;;3306     /* Enable the UART Error Interrupt: (Frame error, noise error, overrun error) */
;;;3307     ATOMIC_SET_BIT(huart->Instance->CR3, USART_CR3_EIE);
000078  bf00              NOP      
00007a  bf00              NOP      
                  |L59.124|
00007c  6821              LDR      r1,[r4,#0]
00007e  3114              ADDS     r1,r1,#0x14
000080  e8511f00          LDREX    r1,[r1,#0]
000084  f0410001          ORR      r0,r1,#1
000088  6821              LDR      r1,[r4,#0]
00008a  3114              ADDS     r1,r1,#0x14
00008c  e8410200          STREX    r2,r0,[r1,#0]
000090  2a00              CMP      r2,#0
000092  d1f3              BNE      |L59.124|
000094  bf00              NOP      
;;;3308   
;;;3309     /* Enable the DMA transfer for the receiver request by setting the DMAR bit
;;;3310     in the UART CR3 register */
;;;3311     ATOMIC_SET_BIT(huart->Instance->CR3, USART_CR3_DMAR);
000096  bf00              NOP      
000098  bf00              NOP      
                  |L59.154|
00009a  6821              LDR      r1,[r4,#0]
00009c  3114              ADDS     r1,r1,#0x14
00009e  e8511f00          LDREX    r1,[r1,#0]
0000a2  f0410040          ORR      r0,r1,#0x40
0000a6  6821              LDR      r1,[r4,#0]
0000a8  3114              ADDS     r1,r1,#0x14
0000aa  e8410200          STREX    r2,r0,[r1,#0]
0000ae  2a00              CMP      r2,#0
0000b0  d1f3              BNE      |L59.154|
0000b2  bf00              NOP      
;;;3312   
;;;3313     return HAL_OK;
0000b4  2000              MOVS     r0,#0
;;;3314   }
0000b6  b004              ADD      sp,sp,#0x10
0000b8  bd70              POP      {r4-r6,pc}
;;;3315   
                          ENDP

0000ba  0000              DCW      0x0000
                  |L59.188|
                          DCD      UART_DMAReceiveCplt
                  |L59.192|
                          DCD      UART_DMARxHalfCplt
                  |L59.196|
                          DCD      UART_DMAError

                          AREA ||i.UART_Start_Receive_IT||, CODE, READONLY, ALIGN=1

                  UART_Start_Receive_IT PROC
;;;3235     */
;;;3236   HAL_StatusTypeDef UART_Start_Receive_IT(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size)
000000  b510              PUSH     {r4,lr}
;;;3237   {
000002  4603              MOV      r3,r0
;;;3238     huart->pRxBuffPtr = pData;
000004  6299              STR      r1,[r3,#0x28]
;;;3239     huart->RxXferSize = Size;
000006  859a              STRH     r2,[r3,#0x2c]
;;;3240     huart->RxXferCount = Size;
000008  85da              STRH     r2,[r3,#0x2e]
;;;3241   
;;;3242     huart->ErrorCode = HAL_UART_ERROR_NONE;
00000a  2000              MOVS     r0,#0
00000c  6458              STR      r0,[r3,#0x44]
;;;3243     huart->RxState = HAL_UART_STATE_BUSY_RX;
00000e  2022              MOVS     r0,#0x22
000010  f8830042          STRB     r0,[r3,#0x42]
;;;3244   
;;;3245     if (huart->Init.Parity != UART_PARITY_NONE)
000014  6918              LDR      r0,[r3,#0x10]
000016  b128              CBZ      r0,|L60.36|
;;;3246     {
;;;3247       /* Enable the UART Parity Error Interrupt */
;;;3248       __HAL_UART_ENABLE_IT(huart, UART_IT_PE);
000018  6818              LDR      r0,[r3,#0]
00001a  68c0              LDR      r0,[r0,#0xc]
00001c  f4407080          ORR      r0,r0,#0x100
000020  681c              LDR      r4,[r3,#0]
000022  60e0              STR      r0,[r4,#0xc]
                  |L60.36|
;;;3249     }
;;;3250   
;;;3251     /* Enable the UART Error Interrupt: (Frame error, noise error, overrun error) */
;;;3252     __HAL_UART_ENABLE_IT(huart, UART_IT_ERR);
000024  6818              LDR      r0,[r3,#0]
000026  6940              LDR      r0,[r0,#0x14]
000028  f0400001          ORR      r0,r0,#1
00002c  681c              LDR      r4,[r3,#0]
00002e  6160              STR      r0,[r4,#0x14]
;;;3253   
;;;3254     /* Enable the UART Data Register not empty Interrupt */
;;;3255     __HAL_UART_ENABLE_IT(huart, UART_IT_RXNE);
000030  6818              LDR      r0,[r3,#0]
000032  68c0              LDR      r0,[r0,#0xc]
000034  f0400020          ORR      r0,r0,#0x20
000038  681c              LDR      r4,[r3,#0]
00003a  60e0              STR      r0,[r4,#0xc]
;;;3256   
;;;3257     return HAL_OK;
00003c  2000              MOVS     r0,#0
;;;3258   }
00003e  bd10              POP      {r4,pc}
;;;3259   
                          ENDP


                          AREA ||i.UART_Transmit_IT||, CODE, READONLY, ALIGN=1

                  UART_Transmit_IT PROC
;;;3528     */
;;;3529   static HAL_StatusTypeDef UART_Transmit_IT(UART_HandleTypeDef *huart)
000000  4601              MOV      r1,r0
;;;3530   {
;;;3531     const uint16_t *tmp;
;;;3532   
;;;3533     /* Check that a Tx process is ongoing */
;;;3534     if (huart->gState == HAL_UART_STATE_BUSY_TX)
000002  f8910041          LDRB     r0,[r1,#0x41]
000006  2821              CMP      r0,#0x21
000008  d128              BNE      |L61.92|
;;;3535     {
;;;3536       if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
00000a  6888              LDR      r0,[r1,#8]
00000c  f5b05f80          CMP      r0,#0x1000
000010  d10b              BNE      |L61.42|
000012  6908              LDR      r0,[r1,#0x10]
000014  b948              CBNZ     r0,|L61.42|
;;;3537       {
;;;3538         tmp = (const uint16_t *) huart->pTxBuffPtr;
000016  6a0a              LDR      r2,[r1,#0x20]
;;;3539         huart->Instance->DR = (uint16_t)(*tmp & (uint16_t)0x01FF);
000018  8810              LDRH     r0,[r2,#0]
00001a  f3c00008          UBFX     r0,r0,#0,#9
00001e  680b              LDR      r3,[r1,#0]
000020  6058              STR      r0,[r3,#4]
;;;3540         huart->pTxBuffPtr += 2U;
000022  6a08              LDR      r0,[r1,#0x20]
000024  1c80              ADDS     r0,r0,#2
000026  6208              STR      r0,[r1,#0x20]
000028  e005              B        |L61.54|
                  |L61.42|
;;;3541       }
;;;3542       else
;;;3543       {
;;;3544         huart->Instance->DR = (uint8_t)(*huart->pTxBuffPtr++ & (uint8_t)0x00FF);
00002a  6a0b              LDR      r3,[r1,#0x20]
00002c  1c58              ADDS     r0,r3,#1
00002e  6208              STR      r0,[r1,#0x20]
000030  7818              LDRB     r0,[r3,#0]
000032  680b              LDR      r3,[r1,#0]
000034  6058              STR      r0,[r3,#4]
                  |L61.54|
;;;3545       }
;;;3546   
;;;3547       if (--huart->TxXferCount == 0U)
000036  8cc8              LDRH     r0,[r1,#0x26]
000038  1e40              SUBS     r0,r0,#1
00003a  b280              UXTH     r0,r0
00003c  84c8              STRH     r0,[r1,#0x26]
00003e  b958              CBNZ     r0,|L61.88|
;;;3548       {
;;;3549         /* Disable the UART Transmit Data Register Empty Interrupt */
;;;3550         __HAL_UART_DISABLE_IT(huart, UART_IT_TXE);
000040  6808              LDR      r0,[r1,#0]
000042  68c0              LDR      r0,[r0,#0xc]
000044  f0200080          BIC      r0,r0,#0x80
000048  680b              LDR      r3,[r1,#0]
00004a  60d8              STR      r0,[r3,#0xc]
;;;3551   
;;;3552         /* Enable the UART Transmit Complete Interrupt */
;;;3553         __HAL_UART_ENABLE_IT(huart, UART_IT_TC);
00004c  6808              LDR      r0,[r1,#0]
00004e  68c0              LDR      r0,[r0,#0xc]
000050  f0400040          ORR      r0,r0,#0x40
000054  680b              LDR      r3,[r1,#0]
000056  60d8              STR      r0,[r3,#0xc]
                  |L61.88|
;;;3554       }
;;;3555       return HAL_OK;
000058  2000              MOVS     r0,#0
                  |L61.90|
;;;3556     }
;;;3557     else
;;;3558     {
;;;3559       return HAL_BUSY;
;;;3560     }
;;;3561   }
00005a  4770              BX       lr
                  |L61.92|
00005c  2002              MOVS     r0,#2                 ;3559
00005e  e7fc              B        |L61.90|
;;;3562   
                          ENDP


                          AREA ||i.UART_WaitOnFlagUntilTimeout||, CODE, READONLY, ALIGN=1

                  UART_WaitOnFlagUntilTimeout PROC
;;;3184     */
;;;3185   static HAL_StatusTypeDef UART_WaitOnFlagUntilTimeout(UART_HandleTypeDef *huart, uint32_t Flag, FlagStatus Status,
000000  e92d43f8          PUSH     {r3-r9,lr}
;;;3186                                                        uint32_t Tickstart, uint32_t Timeout)
;;;3187   {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4617              MOV      r7,r2
00000a  4698              MOV      r8,r3
00000c  9e08              LDR      r6,[sp,#0x20]
;;;3188     /* Wait until flag is set */
;;;3189     while ((__HAL_UART_GET_FLAG(huart, Flag) ? SET : RESET) == Status)
00000e  e031              B        |L62.116|
                  |L62.16|
;;;3190     {
;;;3191       /* Check for the Timeout */
;;;3192       if (Timeout != HAL_MAX_DELAY)
000010  1c70              ADDS     r0,r6,#1
000012  b370              CBZ      r0,|L62.114|
;;;3193       {
;;;3194         if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
000014  f7fffffe          BL       HAL_GetTick
000018  eba00008          SUB      r0,r0,r8
00001c  42b0              CMP      r0,r6
00001e  d800              BHI      |L62.34|
000020  b916              CBNZ     r6,|L62.40|
                  |L62.34|
;;;3195         {
;;;3196   
;;;3197           return HAL_TIMEOUT;
000022  2003              MOVS     r0,#3
                  |L62.36|
;;;3198         }
;;;3199   
;;;3200         if ((READ_BIT(huart->Instance->CR1, USART_CR1_RE) != 0U) && (Flag != UART_FLAG_TXE) && (Flag != UART_FLAG_TC))
;;;3201         {
;;;3202           if (__HAL_UART_GET_FLAG(huart, UART_FLAG_ORE) == SET)
;;;3203           {
;;;3204             /* Clear Overrun Error flag*/
;;;3205             __HAL_UART_CLEAR_OREFLAG(huart);
;;;3206   
;;;3207             /* Blocking error : transfer is aborted
;;;3208             Set the UART state ready to be able to start again the process,
;;;3209             Disable Rx Interrupts if ongoing */
;;;3210             UART_EndRxTransfer(huart);
;;;3211   
;;;3212             huart->ErrorCode = HAL_UART_ERROR_ORE;
;;;3213   
;;;3214             /* Process Unlocked */
;;;3215             __HAL_UNLOCK(huart);
;;;3216   
;;;3217             return HAL_ERROR;
;;;3218           }
;;;3219         }
;;;3220       }
;;;3221     }
;;;3222     return HAL_OK;
;;;3223   }
000024  e8bd83f8          POP      {r3-r9,pc}
                  |L62.40|
000028  6820              LDR      r0,[r4,#0]            ;3200
00002a  68c0              LDR      r0,[r0,#0xc]          ;3200
00002c  f0000004          AND      r0,r0,#4              ;3200
000030  b1f8              CBZ      r0,|L62.114|
000032  2d80              CMP      r5,#0x80              ;3200
000034  d01e              BEQ      |L62.116|
000036  2d40              CMP      r5,#0x40              ;3200
000038  d01c              BEQ      |L62.116|
00003a  6820              LDR      r0,[r4,#0]            ;3202
00003c  6800              LDR      r0,[r0,#0]            ;3202
00003e  f3c000c0          UBFX     r0,r0,#3,#1           ;3202
000042  b1b0              CBZ      r0,|L62.114|
000044  bf00              NOP                            ;3205
000046  2000              MOVS     r0,#0                 ;3205
000048  9000              STR      r0,[sp,#0]            ;3205
00004a  6820              LDR      r0,[r4,#0]            ;3205
00004c  6800              LDR      r0,[r0,#0]            ;3205
00004e  9000              STR      r0,[sp,#0]            ;3205
000050  6820              LDR      r0,[r4,#0]            ;3205
000052  6840              LDR      r0,[r0,#4]            ;3205
000054  9000              STR      r0,[sp,#0]            ;3205
000056  bf00              NOP                            ;3205
000058  bf00              NOP                            ;3205
00005a  4620              MOV      r0,r4                 ;3210
00005c  f7fffffe          BL       UART_EndRxTransfer
000060  2008              MOVS     r0,#8                 ;3212
000062  6460              STR      r0,[r4,#0x44]         ;3212
000064  bf00              NOP                            ;3215
000066  2000              MOVS     r0,#0                 ;3215
000068  f8840040          STRB     r0,[r4,#0x40]         ;3215
00006c  bf00              NOP                            ;3215
00006e  2001              MOVS     r0,#1                 ;3217
000070  e7d8              B        |L62.36|
                  |L62.114|
000072  e7ff              B        |L62.116|
                  |L62.116|
000074  6820              LDR      r0,[r4,#0]            ;3189
000076  6800              LDR      r0,[r0,#0]            ;3189
000078  4028              ANDS     r0,r0,r5              ;3189
00007a  42a8              CMP      r0,r5                 ;3189
00007c  d101              BNE      |L62.130|
00007e  2001              MOVS     r0,#1                 ;3189
000080  e000              B        |L62.132|
                  |L62.130|
000082  2000              MOVS     r0,#0                 ;3189
                  |L62.132|
000084  42b8              CMP      r0,r7                 ;3189
000086  d0c3              BEQ      |L62.16|
000088  2000              MOVS     r0,#0                 ;3222
00008a  e7cb              B        |L62.36|
;;;3224   
                          ENDP


;*** Start embedded assembler ***

#line 1 "../Drivers/STM32F4xx_HAL_Driver/Src/stm32f4xx_hal_uart.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___20_stm32f4xx_hal_uart_c_d497114f____REV16|
#line 208 "../Drivers/CMSIS/Include/cmsis_armcc.h"
|__asm___20_stm32f4xx_hal_uart_c_d497114f____REV16| PROC
#line 209

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___20_stm32f4xx_hal_uart_c_d497114f____REVSH|
#line 223
|__asm___20_stm32f4xx_hal_uart_c_d497114f____REVSH| PROC
#line 224

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___20_stm32f4xx_hal_uart_c_d497114f____RRX|
#line 410
|__asm___20_stm32f4xx_hal_uart_c_d497114f____RRX| PROC
#line 411

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
